(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.3.1";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component3(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component3.prototype.isReactComponent = {};
          Component3.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component3.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component3.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component3.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign(pureComponentPrototype, Component3.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement2(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self = null;
            var source = null;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config);
                }
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              self = config.__self === void 0 ? null : config.__self;
              source = config.__source === void 0 ? null : config.__source;
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement2(element, config, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self, source, owner, props);
          }
          function isValidElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement2(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement2(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext7(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef2(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo2(type, compare) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext9(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState4(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef7(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect7(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create2, deps);
          }
          function useInsertionEffect3(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create2, deps);
          }
          function useLayoutEffect2(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create2, deps);
          }
          function useCallback4(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo7(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create2, deps);
          }
          function useImperativeHandle(ref, create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create2, deps);
          }
          function useDebugValue2(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId4() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component4) {
            var prototype = Component4.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement2(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement2(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement2(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement2.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement2.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children2 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports.Children = Children2;
          exports.Component = Component3;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.act = act;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext7;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef2;
          exports.isValidElement = isValidElement2;
          exports.lazy = lazy;
          exports.memo = memo2;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback4;
          exports.useContext = useContext9;
          exports.useDebugValue = useDebugValue2;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect7;
          exports.useId = useId4;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect3;
          exports.useLayoutEffect = useLayoutEffect2;
          exports.useMemo = useMemo7;
          exports.useReducer = useReducer;
          exports.useRef = useRef7;
          exports.useState = useState4;
          exports.useSyncExternalStore = useSyncExternalStore;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React6 = require_react();
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config, self) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type, key, ref, self, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type, config, maybeKey, source, self) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref = null;
              if (maybeKey !== void 0) {
                {
                  checkKeyStringCoercion(maybeKey);
                }
                key = "" + maybeKey;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config, self);
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
              if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for (propName in defaultProps) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement2(object) {
            {
              return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                if (name) {
                  return "\n\nCheck the render method of `" + name + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            {
              if (typeof node !== "object") {
                return;
              }
              if (isArray(node)) {
                for (var i = 0; i < node.length; i++) {
                  var child = node[i];
                  if (isValidElement2(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement2(node)) {
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement2(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          var didWarnAboutKeySpread = {};
          function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
            {
              var validType = isValidElementType(type);
              if (!validType) {
                var info = "";
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                  typeString = "null";
                } else if (isArray(type)) {
                  typeString = "array";
                } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type;
                }
                error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type, props, key, source, self);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (isArray(children)) {
                      for (var i = 0; i < children.length; i++) {
                        validateChildKeys(children[i], type);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type);
                  }
                }
              }
              {
                if (hasOwnProperty.call(props, "key")) {
                  var componentName = getComponentNameFromType(type);
                  var keys = Object.keys(props).filter(function(k) {
                    return k !== "key";
                  });
                  var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
                  if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                    var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                    error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                    didWarnAboutKeySpread[componentName + beforeExample] = true;
                  }
                }
              }
              if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, false);
            }
          }
          var jsx10 = jsxWithValidationDynamic;
          var jsxs6 = jsxWithValidationStatic;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.jsx = jsx10;
          exports.jsxs = jsxs6;
        })();
      }
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React6 = require_react();
          var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useState4 = React6.useState, useEffect7 = React6.useEffect, useLayoutEffect2 = React6.useLayoutEffect, useDebugValue2 = React6.useDebugValue;
          var didWarnOld18Alpha = false;
          var didWarnUncachedGetSnapshot = false;
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            {
              if (!didWarnOld18Alpha) {
                if (React6.startTransition !== void 0) {
                  didWarnOld18Alpha = true;
                  error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
                }
              }
            }
            var value = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                if (!objectIs(value, cachedValue)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var _useState = useState4({
              inst: {
                value,
                getSnapshot
              }
            }), inst = _useState[0].inst, forceUpdate = _useState[1];
            useLayoutEffect2(function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            }, [subscribe, value, getSnapshot]);
            useEffect7(function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe(handleStoreChange);
            }, [subscribe]);
            useDebugValue2(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
            return getSnapshot();
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var isServerEnvironment = !canUseDOM;
          var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
          var useSyncExternalStore$2 = React6.useSyncExternalStore !== void 0 ? React6.useSyncExternalStore : shim;
          exports.useSyncExternalStore = useSyncExternalStore$2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
  var require_with_selector_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React6 = require_react();
          var shim = require_shim();
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useSyncExternalStore = shim.useSyncExternalStore;
          var useRef7 = React6.useRef, useEffect7 = React6.useEffect, useMemo7 = React6.useMemo, useDebugValue2 = React6.useDebugValue;
          function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
            var instRef = useRef7(null);
            var inst;
            if (instRef.current === null) {
              inst = {
                hasValue: false,
                value: null
              };
              instRef.current = inst;
            } else {
              inst = instRef.current;
            }
            var _useMemo = useMemo7(function() {
              var hasMemo = false;
              var memoizedSnapshot;
              var memoizedSelection;
              var memoizedSelector = function(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  var _nextSelection = selector(nextSnapshot);
                  if (isEqual !== void 0) {
                    if (inst.hasValue) {
                      var currentSelection = inst.value;
                      if (isEqual(currentSelection, _nextSelection)) {
                        memoizedSelection = currentSelection;
                        return currentSelection;
                      }
                    }
                  }
                  memoizedSelection = _nextSelection;
                  return _nextSelection;
                }
                var prevSnapshot = memoizedSnapshot;
                var prevSelection = memoizedSelection;
                if (objectIs(prevSnapshot, nextSnapshot)) {
                  return prevSelection;
                }
                var nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                  return prevSelection;
                }
                memoizedSnapshot = nextSnapshot;
                memoizedSelection = nextSelection;
                return nextSelection;
              };
              var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
              var getSnapshotWithSelector = function() {
                return memoizedSelector(getSnapshot());
              };
              var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              };
              return [getSnapshotWithSelector, getServerSnapshotWithSelector];
            }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
            var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
            useEffect7(function() {
              inst.hasValue = true;
              inst.value = value;
            }, [value]);
            useDebugValue2(value);
            return value;
          }
          exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_with_selector_development();
      }
    }
  });

  // features/agent/components/ChatInterface.tsx
  var import_react26 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  var import_react10 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
  var import_react = __toESM(require_react(), 1);
  var LayoutGroupContext = (0, import_react.createContext)({});

  // node_modules/framer-motion/dist/es/utils/use-constant.mjs
  var import_react2 = __toESM(require_react(), 1);
  function useConstant(init) {
    const ref = (0, import_react2.useRef)(null);
    if (ref.current === null) {
      ref.current = init();
    }
    return ref.current;
  }

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var import_react3 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-browser.mjs
  var isBrowser = typeof window !== "undefined";

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var useIsomorphicLayoutEffect = isBrowser ? import_react3.useLayoutEffect : import_react3.useEffect;

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
  var React3 = __toESM(require_react(), 1);
  var import_react7 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/PresenceContext.mjs
  var import_react4 = __toESM(require_react(), 1);
  var PresenceContext = /* @__PURE__ */ (0, import_react4.createContext)(null);

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

  // node_modules/motion-utils/dist/es/array.mjs
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1)
      arr.splice(index, 1);
  }

  // node_modules/motion-utils/dist/es/clamp.mjs
  var clamp = (min, max, v) => {
    if (v > max)
      return max;
    if (v < min)
      return min;
    return v;
  };

  // node_modules/motion-utils/dist/es/format-error-message.mjs
  function formatErrorMessage(message, errorCode) {
    return errorCode ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}` : message;
  }

  // node_modules/motion-utils/dist/es/errors.mjs
  var warning = () => {
  };
  var invariant = () => {
  };
  if (true) {
    warning = (check, message, errorCode) => {
      if (!check && typeof console !== "undefined") {
        console.warn(formatErrorMessage(message, errorCode));
      }
    };
    invariant = (check, message, errorCode) => {
      if (!check) {
        throw new Error(formatErrorMessage(message, errorCode));
      }
    };
  }

  // node_modules/motion-utils/dist/es/global-config.mjs
  var MotionGlobalConfig = {};

  // node_modules/motion-utils/dist/es/is-numerical-string.mjs
  var isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);

  // node_modules/motion-utils/dist/es/is-object.mjs
  function isObject(value) {
    return typeof value === "object" && value !== null;
  }

  // node_modules/motion-utils/dist/es/is-zero-value-string.mjs
  var isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);

  // node_modules/motion-utils/dist/es/memo.mjs
  // @__NO_SIDE_EFFECTS__
  function memo(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }

  // node_modules/motion-utils/dist/es/noop.mjs
  var noop = /* @__NO_SIDE_EFFECTS__ */ (any) => any;

  // node_modules/motion-utils/dist/es/pipe.mjs
  var combineFunctions = (a, b) => (v) => b(a(v));
  var pipe = (...transformers) => transformers.reduce(combineFunctions);

  // node_modules/motion-utils/dist/es/progress.mjs
  var progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
  };

  // node_modules/motion-utils/dist/es/subscription-manager.mjs
  var SubscriptionManager = class {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b, c);
      } else {
        for (let i = 0; i < numSubscriptions; i++) {
          const handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  };

  // node_modules/motion-utils/dist/es/time-conversion.mjs
  var secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
  var millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;

  // node_modules/motion-utils/dist/es/velocity-per-second.mjs
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }

  // node_modules/motion-utils/dist/es/warn-once.mjs
  var warned = /* @__PURE__ */ new Set();
  function warnOnce(condition, message, errorCode) {
    if (condition || warned.has(message))
      return;
    console.warn(formatErrorMessage(message, errorCode));
    warned.add(message);
  }

  // node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs
  var calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
  var subdivisionPrecision = 1e-7;
  var subdivisionMaxIterations = 12;
  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
  }

  // node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs
  var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

  // node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs
  var reverseEasing = (easing) => (p) => 1 - easing(1 - p);

  // node_modules/motion-utils/dist/es/easing/back.mjs
  var backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
  var backIn = /* @__PURE__ */ reverseEasing(backOut);
  var backInOut = /* @__PURE__ */ mirrorEasing(backIn);

  // node_modules/motion-utils/dist/es/easing/anticipate.mjs
  var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

  // node_modules/motion-utils/dist/es/easing/circ.mjs
  var circIn = (p) => 1 - Math.sin(Math.acos(p));
  var circOut = reverseEasing(circIn);
  var circInOut = mirrorEasing(circIn);

  // node_modules/motion-utils/dist/es/easing/ease.mjs
  var easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
  var easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
  var easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);

  // node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs
  var isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };

  // node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs
  var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

  // node_modules/motion-utils/dist/es/easing/utils/map.mjs
  var easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  var isValidEasing = (easing) => {
    return typeof easing === "string";
  };
  var easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
      invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`, "cubic-bezier-length");
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
      invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`, "invalid-easing-type");
      return easingLookup[definition];
    }
    return definition;
  };

  // node_modules/motion-dom/dist/es/frameloop/order.mjs
  var stepsOrder = [
    "setup",
    // Compute
    "read",
    // Read
    "resolveKeyframes",
    // Write/Read/Write/Read
    "preUpdate",
    // Compute
    "update",
    // Compute
    "preRender",
    // Compute
    "render",
    // Write
    "postRender"
    // Compute
  ];

  // node_modules/motion-dom/dist/es/stats/buffer.mjs
  var statsBuffer = {
    value: null,
    addProjectionMetrics: null
  };

  // node_modules/motion-dom/dist/es/frameloop/render-step.mjs
  function createRenderStep(runNextFrame, stepName) {
    let thisFrame = /* @__PURE__ */ new Set();
    let nextFrame = /* @__PURE__ */ new Set();
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    let latestFrameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    let numCalls = 0;
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      numCalls++;
      callback(latestFrameData);
    }
    const step = {
      /**
       * Schedule a process to run on the next frame.
       */
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (!queue.has(callback))
          queue.add(callback);
        return callback;
      },
      /**
       * Cancel the provided callback from running on the next frame.
       */
      cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
      /**
       * Execute all schedule callbacks.
       */
      process: (frameData2) => {
        latestFrameData = frameData2;
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        thisFrame.forEach(triggerCallback);
        if (stepName && statsBuffer.value) {
          statsBuffer.value.frameloop[stepName].push(numCalls);
        }
        numCalls = 0;
        thisFrame.clear();
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }

  // node_modules/motion-dom/dist/es/frameloop/batcher.mjs
  var maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
      return acc;
    }, {});
    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
      runNextFrame = false;
      if (!MotionGlobalConfig.useManualTiming) {
        state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
      }
      state.timestamp = timestamp;
      state.isProcessing = true;
      setup.process(state);
      read.process(state);
      resolveKeyframes.process(state);
      preUpdate.process(state);
      update.process(state);
      preRender.process(state);
      render.process(state);
      postRender.process(state);
      state.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i = 0; i < stepsOrder.length; i++) {
        steps[stepsOrder[i]].cancel(process2);
      }
    };
    return { schedule, cancel, state, steps };
  }

  // node_modules/motion-dom/dist/es/frameloop/frame.mjs
  var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

  // node_modules/motion-dom/dist/es/frameloop/sync-time.mjs
  var now;
  function clearTime() {
    now = void 0;
  }
  var time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };

  // node_modules/motion-dom/dist/es/stats/animation-count.mjs
  var activeAnimations = {
    layout: 0,
    mainThread: 0,
    waapi: 0
  };

  // node_modules/motion-dom/dist/es/animation/utils/is-css-variable.mjs
  var checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
  var isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
  var startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
  var isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

  // node_modules/motion-dom/dist/es/value/types/numbers/index.mjs
  var number = {
    test: (v) => typeof v === "number",
    parse: parseFloat,
    transform: (v) => v
  };
  var alpha = {
    ...number,
    transform: (v) => clamp(0, 1, v)
  };
  var scale = {
    ...number,
    default: 1
  };

  // node_modules/motion-dom/dist/es/value/types/utils/sanitize.mjs
  var sanitize = (v) => Math.round(v * 1e5) / 1e5;

  // node_modules/motion-dom/dist/es/value/types/utils/float-regex.mjs
  var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

  // node_modules/motion-dom/dist/es/value/types/utils/is-nullish.mjs
  function isNullish(v) {
    return v == null;
  }

  // node_modules/motion-dom/dist/es/value/types/utils/single-color-regex.mjs
  var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

  // node_modules/motion-dom/dist/es/value/types/color/utils.mjs
  var isColorString = (type, testProp) => (v) => {
    return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
  };
  var splitColor = (aName, bName, cName) => (v) => {
    if (typeof v !== "string")
      return v;
    const [a, b, c, alpha2] = v.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b),
      [cName]: parseFloat(c),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };

  // node_modules/motion-dom/dist/es/value/types/color/rgba.mjs
  var clampRgbUnit = (v) => clamp(0, 255, v);
  var rgbUnit = {
    ...number,
    transform: (v) => Math.round(clampRgbUnit(v))
  };
  var rgba = {
    test: /* @__PURE__ */ isColorString("rgb", "red"),
    parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };

  // node_modules/motion-dom/dist/es/value/types/color/hex.mjs
  function parseHex(v) {
    let r = "";
    let g = "";
    let b = "";
    let a = "";
    if (v.length > 5) {
      r = v.substring(1, 3);
      g = v.substring(3, 5);
      b = v.substring(5, 7);
      a = v.substring(7, 9);
    } else {
      r = v.substring(1, 2);
      g = v.substring(2, 3);
      b = v.substring(3, 4);
      a = v.substring(4, 5);
      r += r;
      g += g;
      b += b;
      a += a;
    }
    return {
      red: parseInt(r, 16),
      green: parseInt(g, 16),
      blue: parseInt(b, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1
    };
  }
  var hex = {
    test: /* @__PURE__ */ isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };

  // node_modules/motion-dom/dist/es/value/types/numbers/units.mjs
  var createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit}`
  });
  var degrees = /* @__PURE__ */ createUnitType("deg");
  var percent = /* @__PURE__ */ createUnitType("%");
  var px = /* @__PURE__ */ createUnitType("px");
  var vh = /* @__PURE__ */ createUnitType("vh");
  var vw = /* @__PURE__ */ createUnitType("vw");
  var progressPercentage = /* @__PURE__ */ (() => ({
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100)
  }))();

  // node_modules/motion-dom/dist/es/value/types/color/hsla.mjs
  var hsla = {
    test: /* @__PURE__ */ isColorString("hsl", "hue"),
    parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };

  // node_modules/motion-dom/dist/es/value/types/color/index.mjs
  var color = {
    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
    parse: (v) => {
      if (rgba.test(v)) {
        return rgba.parse(v);
      } else if (hsla.test(v)) {
        return hsla.parse(v);
      } else {
        return hex.parse(v);
      }
    },
    transform: (v) => {
      return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
    },
    getAnimatableNone: (v) => {
      const parsed = color.parse(v);
      parsed.alpha = 0;
      return color.transform(parsed);
    }
  };

  // node_modules/motion-dom/dist/es/value/types/utils/color-regex.mjs
  var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

  // node_modules/motion-dom/dist/es/value/types/complex/index.mjs
  function test(v) {
    return isNaN(v) && typeof v === "string" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;
  }
  var NUMBER_TOKEN = "number";
  var COLOR_TOKEN = "color";
  var VAR_TOKEN = "var";
  var VAR_FUNCTION_TOKEN = "var(";
  var SPLIT_TOKEN = "${}";
  var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types = [];
    let i = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i);
        types.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i);
        types.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i);
        types.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types };
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const { split, types } = analyseComplexValue(source);
    const numSections = split.length;
    return (v) => {
      let output = "";
      for (let i = 0; i < numSections; i++) {
        output += split[i];
        if (v[i] !== void 0) {
          const type = types[i];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v[i]);
          } else if (type === COLOR_TOKEN) {
            output += color.transform(v[i]);
          } else {
            output += v[i];
          }
        }
      }
      return output;
    };
  }
  var convertNumbersToZero = (v) => typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
  function getAnimatableNone(v) {
    const parsed = parseComplexValue(v);
    const transformer = createTransformer(v);
    return transformer(parsed.map(convertNumbersToZero));
  }
  var complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone
  };

  // node_modules/motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs
  function hueToRgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      red = hueToRgb(p, q, hue + 1 / 3);
      green = hueToRgb(p, q, hue);
      blue = hueToRgb(p, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }

  // node_modules/motion-dom/dist/es/utils/mix/immediate.mjs
  function mixImmediate(a, b) {
    return (p) => p > 0 ? b : a;
  }

  // node_modules/motion-dom/dist/es/utils/mix/number.mjs
  var mixNumber = (from, to, progress2) => {
    return from + (to - from) * progress2;
  };

  // node_modules/motion-dom/dist/es/utils/mix/color.mjs
  var mixLinearColor = (from, to, v) => {
    const fromExpo = from * from;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  var colorTypes = [hex, rgba, hsla];
  var getColorType = (v) => colorTypes.find((type) => type.test(v));
  function asRGBA(color2) {
    const type = getColorType(color2);
    warning(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable");
    if (!Boolean(type))
      return false;
    let model = type.parse(color2);
    if (type === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  var mixColor = (from, to) => {
    const fromRGBA = asRGBA(from);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from, to);
    }
    const blended = { ...fromRGBA };
    return (v) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba.transform(blended);
    };
  };

  // node_modules/motion-dom/dist/es/utils/mix/visibility.mjs
  var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p) => p <= 0 ? origin : target;
    } else {
      return (p) => p >= 1 ? target : origin;
    }
  }

  // node_modules/motion-dom/dist/es/utils/mix/complex.mjs
  function mixNumber2(a, b) {
    return (p) => mixNumber(a, b, p);
  }
  function getMixer(a) {
    if (typeof a === "number") {
      return mixNumber2;
    } else if (typeof a === "string") {
      return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === "object") {
      return color.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
    return (p) => {
      for (let i = 0; i < numValues; i++) {
        output[i] = blendValue[i](p);
      }
      return output;
    };
  }
  function mixObject(a, b) {
    const output = { ...a, ...b };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== void 0 && b[key] !== void 0) {
        blendValue[key] = getMixer(a[key])(a[key], b[key]);
      }
    }
    return (v) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i = 0; i < target.values.length; i++) {
      const type = target.types[i];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = origin.values[originIndex] ?? 0;
      orderedOrigin[i] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  var mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different");
      return mixImmediate(origin, target);
    }
  };

  // node_modules/motion-dom/dist/es/utils/mix/index.mjs
  function mix(from, to, p) {
    if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
      return mixNumber(from, to, p);
    }
    const mixer = getMixer(from);
    return mixer(from, to);
  }

  // node_modules/motion-dom/dist/es/animation/drivers/frame.mjs
  var frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
      stop: () => cancelFrame(passTimestamp),
      /**
       * If we're processing this frame we can use the
       * framelocked timestamp to keep things in sync.
       */
      now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };

  // node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs
  var generateLinearEasing = (easing, duration, resolution = 10) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i = 0; i < numPoints; i++) {
      points += Math.round(easing(i / (numPoints - 1)) * 1e4) / 1e4 + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  };

  // node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs
  var maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }

  // node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs
  function createGeneratorEasing(options, scale2 = 100, createGenerator) {
    const generator = createGenerator({ ...options, keyframes: [0, scale2] });
    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
    return {
      type: "keyframes",
      ease: (progress2) => {
        return generator.next(duration * progress2).value / scale2;
      },
      duration: millisecondsToSeconds(duration)
    };
  }

  // node_modules/motion-dom/dist/es/animation/generators/utils/velocity.mjs
  var velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t, current) {
    const prevT = Math.max(t - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
  }

  // node_modules/motion-dom/dist/es/animation/generators/spring/defaults.mjs
  var springDefaults = {
    // Default spring physics
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    // Default duration/bounce-based options
    duration: 800,
    // in ms
    bounce: 0.3,
    visualDuration: 0.3,
    // in seconds
    // Rest thresholds
    restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
    // Limits
    minDuration: 0.01,
    // in seconds
    maxDuration: 10,
    // in seconds
    minDamping: 0.05,
    maxDamping: 1
  };

  // node_modules/motion-dom/dist/es/animation/generators/spring/find.mjs
  var safeMin = 1e-3;
  function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
    let envelope;
    let derivative;
    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit");
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = calcAngularFreq(undampedFreq2, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - a / b * c;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f = Math.exp(-delta);
        const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d - e) * f) / g;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a * b;
      };
      derivative = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (velocity - undampedFreq2) * (duration * duration);
        return a * b;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  var rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i = 1; i < rootIterations; i++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }

  // node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs
  var durationKeys = ["duration", "bounce"];
  var physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys) {
    return keys.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      if (options.visualDuration) {
        const visualDuration = options.visualDuration;
        const root = 2 * Math.PI / (visualDuration * 1.2);
        const stiffness = root * root;
        const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping
        };
      } else {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    const options = typeof optionsOrVisualDuration !== "object" ? {
      visualDuration: optionsOrVisualDuration,
      keyframes: [0, 1],
      bounce
    } : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options;
    const origin = options.keyframes[0];
    const target = options.keyframes[options.keyframes.length - 1];
    const state = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: -millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t) => {
        const current = resolveSpring(t);
        if (!isResolvedFromDuration) {
          let currentVelocity = t === 0 ? initialVelocity : 0;
          if (dampingRatio < 1) {
            currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t >= duration;
        }
        state.value = state.done ? target : current;
        return state;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
        return calculatedDuration + "ms " + easing;
      },
      toTransition: () => {
      }
    };
    return generator;
  }
  spring.applyToOptions = (options) => {
    const generatorOptions = createGeneratorEasing(options, 100, spring);
    options.ease = generatorOptions.ease;
    options.duration = secondsToMilliseconds(generatorOptions.duration);
    options.type = "keyframes";
    return options;
  };

  // node_modules/motion-dom/dist/es/animation/generators/inertia.mjs
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
    const origin = keyframes2[0];
    const state = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
    const nearestBoundary = (v) => {
      if (min === void 0)
        return max;
      if (max === void 0)
        return min;
      return Math.abs(min - v) < Math.abs(max - v) ? min : max;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin;
    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
    const calcLatest = (t) => target + calcDelta(t);
    const applyFriction = (t) => {
      const delta = calcDelta(t);
      const latest = calcLatest(t);
      state.done = Math.abs(delta) <= restDelta;
      state.value = state.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t) => {
      if (!isOutOfBounds(state.value))
        return;
      timeReachedBoundary = t;
      spring$1 = spring({
        keyframes: [state.value, nearestBoundary(state.value)],
        velocity: calcGeneratorVelocity(calcLatest, t, state.value),
        // TODO: This should be passing * 1000
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t);
          checkCatchBoundary(t);
        }
        if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
          return spring$1.next(t - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t);
          return state;
        }
      }
    };
  }

  // node_modules/motion-dom/dist/es/utils/interpolate.mjs
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
      let mixer = mixerFactory(output[i], output[i + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length, "Both input and output ranges must be the same length", "range-length");
    if (inputLength === 1)
      return () => output[0];
    if (inputLength === 2 && output[0] === output[1])
      return () => output[1];
    const isZeroDeltaRange = input[0] === input[1];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
      if (isZeroDeltaRange && v < input[0])
        return output[0];
      let i = 0;
      if (numMixers > 1) {
        for (; i < input.length - 2; i++) {
          if (v < input[i + 1])
            break;
        }
      }
      const progressInRange = progress(input[i], input[i + 1], v);
      return mixers[i](progressInRange);
    };
    return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/offsets/fill.mjs
  function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i = 1; i <= remaining; i++) {
      const offsetProgress = progress(0, remaining, i);
      offset.push(mixNumber(min, 1, offsetProgress));
    }
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/offsets/default.mjs
  function defaultOffset(arr) {
    const offset = [0];
    fillOffset(offset, arr.length - 1);
    return offset;
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/offsets/time.mjs
  function convertOffsetToTimes(offset, duration) {
    return offset.map((o) => o * duration);
  }

  // node_modules/motion-dom/dist/es/animation/generators/keyframes.mjs
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(
      // Only use the provided offsets if they're the correct length
      // TODO Maybe we should warn here if there's a length mismatch
      times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t) => {
        state.value = mapTimeToKeyframe(t);
        state.done = t >= duration;
        return state;
      }
    };
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/get-final.mjs
  var isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
  }

  // node_modules/motion-dom/dist/es/animation/utils/replace-transition-type.mjs
  var transitionTypeMap = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  function replaceTransitionType(transition) {
    if (typeof transition.type === "string") {
      transition.type = transitionTypeMap[transition.type];
    }
  }

  // node_modules/motion-dom/dist/es/animation/utils/WithPromise.mjs
  var WithPromise = class {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((resolve) => {
        this.resolve = resolve;
      });
    }
    notifyFinished() {
      this.resolve();
    }
    /**
     * Allows the animation to be awaited.
     *
     * @deprecated Use `finished` instead.
     */
    then(onResolve, onReject) {
      return this.finished.then(onResolve, onReject);
    }
  };

  // node_modules/motion-dom/dist/es/animation/JSAnimation.mjs
  var percentToProgress = (percent2) => percent2 / 100;
  var JSAnimation = class extends WithPromise {
    constructor(options) {
      super();
      this.state = "idle";
      this.startTime = null;
      this.isStopped = false;
      this.currentTime = 0;
      this.holdTime = null;
      this.playbackSpeed = 1;
      this.stop = () => {
        const { motionValue: motionValue2 } = this.options;
        if (motionValue2 && motionValue2.updatedAt !== time.now()) {
          this.tick(time.now());
        }
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.teardown();
        this.options.onStop?.();
      };
      activeAnimations.mainThread++;
      this.options = options;
      this.initAnimation();
      this.play();
      if (options.autoplay === false)
        this.pause();
    }
    initAnimation() {
      const { options } = this;
      replaceTransitionType(options);
      const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
      let { keyframes: keyframes$1 } = options;
      const generatorFactory = type || keyframes;
      if (generatorFactory !== keyframes) {
        invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`, "spring-two-frames");
      }
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
        this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
      if (repeatType === "mirror") {
        this.mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$1].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      this.calculatedDuration = calculatedDuration;
      this.resolvedDuration = calculatedDuration + repeatDelay;
      this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
      this.generator = generator;
    }
    updateTime(timestamp) {
      const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
      if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = animationTime;
      }
    }
    tick(timestamp, sample = false) {
      const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
      if (this.startTime === null)
        return generator.next(0);
      const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else {
        this.updateTime(timestamp);
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
      const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
      if (mixKeyframes) {
        state.value = mixKeyframes(state.value);
      }
      let { done } = state;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && type !== inertia) {
        state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
      }
      if (onUpdate) {
        onUpdate(state.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state;
    }
    /**
     * Allows the returned animation to be awaited or promise-chained. Currently
     * resolves when the animation finishes at all but in a future update could/should
     * reject if its cancels.
     */
    then(resolve, reject) {
      return this.finished.then(resolve, reject);
    }
    get duration() {
      return millisecondsToSeconds(this.calculatedDuration);
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.playbackSpeed;
      }
      this.driver?.start(false);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      this.updateTime(time.now());
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (this.isStopped)
        return;
      const { driver = frameloopDriver, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      this.options.onPlay?.();
      const now2 = this.driver.now();
      if (this.state === "finished") {
        this.updateFinished();
        this.startTime = now2;
      } else if (this.holdTime !== null) {
        this.startTime = now2 - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime ?? now2;
      }
      if (this.state === "finished" && this.speed < 0) {
        this.startTime += this.calculatedDuration;
      }
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      this.state = "paused";
      this.updateTime(time.now());
      this.holdTime = this.currentTime;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.notifyFinished();
      this.teardown();
      this.state = "finished";
      this.options.onComplete?.();
    }
    cancel() {
      this.holdTime = null;
      this.startTime = 0;
      this.tick(0);
      this.teardown();
      this.options.onCancel?.();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.startTime = this.holdTime = null;
      activeAnimations.mainThread--;
    }
    stopDriver() {
      if (!this.driver)
        return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(sampleTime) {
      this.startTime = 0;
      return this.tick(sampleTime, true);
    }
    attachTimeline(timeline) {
      if (this.options.allowFlatten) {
        this.options.type = "keyframes";
        this.options.ease = "linear";
        this.initAnimation();
      }
      this.driver?.stop();
      return timeline.observe(this);
    }
  };

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs
  function fillWildcards(keyframes2) {
    for (let i = 1; i < keyframes2.length; i++) {
      keyframes2[i] ?? (keyframes2[i] = keyframes2[i - 1]);
    }
  }

  // node_modules/motion-dom/dist/es/render/dom/parse-transform.mjs
  var radToDeg = (rad) => rad * 180 / Math.PI;
  var rotate = (v) => {
    const angle = radToDeg(Math.atan2(v[1], v[0]));
    return rebaseAngle(angle);
  };
  var matrix2dParsers = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
    rotate,
    rotateZ: rotate,
    skewX: (v) => radToDeg(Math.atan(v[1])),
    skewY: (v) => radToDeg(Math.atan(v[2])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
  };
  var rebaseAngle = (angle) => {
    angle = angle % 360;
    if (angle < 0)
      angle += 360;
    return angle;
  };
  var rotateZ = rotate;
  var scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  var scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
  var matrix3dParsers = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX,
    scaleY,
    scale: (v) => (scaleX(v) + scaleY(v)) / 2,
    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
    rotateZ,
    rotate: rotateZ,
    skewX: (v) => radToDeg(Math.atan(v[4])),
    skewY: (v) => radToDeg(Math.atan(v[1])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
  };
  function defaultTransformValue(name) {
    return name.includes("scale") ? 1 : 0;
  }
  function parseValueFromTransform(transform, name) {
    if (!transform || transform === "none") {
      return defaultTransformValue(name);
    }
    const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let parsers;
    let match;
    if (matrix3dMatch) {
      parsers = matrix3dParsers;
      match = matrix3dMatch;
    } else {
      const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      parsers = matrix2dParsers;
      match = matrix2dMatch;
    }
    if (!match) {
      return defaultTransformValue(name);
    }
    const valueParser = parsers[name];
    const values = match[1].split(",").map(convertTransformToNumber);
    return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
  }
  var readTransformValue = (instance, name) => {
    const { transform = "none" } = getComputedStyle(instance);
    return parseValueFromTransform(transform, name);
  };
  function convertTransformToNumber(value) {
    return parseFloat(value.trim());
  }

  // node_modules/motion-dom/dist/es/render/utils/keys-transform.mjs
  var transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  var transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/unit-conversion.mjs
  var isNumOrPxType = (v) => v === number || v === px;
  var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
  var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  var positionalValues = {
    // Dimensions
    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
    // Transform
    x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
    y: (_bbox, { transform }) => parseValueFromTransform(transform, "y")
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;

  // node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs
  var toResolve = /* @__PURE__ */ new Set();
  var isScheduled = false;
  var anyNeedsMeasurement = false;
  var isForced = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = /* @__PURE__ */ new Map();
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length)
          return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            element.getValue(key)?.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete(isForced));
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    isForced = true;
    readAllKeyframes();
    measureAllKeyframes();
    isForced = false;
  }
  var KeyframeResolver = class {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
      this.state = "pending";
      this.isAsync = false;
      this.needsMeasurement = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue2;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.state = "scheduled";
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
      if (unresolvedKeyframes[0] === null) {
        const currentValue = motionValue2?.get();
        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (currentValue !== void 0) {
          unresolvedKeyframes[0] = currentValue;
        } else if (element && name) {
          const valueAsRead = element.readValue(name, finalKeyframe);
          if (valueAsRead !== void 0 && valueAsRead !== null) {
            unresolvedKeyframes[0] = valueAsRead;
          }
        }
        if (unresolvedKeyframes[0] === void 0) {
          unresolvedKeyframes[0] = finalKeyframe;
        }
        if (motionValue2 && currentValue === void 0) {
          motionValue2.set(unresolvedKeyframes[0]);
        }
      }
      fillWildcards(unresolvedKeyframes);
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete(isForcedComplete = false) {
      this.state = "complete";
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
      toResolve.delete(this);
    }
    cancel() {
      if (this.state === "scheduled") {
        toResolve.delete(this);
        this.state = "pending";
      }
    }
    resume() {
      if (this.state === "pending")
        this.scheduleResolve();
    }
  };

  // node_modules/motion-dom/dist/es/render/dom/is-css-var.mjs
  var isCSSVar = (name) => name.startsWith("--");

  // node_modules/motion-dom/dist/es/render/dom/style-set.mjs
  function setStyle(element, name, value) {
    isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
  }

  // node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs
  var supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);

  // node_modules/motion-dom/dist/es/utils/supports/flags.mjs
  var supportsFlags = {};

  // node_modules/motion-dom/dist/es/utils/supports/memo.mjs
  function memoSupports(callback, supportsFlag) {
    const memoized = memo(callback);
    return () => supportsFlags[supportsFlag] ?? memoized();
  }

  // node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs
  var supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
    try {
      document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e) {
      return false;
    }
    return true;
  }, "linearEasing");

  // node_modules/motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs
  var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;

  // node_modules/motion-dom/dist/es/animation/waapi/easing/supported.mjs
  var supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };

  // node_modules/motion-dom/dist/es/animation/waapi/easing/map-easing.mjs
  function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
      return void 0;
    } else if (typeof easing === "function") {
      return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
    } else {
      return supportedWaapiEasing[easing];
    }
  }

  // node_modules/motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs
  function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
    const keyframeOptions = {
      [valueName]: keyframes2
    };
    if (times)
      keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2, duration);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    if (statsBuffer.value) {
      activeAnimations.waapi++;
    }
    const options = {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    };
    if (pseudoElement)
      options.pseudoElement = pseudoElement;
    const animation = element.animate(keyframeOptions, options);
    if (statsBuffer.value) {
      animation.finished.finally(() => {
        activeAnimations.waapi--;
      });
    }
    return animation;
  }

  // node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs
  function isGenerator(type) {
    return typeof type === "function" && "applyToOptions" in type;
  }

  // node_modules/motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs
  function applyGeneratorOptions({ type, ...options }) {
    if (isGenerator(type) && supportsLinearEasing()) {
      return type.applyToOptions(options);
    } else {
      options.duration ?? (options.duration = 300);
      options.ease ?? (options.ease = "easeOut");
    }
    return options;
  }

  // node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs
  var NativeAnimation = class extends WithPromise {
    constructor(options) {
      super();
      this.finishedTime = null;
      this.isStopped = false;
      if (!options)
        return;
      const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
      this.isPseudoElement = Boolean(pseudoElement);
      this.allowFlatten = allowFlatten;
      this.options = options;
      invariant(typeof options.type !== "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring");
      const transition = applyGeneratorOptions(options);
      this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
      if (transition.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = () => {
        this.finishedTime = this.time;
        if (!pseudoElement) {
          const keyframe = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
          if (this.updateMotionValue) {
            this.updateMotionValue(keyframe);
          } else {
            setStyle(element, name, keyframe);
          }
          this.animation.cancel();
        }
        onComplete?.();
        this.notifyFinished();
      };
    }
    play() {
      if (this.isStopped)
        return;
      this.animation.play();
      if (this.state === "finished") {
        this.updateFinished();
      }
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.finish?.();
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch (e) {
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      const { state } = this;
      if (state === "idle" || state === "finished") {
        return;
      }
      if (this.updateMotionValue) {
        this.updateMotionValue();
      } else {
        this.commitStyles();
      }
      if (!this.isPseudoElement)
        this.cancel();
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * In this method, we commit styles back to the DOM before cancelling
     * the animation.
     *
     * This is designed to be overridden by NativeAnimationExtended, which
     * will create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to also correctly calculate velocity for any subsequent animation
     * while deferring the commit until the next animation frame.
     */
    commitStyles() {
      if (!this.isPseudoElement) {
        this.animation.commitStyles?.();
      }
    }
    get duration() {
      const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
      return millisecondsToSeconds(Number(duration));
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(newTime) {
      this.finishedTime = null;
      this.animation.currentTime = secondsToMilliseconds(newTime);
    }
    /**
     * The playback speed of the animation.
     * 1 = normal speed, 2 = double speed, 0.5 = half speed.
     */
    get speed() {
      return this.animation.playbackRate;
    }
    set speed(newSpeed) {
      if (newSpeed < 0)
        this.finishedTime = null;
      this.animation.playbackRate = newSpeed;
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState;
    }
    get startTime() {
      return Number(this.animation.startTime);
    }
    set startTime(newStartTime) {
      this.animation.startTime = newStartTime;
    }
    /**
     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
     */
    attachTimeline({ timeline, observe }) {
      if (this.allowFlatten) {
        this.animation.effect?.updateTiming({ easing: "linear" });
      }
      this.animation.onfinish = null;
      if (timeline && supportsScrollTimeline()) {
        this.animation.timeline = timeline;
        return noop;
      } else {
        return observe(this);
      }
    }
  };

  // node_modules/motion-dom/dist/es/animation/waapi/utils/unsupported-easing.mjs
  var unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  function replaceStringEasing(transition) {
    if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
      transition.ease = unsupportedEasingFunctions[transition.ease];
    }
  }

  // node_modules/motion-dom/dist/es/animation/NativeAnimationExtended.mjs
  var sampleDelta = 10;
  var NativeAnimationExtended = class extends NativeAnimation {
    constructor(options) {
      replaceStringEasing(options);
      replaceTransitionType(options);
      super(options);
      if (options.startTime) {
        this.startTime = options.startTime;
      }
      this.options = options;
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * Rather than read commited styles back out of the DOM, we can
     * create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to calculate velocity for any subsequent animation.
     */
    updateMotionValue(value) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
      if (!motionValue2)
        return;
      if (value !== void 0) {
        motionValue2.set(value);
        return;
      }
      const sampleAnimation = new JSAnimation({
        ...options,
        autoplay: false
      });
      const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
      sampleAnimation.stop();
    }
  };

  // node_modules/motion-dom/dist/es/animation/utils/is-animatable.mjs
  var isAnimatable = (value, name) => {
    if (name === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" && // It's animatable if we have a string
    (complex.test(value) || value === "0") && // And it contains numbers and/or colors
    !value.startsWith("url(")) {
      return true;
    }
    return false;
  };

  // node_modules/motion-dom/dist/es/animation/utils/can-animate.mjs
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1)
      return true;
    for (let i = 0; i < keyframes2.length; i++) {
      if (keyframes2[i] !== current)
        return true;
    }
  }
  function canAnimate(keyframes2, name, type, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null)
      return false;
    if (name === "display" || name === "visibility")
      return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". "${isOriginAnimatable ? targetKeyframe : originKeyframe}" is not an animatable value.`, "value-not-animatable");
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
  }

  // node_modules/motion-dom/dist/es/animation/utils/make-animation-instant.mjs
  function makeAnimationInstant(options) {
    options.duration = 0;
    options.type = "keyframes";
  }

  // node_modules/motion-dom/dist/es/animation/waapi/supports/waapi.mjs
  var acceleratedValues = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
    // TODO: Could be re-enabled now we have support for linear() easing
    // "background-color"
  ]);
  var supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  function supportsBrowserAnimation(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    const subject = motionValue2?.owner?.current;
    if (!(subject instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }

  // node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs
  var MAX_RESOLVE_DELAY = 40;
  var AsyncMotionValueAnimation = class extends WithPromise {
    constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
      super();
      this.stop = () => {
        if (this._animation) {
          this._animation.stop();
          this.stopTimeline?.();
        }
        this.keyframeResolver?.cancel();
      };
      this.createdAt = time.now();
      const optionsWithDefaults = {
        autoplay,
        delay: delay2,
        type,
        repeat,
        repeatDelay,
        repeatType,
        name,
        motionValue: motionValue2,
        element,
        ...options
      };
      const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
      this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
      this.keyframeResolver?.scheduleResolve();
    }
    onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
      this.keyframeResolver = void 0;
      const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
      this.resolvedAt = time.now();
      if (!canAnimate(keyframes2, name, type, velocity)) {
        if (MotionGlobalConfig.instantAnimations || !delay2) {
          onUpdate?.(getFinalKeyframe(keyframes2, options, finalKeyframe));
        }
        keyframes2[0] = keyframes2[keyframes2.length - 1];
        makeAnimationInstant(options);
        options.repeat = 0;
      }
      const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
      const resolvedOptions = {
        startTime,
        finalKeyframe,
        ...options,
        keyframes: keyframes2
      };
      const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
        ...resolvedOptions,
        element: resolvedOptions.motionValue.owner.current
      }) : new JSAnimation(resolvedOptions);
      animation.finished.then(() => this.notifyFinished()).catch(noop);
      if (this.pendingTimeline) {
        this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
        this.pendingTimeline = void 0;
      }
      this._animation = animation;
    }
    get finished() {
      if (!this._animation) {
        return this._finished;
      } else {
        return this.animation.finished;
      }
    }
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {
      });
    }
    get animation() {
      if (!this._animation) {
        this.keyframeResolver?.resume();
        flushKeyframeResolvers();
      }
      return this._animation;
    }
    get duration() {
      return this.animation.duration;
    }
    get iterationDuration() {
      return this.animation.iterationDuration;
    }
    get time() {
      return this.animation.time;
    }
    set time(newTime) {
      this.animation.time = newTime;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(newSpeed) {
      this.animation.speed = newSpeed;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(timeline) {
      if (this._animation) {
        this.stopTimeline = this.animation.attachTimeline(timeline);
      } else {
        this.pendingTimeline = timeline;
      }
      return () => this.stop();
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      if (this._animation) {
        this.animation.cancel();
      }
      this.keyframeResolver?.cancel();
    }
  };

  // node_modules/motion-dom/dist/es/animation/utils/css-variables-conversion.mjs
  var splitCSSVariableRegex = (
    // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
  );
  function parseCSSVariable(current) {
    const match = splitCSSVariableRegex.exec(current);
    if (!match)
      return [,];
    const [, token1, token2, fallback] = match;
    return [`--${token1 ?? token2}`, fallback];
  }
  var maxDepth = 4;
  function getVariableValue(current, element, depth = 1) {
    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`, "max-css-var-depth");
    const [token, fallback] = parseCSSVariable(current);
    if (!token)
      return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
  }

  // node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs
  function getValueTransition(transition, key) {
    return transition?.[key] ?? transition?.["default"] ?? transition;
  }

  // node_modules/motion-dom/dist/es/render/utils/keys-position.mjs
  var positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...transformPropOrder
  ]);

  // node_modules/motion-dom/dist/es/value/types/auto.mjs
  var auto = {
    test: (v) => v === "auto",
    parse: (v) => v
  };

  // node_modules/motion-dom/dist/es/value/types/test.mjs
  var testValueType = (v) => (type) => type.test(v);

  // node_modules/motion-dom/dist/es/value/types/dimensions.mjs
  var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
  var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/is-none.mjs
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }

  // node_modules/motion-dom/dist/es/value/types/complex/filter.mjs
  var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v;
    const [number2] = value.match(floatRegex) || [];
    if (!number2)
      return v;
    const unit = value.replace(number2, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number2 !== value)
      defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
  }
  var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  var filter = {
    ...complex,
    getAnimatableNone: (v) => {
      const functions = v.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v;
    }
  };

  // node_modules/motion-dom/dist/es/value/types/int.mjs
  var int = {
    ...number,
    transform: Math.round
  };

  // node_modules/motion-dom/dist/es/value/types/maps/transform.mjs
  var transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
  };

  // node_modules/motion-dom/dist/es/value/types/maps/number.mjs
  var numberValueTypes = {
    // Border props
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    // Misc
    backgroundPositionX: px,
    backgroundPositionY: px,
    ...transformValueTypes,
    zIndex: int,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };

  // node_modules/motion-dom/dist/es/value/types/maps/defaults.mjs
  var defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
  };
  var getDefaultValueType = (key) => defaultValueTypes[key];

  // node_modules/motion-dom/dist/es/value/types/utils/animatable-none.mjs
  function getAnimatableNone2(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter)
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/make-none-animatable.mjs
  var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i = 0;
    let animatableTemplate = void 0;
    while (i < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i];
      }
      i++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
      }
    }
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs
  var DOMKeyframesResolver = class extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element || !element.current)
        return;
      super.readKeyframes();
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        let keyframe = unresolvedKeyframes[i];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i] = resolved;
            }
            if (i === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      if (originType === targetType)
        return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
          const value = unresolvedKeyframes[i];
          if (typeof value === "string") {
            unresolvedKeyframes[i] = parseFloat(value);
          }
        }
      } else if (positionalValues[name]) {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
          noneKeyframeIndexes.push(i);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element || !element.current)
        return;
      if (name === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      const { element, name, unresolvedKeyframes } = this;
      if (!element || !element.current)
        return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if (this.removedTransforms?.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  };

  // node_modules/motion-dom/dist/es/utils/resolve-elements.mjs
  function resolveElements(elementOrSelector, scope, selectorCache) {
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    } else if (typeof elementOrSelector === "string") {
      let root = document;
      if (scope) {
        root = scope.current;
      }
      const elements = selectorCache?.[elementOrSelector] ?? root.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector);
  }

  // node_modules/motion-dom/dist/es/value/types/utils/get-as-type.mjs
  var getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };

  // node_modules/motion-dom/dist/es/utils/is-html-element.mjs
  function isHTMLElement(element) {
    return isObject(element) && "offsetHeight" in element;
  }

  // node_modules/motion-dom/dist/es/value/index.mjs
  var MAX_VELOCITY_DELTA = 30;
  var isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  var collectMotionValues = {
    current: void 0
  };
  var MotionValue = class {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     */
    constructor(init, options = {}) {
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v);
        if (this.current !== this.prev) {
          this.events.change?.notify(this.current);
          if (this.dependents) {
            for (const dependent of this.dependents) {
              dependent.dirty();
            }
          }
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */
    onChange(subscription) {
      if (true) {
        warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
      }
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    /**
     * Attaches a passive effect to the `MotionValue`.
     */
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */
    set(v) {
      if (!this.passiveEffect) {
        this.updateAndNotify(v);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    /**
     * Set the state of the `MotionValue`, stopping any active animations,
     * effects, and resets velocity to `0`.
     */
    jump(v, endAnimation = true) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    dirty() {
      this.events.change?.notify(this.current);
    }
    addDependent(dependent) {
      if (!this.dependents) {
        this.dependents = /* @__PURE__ */ new Set();
      }
      this.dependents.add(dependent);
    }
    removeDependent(dependent) {
      if (this.dependents) {
        this.dependents.delete(dependent);
      }
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */
    get() {
      if (collectMotionValues.current) {
        collectMotionValues.current.push(this);
      }
      return this.current;
    }
    /**
     * @public
     */
    getPrevious() {
      return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */
    getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     */
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    /**
     * Stop the currently active animation.
     *
     * @public
     */
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     *
     * @public
     */
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     *
     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
     * created a `MotionValue` via the `motionValue` function.
     *
     * @public
     */
    destroy() {
      this.dependents?.clear();
      this.events.destroy?.notify();
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  };
  function motionValue(init, options) {
    return new MotionValue(init, options);
  }

  // node_modules/motion-dom/dist/es/frameloop/microtask.mjs
  var { schedule: microtask, cancel: cancelMicrotask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);

  // node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs
  var isDragging = {
    x: false,
    y: false
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }

  // node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs
  function setDragLock(axis) {
    if (axis === "x" || axis === "y") {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  }

  // node_modules/motion-dom/dist/es/gestures/utils/setup.mjs
  function setupGesture(elementOrSelector, options) {
    const elements = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options,
      signal: gestureAbortController.signal
    };
    const cancel = () => gestureAbortController.abort();
    return [elements, eventOptions, cancel];
  }

  // node_modules/motion-dom/dist/es/gestures/hover.mjs
  function isValidHover(event) {
    return !(event.pointerType === "touch" || isDragActive());
  }
  function hover(elementOrSelector, onHoverStart, options = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
    const onPointerEnter = (enterEvent) => {
      if (!isValidHover(enterEvent))
        return;
      const { target } = enterEvent;
      const onHoverEnd = onHoverStart(target, enterEvent);
      if (typeof onHoverEnd !== "function" || !target)
        return;
      const onPointerLeave = (leaveEvent) => {
        if (!isValidHover(leaveEvent))
          return;
        onHoverEnd(leaveEvent);
        target.removeEventListener("pointerleave", onPointerLeave);
      };
      target.addEventListener("pointerleave", onPointerLeave, eventOptions);
    };
    elements.forEach((element) => {
      element.addEventListener("pointerenter", onPointerEnter, eventOptions);
    });
    return cancel;
  }

  // node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs
  var isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };

  // node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs
  var isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };

  // node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs
  var focusableElements = /* @__PURE__ */ new Set([
    "BUTTON",
    "INPUT",
    "SELECT",
    "TEXTAREA",
    "A"
  ]);
  function isElementKeyboardAccessible(element) {
    return focusableElements.has(element.tagName) || element.tabIndex !== -1;
  }

  // node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs
  var isPressing = /* @__PURE__ */ new WeakSet();

  // node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs
  function filterEvents(callback) {
    return (event) => {
      if (event.key !== "Enter")
        return;
      callback(event);
    };
  }
  function firePointerEvent(target, type) {
    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
  }
  var enableKeyboardPress = (focusEvent, eventOptions) => {
    const element = focusEvent.currentTarget;
    if (!element)
      return;
    const handleKeydown = filterEvents(() => {
      if (isPressing.has(element))
        return;
      firePointerEvent(element, "down");
      const handleKeyup = filterEvents(() => {
        firePointerEvent(element, "up");
      });
      const handleBlur = () => firePointerEvent(element, "cancel");
      element.addEventListener("keyup", handleKeyup, eventOptions);
      element.addEventListener("blur", handleBlur, eventOptions);
    });
    element.addEventListener("keydown", handleKeydown, eventOptions);
    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
  };

  // node_modules/motion-dom/dist/es/gestures/press/index.mjs
  function isValidPressEvent(event) {
    return isPrimaryPointer(event) && !isDragActive();
  }
  function press(targetOrSelector, onPressStart, options = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
    const startPress = (startEvent) => {
      const target = startEvent.currentTarget;
      if (!isValidPressEvent(startEvent))
        return;
      isPressing.add(target);
      const onPressEnd = onPressStart(target, startEvent);
      const onPointerEnd = (endEvent, success) => {
        window.removeEventListener("pointerup", onPointerUp);
        window.removeEventListener("pointercancel", onPointerCancel);
        if (isPressing.has(target)) {
          isPressing.delete(target);
        }
        if (!isValidPressEvent(endEvent)) {
          return;
        }
        if (typeof onPressEnd === "function") {
          onPressEnd(endEvent, { success });
        }
      };
      const onPointerUp = (upEvent) => {
        onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
      };
      const onPointerCancel = (cancelEvent) => {
        onPointerEnd(cancelEvent, false);
      };
      window.addEventListener("pointerup", onPointerUp, eventOptions);
      window.addEventListener("pointercancel", onPointerCancel, eventOptions);
    };
    targets.forEach((target) => {
      const pointerDownTarget = options.useGlobalTarget ? window : target;
      pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
      if (isHTMLElement(target)) {
        target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
        if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
          target.tabIndex = 0;
        }
      }
    });
    return cancelEvents;
  }

  // node_modules/motion-dom/dist/es/utils/is-svg-element.mjs
  function isSVGElement(element) {
    return isObject(element) && "ownerSVGElement" in element;
  }

  // node_modules/motion-dom/dist/es/utils/is-svg-svg-element.mjs
  function isSVGSVGElement(element) {
    return isSVGElement(element) && element.tagName === "svg";
  }

  // node_modules/motion-dom/dist/es/value/utils/is-motion-value.mjs
  var isMotionValue = (value) => Boolean(value && value.getVelocity);

  // node_modules/motion-dom/dist/es/value/types/utils/find.mjs
  var valueTypes = [...dimensionValueTypes, color, complex];
  var findValueType = (v) => valueTypes.find(testValueType(v));

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var React2 = __toESM(require_react(), 1);
  var import_react6 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
  var import_react5 = __toESM(require_react(), 1);
  var MotionConfigContext = (0, import_react5.createContext)({
    transformPagePoint: (p) => p,
    isStatic: false,
    reducedMotion: "never"
  });

  // node_modules/framer-motion/dist/es/utils/use-composed-ref.mjs
  var React = __toESM(require_react(), 1);
  function setRef(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef(ref, node);
        if (!hasCleanup && typeof cleanup === "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup === "function") {
              cleanup();
            } else {
              setRef(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return React.useCallback(composeRefs(...refs), refs);
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var PopChildMeasure = class extends React2.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent) {
        const parent = element.offsetParent;
        const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;
        const size = this.props.sizeRef.current;
        size.height = element.offsetHeight || 0;
        size.width = element.offsetWidth || 0;
        size.top = element.offsetTop;
        size.left = element.offsetLeft;
        size.right = parentWidth - size.width - size.left;
      }
      return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  };
  function PopChild({ children, isPresent, anchorX, root }) {
    const id3 = (0, import_react6.useId)();
    const ref = (0, import_react6.useRef)(null);
    const size = (0, import_react6.useRef)({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      right: 0
    });
    const { nonce } = (0, import_react6.useContext)(MotionConfigContext);
    const composedRef = useComposedRefs(ref, children?.ref);
    (0, import_react6.useInsertionEffect)(() => {
      const { width, height, top, left, right } = size.current;
      if (isPresent || !ref.current || !width || !height)
        return;
      const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
      ref.current.dataset.motionPopId = id3;
      const style = document.createElement("style");
      if (nonce)
        style.nonce = nonce;
      const parent = root ?? document.head;
      parent.appendChild(style);
      if (style.sheet) {
        style.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            top: ${top}px !important;
          }
        `);
      }
      return () => {
        if (parent.contains(style)) {
          parent.removeChild(style);
        }
      };
    }, [isPresent]);
    return (0, import_jsx_runtime.jsx)(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size, children: React2.cloneElement(children, { ref: composedRef }) });
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id3 = (0, import_react7.useId)();
    let isReusedContext = true;
    let context = (0, import_react7.useMemo)(() => {
      isReusedContext = false;
      return {
        id: id3,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
              return;
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        }
      };
    }, [isPresent, presenceChildren, onExitComplete]);
    if (presenceAffectsLayout && isReusedContext) {
      context = { ...context };
    }
    (0, import_react7.useMemo)(() => {
      presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    React3.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
      children = (0, import_jsx_runtime2.jsx)(PopChild, { isPresent, anchorX, root, children });
    }
    return (0, import_jsx_runtime2.jsx)(PresenceContext.Provider, { value: context, children });
  };
  function newChildrenMap() {
    return /* @__PURE__ */ new Map();
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
  var import_react8 = __toESM(require_react(), 1);
  function usePresence(subscribe = true) {
    const context = (0, import_react8.useContext)(PresenceContext);
    if (context === null)
      return [true, null];
    const { isPresent, onExitComplete, register } = context;
    const id3 = (0, import_react8.useId)();
    (0, import_react8.useEffect)(() => {
      if (subscribe) {
        return register(id3);
      }
    }, [subscribe]);
    const safeToRemove = (0, import_react8.useCallback)(() => subscribe && onExitComplete && onExitComplete(id3), [id3, onExitComplete, subscribe]);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs
  var import_react9 = __toESM(require_react(), 1);
  var getChildKey = (child) => child.key || "";
  function onlyElements(children) {
    const filtered = [];
    import_react9.Children.forEach(children, (child) => {
      if ((0, import_react9.isValidElement)(child))
        filtered.push(child);
    });
    return filtered;
  }

  // node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", root }) => {
    const [isParentPresent, safeToRemove] = usePresence(propagate);
    const presentChildren = (0, import_react10.useMemo)(() => onlyElements(children), [children]);
    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
    const isInitialRender = (0, import_react10.useRef)(true);
    const pendingPresentChildren = (0, import_react10.useRef)(presentChildren);
    const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
    const [diffedChildren, setDiffedChildren] = (0, import_react10.useState)(presentChildren);
    const [renderedChildren, setRenderedChildren] = (0, import_react10.useState)(presentChildren);
    useIsomorphicLayoutEffect(() => {
      isInitialRender.current = false;
      pendingPresentChildren.current = presentChildren;
      for (let i = 0; i < renderedChildren.length; i++) {
        const key = getChildKey(renderedChildren[i]);
        if (!presentKeys.includes(key)) {
          if (exitComplete.get(key) !== true) {
            exitComplete.set(key, false);
          }
        } else {
          exitComplete.delete(key);
        }
      }
    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
      let nextChildren = [...presentChildren];
      for (let i = 0; i < renderedChildren.length; i++) {
        const child = renderedChildren[i];
        const key = getChildKey(child);
        if (!presentKeys.includes(key)) {
          nextChildren.splice(i, 0, child);
          exitingChildren.push(child);
        }
      }
      if (mode === "wait" && exitingChildren.length) {
        nextChildren = exitingChildren;
      }
      setRenderedChildren(onlyElements(nextChildren));
      setDiffedChildren(presentChildren);
      return null;
    }
    if (mode === "wait" && renderedChildren.length > 1) {
      console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
    }
    const { forceRender } = (0, import_react10.useContext)(LayoutGroupContext);
    return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: renderedChildren.map((child) => {
      const key = getChildKey(child);
      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
      const onExit = () => {
        if (exitComplete.has(key)) {
          exitComplete.set(key, true);
        } else {
          return;
        }
        let isEveryExitComplete = true;
        exitComplete.forEach((isExitComplete) => {
          if (!isExitComplete)
            isEveryExitComplete = false;
        });
        if (isEveryExitComplete) {
          forceRender?.();
          setRenderedChildren(pendingPresentChildren.current);
          propagate && safeToRemove?.();
          onExitComplete && onExitComplete();
        }
      };
      return (0, import_jsx_runtime3.jsx)(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, root, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key);
    }) });
  };

  // node_modules/framer-motion/dist/es/context/LazyContext.mjs
  var import_react11 = __toESM(require_react(), 1);
  var LazyContext = (0, import_react11.createContext)({ strict: false });

  // node_modules/framer-motion/dist/es/motion/features/definitions.mjs
  var featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  var featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/load-features.mjs
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }

  // node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
  var validMotionProps = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
  var shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (typeof isValidProp !== "function")
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(__require("@emotion/is-prop-valid").default);
  } catch {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
      props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // node_modules/framer-motion/dist/es/motion/index.mjs
  var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  var import_react21 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
  var import_react12 = __toESM(require_react(), 1);
  var MotionContext = /* @__PURE__ */ (0, import_react12.createContext)({});

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  var import_react13 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
  function isAnimationControls(v) {
    return v !== null && typeof v === "object" && typeof v.start === "function";
  }

  // node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
  function isVariantLabel(v) {
    return typeof v === "string" || Array.isArray(v);
  }

  // node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
  var variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  var variantProps = ["initial", ...variantPriorityOrder];

  // node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, (0, import_react13.useContext)(MotionContext));
    return (0, import_react13.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  var import_react16 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  var import_react14 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
  var scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    for (const key in correctors) {
      scaleCorrectors[key] = correctors[key];
      if (isCSSVariableName(key)) {
        scaleCorrectors[key].isCSSVariable = true;
      }
    }
  }

  // node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }

  // node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
  var translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  var numTransforms = transformPropOrder.length;
  function buildTransform(latestValues, transform, transformTemplate) {
    let transformString = "";
    let transformIsDefault = true;
    for (let i = 0; i < numTransforms; i++) {
      const key = transformPropOrder[i];
      const value = latestValues[key];
      if (value === void 0)
        continue;
      let valueIsDefault = true;
      if (typeof value === "number") {
        valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
      } else {
        valueIsDefault = parseFloat(value) === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    } else if (transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }

  // node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
  function buildHTMLStyles(state, latestValues, transformTemplate) {
    const { style, vars, transformOrigin } = state;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        hasTransform2 = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style.transform = buildTransform(latestValues, state.transform, transformTemplate);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }

  // node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
  var createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return (0, import_react14.useMemo)(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [visualState]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
  }
  function useHTMLProps(props, visualState) {
    const htmlProps = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  }

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  var import_react15 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
  var dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  var camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys = useDashCase ? dashKeys : camelKeys;
    attrs[keys.offset] = px.transform(-offset);
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys.array] = `${pathLength} ${pathSpacing}`;
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
  function buildSVGAttrs(state, {
    attrX,
    attrY,
    attrScale,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  }, isSVGTag2, transformTemplate, styleProp) {
    buildHTMLStyles(state, latest, transformTemplate);
    if (isSVGTag2) {
      if (state.style.viewBox) {
        state.attrs.viewBox = state.style.viewBox;
      }
      return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style } = state;
    if (attrs.transform) {
      style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (style.transform || attrs.transformOrigin) {
      style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
      delete attrs.transformOrigin;
    }
    if (style.transform) {
      style.transformBox = styleProp?.transformBox ?? "fill-box";
      delete attrs.transformBox;
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
  var createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });

  // node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
  var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  function useSVGProps(props, visualState, _isStatic, Component3) {
    const visualProps = (0, import_react15.useMemo)(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, isSVGTag(Component3), props.transformTemplate, props.style);
      return {
        ...state.attrs,
        style: { ...state.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }

  // node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
  var lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];

  // node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
  function isSVGComponent(Component3) {
    if (
      /**
       * If it's not a string, it's a custom React component. Currently we only support
       * HTML custom React components.
       */
      typeof Component3 !== "string" || /**
       * If it contains a dash, the element is a custom HTML webcomponent.
       */
      Component3.includes("-")
    ) {
      return false;
    } else if (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      lowercaseSVGElements.indexOf(Component3) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component3)
    ) {
      return true;
    }
    return false;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  function useRender(Component3, props, ref, { latestValues }, isStatic, forwardMotionProps = false) {
    const useVisualProps = isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component3);
    const filteredProps = filterProps(props, typeof Component3 === "string", forwardMotionProps);
    const elementProps = Component3 !== import_react16.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = (0, import_react16.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react16.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  var import_react17 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
  function getValueState(visualElement) {
    const state = [{}, {}];
    visualElement?.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    return definition;
  }

  // node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
  function resolveMotionValue(value) {
    return isMotionValue(value) ? value.get() : value;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState }, props, context, presenceContext) {
    const state = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
      renderState: createRenderState()
    };
    return state;
  }
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context.initial;
      if (animate === void 0)
        animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      for (let i = 0; i < list.length; i++) {
        const resolved = resolveVariantFromProps(props, list[i]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  var makeUseVisualState = (config) => (props, isStatic) => {
    const context = (0, import_react17.useContext)(MotionContext);
    const presenceContext = (0, import_react17.useContext)(PresenceContext);
    const make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };

  // node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/render/html/use-html-visual-state.mjs
  var useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  });

  // node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/render/svg/use-svg-visual-state.mjs
  var useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState
  });

  // node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
  var motionComponentSymbol = Symbol.for("motionComponentSymbol");

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  var import_react18 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
  function isRefObject(ref) {
    return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  function useMotionRef(visualState, visualElement, externalRef) {
    return (0, import_react18.useCallback)(
      (instance) => {
        if (instance) {
          visualState.onMount && visualState.onMount(instance);
        }
        if (visualElement) {
          if (instance) {
            visualElement.mount(instance);
          } else {
            visualElement.unmount();
          }
        }
        if (externalRef) {
          if (typeof externalRef === "function") {
            externalRef(instance);
          } else if (isRefObject(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
      /**
       * Include externalRef in dependencies to ensure the callback updates
       * when the ref changes, allowing proper ref forwarding.
       */
      [visualElement]
    );
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  var import_react20 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
  var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

  // node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
  var optimizedAppearDataId = "framerAppearId";
  var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

  // node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
  var import_react19 = __toESM(require_react(), 1);
  var SwitchLayoutGroupContext = (0, import_react19.createContext)({});

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  function useVisualElement(Component3, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    const { visualElement: parent } = (0, import_react20.useContext)(MotionContext);
    const lazyContext = (0, import_react20.useContext)(LazyContext);
    const presenceContext = (0, import_react20.useContext)(PresenceContext);
    const reducedMotionConfig = (0, import_react20.useContext)(MotionConfigContext).reducedMotion;
    const visualElementRef = (0, import_react20.useRef)(null);
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component3, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig
      });
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = (0, import_react20.useContext)(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    const isMounted = (0, import_react20.useRef)(false);
    (0, import_react20.useInsertionEffect)(() => {
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = (0, import_react20.useRef)(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
    useIsomorphicLayoutEffect(() => {
      if (!visualElement)
        return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      visualElement.scheduleRenderMicrotask();
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    (0, import_react20.useEffect)(() => {
      if (!visualElement)
        return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        queueMicrotask(() => {
          window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
      visualElement.enteringChildren = void 0;
    });
    return visualElement;
  }
  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
      /**
       * TODO: Update options in an effect. This could be tricky as it'll be too late
       * to update by the time layout animations run.
       * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
       * ensuring it gets called if there's no potential layout animations.
       *
       */
      animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      crossfade: layoutCrossfade,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement)
      return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }

  // node_modules/framer-motion/dist/es/motion/index.mjs
  function createMotionComponent(Component3, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    const useVisualState = isSVGComponent(Component3) ? useSVGVisualState : useHTMLVisualState;
    function MotionDOMComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...(0, import_react21.useContext)(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser) {
        useStrictMode(configAndProps, preloadedFeatures);
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
      }
      return (0, import_jsx_runtime4.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? (0, import_jsx_runtime4.jsx)(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component3, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });
    }
    MotionDOMComponent.displayName = `motion.${typeof Component3 === "string" ? Component3 : `create(${Component3.displayName ?? Component3.name ?? ""})`}`;
    const ForwardRefMotionComponent = (0, import_react21.forwardRef)(MotionDOMComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component3;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = (0, import_react21.useContext)(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    const isStrict = (0, import_react21.useContext)(LazyContext).strict;
    if (preloadedFeatures && isStrict) {
      const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      configAndProps.ignoreStrict ? warning(false, strictMessage, "lazy-strict-mode") : invariant(false, strictMessage, "lazy-strict-mode");
    }
  }
  function getProjectionFunctionality(props) {
    const { drag: drag2, layout: layout2 } = featureDefinitions;
    if (!drag2 && !layout2)
      return {};
    const combined = { ...drag2, ...layout2 };
    return {
      MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }

  // node_modules/framer-motion/dist/es/render/components/create-proxy.mjs
  function createMotionProxy(preloadedFeatures, createVisualElement) {
    if (typeof Proxy === "undefined") {
      return createMotionComponent;
    }
    const componentCache = /* @__PURE__ */ new Map();
    const factory = (Component3, options) => {
      return createMotionComponent(Component3, options, preloadedFeatures, createVisualElement);
    };
    const deprecatedFactoryFunction = (Component3, options) => {
      if (true) {
        warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
      }
      return factory(Component3, options);
    };
    return new Proxy(deprecatedFactoryFunction, {
      /**
       * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
       * The prop name is passed through as `key` and we can use that to generate a `motion`
       * DOM component with that name.
       */
      get: (_target, key) => {
        if (key === "create")
          return factory;
        if (!componentCache.has(key)) {
          componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
        }
        return componentCache.get(key);
      }
    });
  }

  // node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var import_react22 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox({ x, y }) {
    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
  }
  function transformBoxPoints(point, transformPoint2) {
    if (!transformPoint2)
      return point;
    const topLeft = transformPoint2({ x: point.left, y: point.top });
    const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }

  // node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
  function scalePoint(point, scale2, originPoint) {
    const distanceFromOrigin = point - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x, y }) {
    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
  }
  var TREE_SCALE_SNAP_MIN = 0.999999999999;
  var TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node;
    let delta;
    for (let i = 0; i < treeLength; i++) {
      node = treePath[i];
      delta = node.projectionDelta;
      const { visualElement } = node.options;
      if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
        transformBox(box, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node.latestValues)) {
        transformBox(box, node.latestValues);
      }
    }
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1;
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  function transformBox(box, transform) {
    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
  }

  // node_modules/framer-motion/dist/es/projection/utils/measure.mjs
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll } = rootProjectionNode2;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.offset.x);
      translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/models.mjs
  var createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  var createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  var createAxis = () => ({ min: 0, max: 0 });
  var createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });

  // node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
  var prefersReducedMotion = { current: null };
  var hasReducedMotionListener = { current: false };

  // node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }

  // node_modules/framer-motion/dist/es/render/store.mjs
  var visualElementStore = /* @__PURE__ */ new WeakMap();

  // node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
  function updateMotionValuesFromProps(element, next, prev) {
    for (const key in next) {
      const nextValue = next[key];
      const prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, { owner: element }));
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
        }
      }
    }
    for (const key in prev) {
      if (next[key] === void 0)
        element.removeValue(key);
    }
    return next;
  }

  // node_modules/framer-motion/dist/es/render/VisualElement.mjs
  var propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  var VisualElement = class {
    /**
     * This method takes React props and returns found MotionValues. For example, HTML
     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
     *
     * This isn't an abstract method as it needs calling in the constructor, but it is
     * intended to be one.
     */
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
      this.current = null;
      this.children = /* @__PURE__ */ new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = /* @__PURE__ */ new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = /* @__PURE__ */ new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0;
      this.scheduleRender = () => {
        const now2 = time.now();
        if (this.renderScheduledAt < now2) {
          this.renderScheduledAt = now2;
          frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = /* @__PURE__ */ new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key]);
        }
      }
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      if (true) {
        warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled");
      }
      this.parent?.addChild(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent?.removeChild(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    addChild(child) {
      this.children.add(child);
      this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
      this.enteringChildren.add(child);
    }
    removeChild(child) {
      this.children.delete(child);
      this.enteringChildren && this.enteringChildren.delete(child);
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
        this.scheduleRender();
      });
      let removeSyncCheck;
      if (window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        if (removeSyncCheck)
          removeSyncCheck();
        if (value.owner)
          value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition)
          continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    /**
     * Measure the current viewport box with or without transforms.
     * Only measures axis-aligned boxes, rotate and skew must be manually
     * removed with a re-render to work.
     */
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    /**
     * Update the provided props. Ensure any newly-added motion values are
     * added to our map, old ones removed, and listeners updated.
     */
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i = 0; i < propEventHandlers.length; i++) {
        const key = propEventHandlers[i];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    /**
     * Returns the variant definition with a given name.
     */
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
    /**
     * Returns the defined default transition on this component.
     */
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    /**
     * Add a child visual element to our set of children.
     */
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    /**
     * Add a motion value and bind it to this visual element.
     */
    addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue)
          this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
    /**
     * Remove a motion value and unbind any active subscriptions.
     */
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    /**
     * Check whether we have a motion value for this key
     */
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
    /**
     * If we're trying to animate to a previously unencountered value,
     * we need to check for it in our state and as a last resort read it
     * directly from the instance (which might have performance implications).
     */
    readValue(key, target) {
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone2(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
    /**
     * Set the base target to later animate back to. This is currently
     * only hydrated on creation and when we first read a value.
     */
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    /**
     * Find the base target for a value thats been removed from all animation
     * props.
     */
    getBaseTarget(key) {
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
    scheduleRenderMicrotask() {
      microtask.render(this.render);
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
  var DOMVisualElement = class extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b) {
      return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  };

  // node_modules/framer-motion/dist/es/render/html/utils/render.mjs
  function renderHTML(element, { style, vars }, styleProp, projection) {
    const elementStyle = element.style;
    let key;
    for (key in style) {
      elementStyle[key] = style[key];
    }
    projection?.applyProjectionStyles(elementStyle, styleProp);
    for (key in vars) {
      elementStyle.setProperty(key, vars[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
  function getComputedStyle2(element) {
    return window.getComputedStyle(element);
  }
  var HTMLVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
      } else {
        const computedStyle = getComputedStyle2(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
  };

  // node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
  var camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);

  // node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
  var SVGVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps2(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var createDomVisualElement = (Component3, options) => {
    return isSVGComponent(Component3) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
      allowProjection: Component3 !== import_react22.Fragment
    });
  };

  // node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
  }

  // node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
  var isKeyframesTarget = (v) => {
    return Array.isArray(v);
  };

  // node_modules/framer-motion/dist/es/render/utils/setters.mjs
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function resolveFinalValueInKeyframes(v) {
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }

  // node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }

  // node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs
  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    } else if (!willChange && MotionGlobalConfig.WillChange) {
      const newWillChange = new MotionGlobalConfig.WillChange("auto");
      visualElement.addValue("willChange", newWillChange);
      newWillChange.add(key);
    }
  }

  // node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }

  // node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
  var isNotNull2 = (value) => value !== null;
  function getFinalKeyframe2(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull2);
    const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
  }

  // node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
  var underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  var criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  var keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  var ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  var getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };

  // node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
  var animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const options = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v) => {
        value.set(v);
        valueTransition.onUpdate && valueTransition.onUpdate(v);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element
    };
    if (!isTransitionDefined(valueTransition)) {
      Object.assign(options, getDefaultTransition(name, options));
    }
    options.duration && (options.duration = secondsToMilliseconds(options.duration));
    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || options.duration === 0 && !options.repeatDelay) {
      makeAnimationInstant(options);
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
      shouldSkip = true;
      makeAnimationInstant(options);
      options.delay = 0;
    }
    options.allowFlatten = !valueTransition.type && !valueTransition.ease;
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe2(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return;
      }
    }
    return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
  };

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    if (transitionOverride)
      transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        ...getValueTransition(transition || {}, key)
      };
      const currentValue = value.get();
      if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
        continue;
      }
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations2;
  }

  // node_modules/framer-motion/dist/es/animation/utils/calc-child-stagger.mjs
  function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
    const index = Array.from(children).sort((a, b) => a.sortNodePosition(b)).indexOf(child);
    const numChildren = children.size;
    const maxStaggerDuration = (numChildren - 1) * staggerChildren;
    const delayIsFunction = typeof delayChildren === "function";
    return delayIsFunction ? delayChildren(index, numChildren) : staggerDirection === 1 ? index * staggerChildren : maxStaggerDuration - index * staggerChildren;
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
  function animateVariant(visualElement, variant, options = {}) {
    const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    for (const child of visualElement.variantChildren) {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delay2 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
      }).then(() => child.notify("AnimationComplete", variant)));
    }
    return Promise.all(animations2);
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  }

  // node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
  function shallowCompare(next, prev) {
    if (!Array.isArray(prev))
      return false;
    const prevLength = prev.length;
    if (prevLength !== next.length)
      return false;
    for (let i = 0; i < prevLength; i++) {
      if (prev[i] !== next[i])
        return false;
    }
    return true;
  }

  // node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs
  var numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement)
      return void 0;
    if (!visualElement.isControllingVariants) {
      const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== void 0) {
        context2.initial = visualElement.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = visualElement.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }

  // node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
  var reversePriorityOrder = [...variantPriorityOrder].reverse();
  var numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type) => (acc, definition) => {
      const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context = getVariantContext(visualElement.parent) || {};
      const animations2 = [];
      const removedKeys = /* @__PURE__ */ new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i = 0; i < numAnimationTypes; i++) {
        const type = reversePriorityOrder[i];
        const typeState = state[type];
        const prop = props[type] !== void 0 ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i;
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
          // If it isn't active and hasn't *just* been set as inactive
          !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
          !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
          isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
        i > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next = resolvedValues[key];
          const prev = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            valueHasChanged = !shallowCompare(next, prev);
          } else {
            valueHasChanged = next !== prev;
          }
          if (valueHasChanged) {
            if (next !== void 0 && next !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations2.push(...definitionList.map((animation) => {
            const options = { type };
            if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
              const { parent } = visualElement;
              const parentVariant = resolveVariant(parent, animation);
              if (parent.enteringChildren && parentVariant) {
                const { delayChildren } = parentVariant.transition || {};
                options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
              }
            }
            return {
              animation,
              options
            };
          }));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        if (typeof props.initial !== "boolean") {
          const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
          if (initialTransition && initialTransition.transition) {
            fallbackAnimation.transition = initialTransition.transition;
          }
        }
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget ?? null;
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive) {
      if (state[type].isActive === isActive)
        return Promise.resolve();
      visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));
      state[type].isActive = isActive;
      const animations2 = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state,
      reset: () => {
        state = createState();
      }
    };
  }
  function checkVariantsDidChange(prev, next) {
    if (typeof next === "string") {
      return next !== prev;
    } else if (Array.isArray(next)) {
      return !shallowCompare(next, prev);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/Feature.mjs
  var Feature = class {
    constructor(node) {
      this.isMounted = false;
      this.node = node;
    }
    update() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
  var AnimationFeature = class extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node) {
      super(node);
      node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      this.node.animationState.reset();
      this.unmountControls?.();
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
  var id = 0;
  var ExitAnimationFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.id = id++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => {
          onExitComplete(this.id);
        });
      }
    }
    mount() {
      const { register, onExitComplete } = this.node.presenceContext || {};
      if (onExitComplete) {
        onExitComplete(this.id);
      }
      if (register) {
        this.unmount = register(this.id);
      }
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animations.mjs
  var animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };

  // node_modules/framer-motion/dist/es/events/add-dom-event.mjs
  function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }

  // node_modules/framer-motion/dist/es/events/event-info.mjs
  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY
      }
    };
  }
  var addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };

  // node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
  var SCALE_PRECISION = 1e-4;
  var SCALE_MIN = 1 - SCALE_PRECISION;
  var SCALE_MAX = 1 + SCALE_PRECISION;
  var TRANSLATE_PRECISION = 0.01;
  var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
      delta.scale = 1;
    }
    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
      delta.translate = 0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }

  // node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }

  // node_modules/framer-motion/dist/es/utils/get-context-window.mjs
  var getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };

  // node_modules/framer-motion/dist/es/utils/distance.mjs
  var distance = (a, b) => Math.abs(a - b);
  function distance2D(a, b) {
    const xDelta = distance(a.x, b.x);
    const yDelta = distance(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }

  // node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
  var PanSession = class {
    constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3 } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point2 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point2, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin)
          resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      this.distanceThreshold = distanceThreshold;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point, timestamp }];
      const { onSessionStart } = handlers;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  };
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
  }
  function getPanInfo({ point }, history) {
    return {
      point,
      delta: subtractPoint(point, lastDevicePoint(history)),
      offset: subtractPoint(point, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i >= 0) {
      timestampedPoint = history[i];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
  function applyConstraints(point, { min, max }, elastic) {
    if (min !== void 0 && point < min) {
      point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);
    } else if (max !== void 0 && point > max) {
      point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);
    }
    return point;
  }
  function calcRelativeAxisConstraints(axis, min, max) {
    return {
      min: min !== void 0 ? axis.min + min : void 0,
      max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min;
    let max = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min, max] = [max, min];
    }
    return { min, max };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  var defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
  var elementDragControls = /* @__PURE__ */ new WeakMap();
  var VisualElementDragControls = class {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
        dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event).point);
        }
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openDragLock)
            this.openDragLock();
          this.openDragLock = setDragLock(drag2);
          if (!this.openDragLock)
            return;
        }
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length = calcLength(measuredAxis);
                current = length * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.postRender(() => onDragStart(event, info));
        }
        addValueToWillChange(this.visualElement, "transform");
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openDragLock)
          return;
        const { offset } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset);
        this.updateAxis("y", info.point, offset);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.stop(event, info);
        this.latestPointerEvent = null;
        this.latestPanInfo = null;
      };
      const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        distanceThreshold,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
    /**
     * @internal
     */
    stop(event, panInfo) {
      const finalEvent = event || this.latestPointerEvent;
      const finalPanInfo = panInfo || this.latestPanInfo;
      const isDragging2 = this.isDragging;
      this.cancel();
      if (!isDragging2 || !finalPanInfo || !finalEvent)
        return;
      const { velocity } = finalPanInfo;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
      }
    }
    /**
     * @internal
     */
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset) {
      const { drag: drag2 } = this.getProps();
      if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next = this.originPoint[axis] + offset[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    }
    resolveConstraints() {
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
    }
    getAnimationState(axis) {
      return this.getAxisMotionValue(axis).animation?.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min, max } = projection.layout.layoutBox[axis];
          axisValue.set(point[axis] - mixNumber(min, max, 0.5));
        }
      });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min, max } = this.constraints[axis];
        axisValue.set(mixNumber(min, max, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        drag2 && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      }));
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  };
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/index.mjs
  var DragGesture = class extends Feature {
    constructor(node) {
      super(node);
      this.removeGroupControls = noop;
      this.removeListeners = noop;
      this.controls = new VisualElementDragControls(node);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  };

  // node_modules/framer-motion/dist/es/gestures/pan/index.mjs
  var asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
  var PanGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
  var import_react23 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/node/state.mjs
  var globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false
  };

  // node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  var correctBorderRadius = {
    correct: (latest, node) => {
      if (!node.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x = pixelsToPercent(latest, node.target.x);
      const y = pixelsToPercent(latest, node.target.y);
      return `${x}% ${y}%`;
    }
  };

  // node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
  var correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset] /= xScale;
      shadow[1 + offset] /= yScale;
      const averageScale = mixNumber(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset] === "number")
        shadow[2 + offset] /= averageScale;
      if (typeof shadow[3 + offset] === "number")
        shadow[3 + offset] /= averageScale;
      return template(shadow);
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var hasTakenAnySnapshot = false;
  var MeasureLayoutWithContext = class extends import_react23.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        if (hasTakenAnySnapshot) {
          projection.root.didUpdate();
        }
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const { projection } = visualElement;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      hasTakenAnySnapshot = true;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      hasTakenAnySnapshot = true;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  };
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = (0, import_react23.useContext)(LayoutGroupContext);
    return (0, import_jsx_runtime5.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react23.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
  }
  var defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };

  // node_modules/framer-motion/dist/es/animation/animate/single-value.mjs
  function animateSingleValue(value, keyframes2, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
    return motionValue$1.animation;
  }

  // node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
  var compareByDepth = (a, b) => a.depth - b.depth;

  // node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
  var FlatTree = class {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  };

  // node_modules/framer-motion/dist/es/utils/delay.mjs
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.setup(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }

  // node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
  var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  var numBorders = borders.length;
  var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
  var isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
      target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
    }
    for (let i = 0; i < numBorders; i++) {
      const borderLabel = `border${borders[i]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  var easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
  var easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
  function compress(min, max, easing) {
    return (p) => {
      if (p < min)
        return 0;
      if (p > max)
        return 1;
      return easing(progress(min, max, p));
    };
  }

  // node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
  function removePointDelta(point, translate, scale2, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  var xKeys = ["x", "scaleX", "originX"];
  var yKeys = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a, b) {
    return a.min === b.min && a.max === b.max;
  }
  function boxEquals(a, b) {
    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
  }
  function axisEqualsRounded(a, b) {
    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
  }
  function boxEqualsRounded(a, b) {
    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b) {
    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
  }

  // node_modules/framer-motion/dist/es/projection/shared/stack.mjs
  var NodeStack = class {
    constructor() {
      this.members = [];
    }
    add(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    }
    remove(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node) {
      const indexOfNode = this.members.findIndex((member) => node === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i = indexOfNode; i >= 0; i--) {
        const member = this.members[i];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node.root && node.root.isUpdating) {
          node.isLayoutDirty = true;
        }
        const { crossfade } = node.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node) => {
        const { options, resumingFrom } = node;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node) => {
        node.instance && node.scheduleRender(false);
      });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  };

  // node_modules/framer-motion/dist/es/projection/styles/transform.mjs
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = latestTransform?.z || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective)
        transform = `perspective(${transformPerspective}px) ${transform}`;
      if (rotate2)
        transform += `rotate(${rotate2}deg) `;
      if (rotateX)
        transform += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform += `rotateY(${rotateY}deg) `;
      if (skewX)
        transform += `skewX(${skewX}deg) `;
      if (skewY)
        transform += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || "none";
  }

  // node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
  var metrics = {
    nodes: 0,
    calculatedTargetDeltas: 0,
    calculatedProjections: 0
  };
  var transformAxes = ["", "X", "Y", "Z"];
  var animationTarget = 1e3;
  var id2 = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
      return;
    const { visualElement } = projectionNode.options;
    if (!visualElement)
      return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
      const { layout: layout2, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode2({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent?.()) {
        this.id = id2++;
        this.animationId = 0;
        this.animationCommitId = 0;
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.hasTreeAnimated = false;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          if (statsBuffer.value) {
            metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
          }
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
          if (statsBuffer.addProjectionMetrics) {
            statsBuffer.addProjectionMetrics(metrics);
          }
        };
        this.resolvedRelativeTargetAt = 0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      /**
       * Lifecycles
       */
      mount(instance) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          let innerWidth = 0;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          frame.read(() => {
            innerWidth = window.innerWidth;
          });
          attachResizeListener(instance, () => {
            const newInnerWidth = window.innerWidth;
            if (newInnerWidth === innerWidth)
              return;
            innerWidth = newInnerWidth;
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
            if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        this.eventHandlers.clear();
        cancelFrame(this.updateProjection);
      }
      // only on the root
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      // Note: currently only running on root node
      startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.shouldResetTransform = true;
          node.updateScroll("snapshot");
          if (node.options.layoutRoot) {
            node.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2)
          return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (this.animationId <= this.animationCommitId) {
          this.nodes.forEach(clearIsLayoutDirty);
          return;
        }
        this.animationCommitId = this.animationId;
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        } else {
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
        }
        this.clearAllSnapshots();
        const now2 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
        frameData.timestamp = now2;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      /**
       * Update measurements
       */
      updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
        if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
          this.snapshot = void 0;
        }
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            node.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement && this.instance) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box = visualElement.measureViewportBox();
        const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          const { scroll } = this.root;
          if (scroll) {
            translateAxis(box.x, scroll.offset.x);
            translateAxis(box.y, scroll.offset.y);
          }
        }
        return box;
      }
      removeElementScroll(box) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if (this.scroll?.wasRoot) {
          return boxWithoutScroll;
        }
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          const { scroll, options } = node;
          if (node !== this.root && scroll && options.layoutScroll) {
            if (scroll.wasRoot) {
              copyBoxInto(boxWithoutScroll, box);
            }
            translateAxis(boxWithoutScroll.x, scroll.offset.x);
            translateAxis(boxWithoutScroll.y, scroll.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.offset.x,
              y: -node.scroll.offset.y
            });
          }
          if (!hasTransform(node.latestValues))
            continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          if (!node.instance)
            continue;
          if (!hasTransform(node.latestValues))
            continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        if (!this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (statsBuffer.value) {
          metrics.calculatedTargetDeltas++;
        }
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      calcProjection() {
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
        if (statsBuffer.value) {
          metrics.calculatedProjections++;
        }
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll = true) {
        this.options.visualElement?.scheduleRender();
        if (notifyAll) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation?.stop();
        this.resumingFrom?.currentAnimation?.stop();
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          activeAnimations.layout++;
          this.motionValue || (this.motionValue = motionValue(0));
          this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
            ...options,
            velocity: 0,
            isSync: true,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onStop: () => {
              activeAnimations.layout--;
            },
            onComplete: () => {
              activeAnimations.layout--;
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2)
          return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        const config = node.options.initialPromotionConfig;
        node.promote({
          transition: config ? config.transition : void 0,
          preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.lead || this : this;
      }
      getPrevLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform)
          return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i = 0; i < transformAxes.length; i++) {
          resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      applyProjectionStyles(targetStyle, styleProp) {
        if (!this.instance || this.isSVG)
          return;
        if (!this.isVisible) {
          targetStyle.visibility = "hidden";
          return;
        }
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          targetStyle.visibility = "";
          targetStyle.opacity = "";
          targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          if (this.options.layoutId) {
            targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return;
        }
        targetStyle.visibility = "";
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          transform = transformTemplate(valuesToRender, transform);
        }
        targetStyle.transform = transform;
        const { x, y } = this.projectionDelta;
        targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
        if (lead.animationValues) {
          targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
          const corrected = transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i = 0; i < num; i++) {
              targetStyle[applyTo[i]] = corrected;
            }
          } else {
            if (isCSSVariable) {
              this.options.visualElement.renderState.vars[key] = corrected;
            } else {
              targetStyle[key] = corrected;
            }
          }
        }
        if (this.options.layoutId) {
          targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
        }
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      // Only run on root
      resetTree() {
        this.root.nodes.forEach((node) => node.currentAnimation?.stop());
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    const snapshot = node.resumeFrom?.snapshot || node.snapshot;
    if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
      const { animationType } = node.options;
      const isShared = snapshot.source !== node.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
          if (node.relativeTarget && !node.currentAnimation) {
            node.isProjectionDirty = true;
            node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeLayoutChanged = false;
      if (!node.resumeFrom) {
        const relativeParent = node.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeLayoutChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node.relativeTarget = relativeLayout;
              node.relativeTargetOrigin = relativeSnapshot;
              node.relativeParent = relativeParent;
            }
          }
        }
      }
      node.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeLayoutChanged
      });
    } else if (node.isLead()) {
      const { onExitComplete } = node.options;
      onExitComplete && onExitComplete();
    }
    node.options.transition = void 0;
  }
  function propagateDirtyNodes(node) {
    if (statsBuffer.value) {
      metrics.nodes++;
    }
    if (!node.parent)
      return;
    if (!node.isProjecting()) {
      node.isProjectionDirty = node.parent.isProjectionDirty;
    }
    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node) {
    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function clearIsLayoutDirty(node) {
    node.isLayoutDirty = false;
  }
  function resetTransformStyle(node) {
    const { visualElement } = node.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = void 0;
    node.isProjectionDirty = true;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber(delta.translate, 0, p);
    output.scale = mixNumber(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from, to, p) {
    output.min = mixNumber(from.min, to.min, p);
    output.max = mixNumber(from.max, to.max, p);
  }
  function mixBox(output, from, to, p) {
    mixAxis(output.x, from.x, to.x, p);
    mixAxis(output.y, from.y, to.y, p);
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && node.animationValues.opacityExit !== void 0;
  }
  var defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  var userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
  var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
  }
  function checkNodeWasScrollRoot(node) {
    return node !== node.root && node.scroll?.wasRoot;
  }

  // node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
  var DocumentProjectionNode = createProjectionNode2({
    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });

  // node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
  var rootProjectionNode = {
    current: void 0
  };
  var HTMLProjectionNode = createProjectionNode2({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });

  // node_modules/framer-motion/dist/es/motion/features/drag.mjs
  var drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // node_modules/framer-motion/dist/es/gestures/hover.mjs
  function handleHoverEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.animationState && props.whileHover) {
      node.animationState.setActive("whileHover", lifecycle === "Start");
    }
    const eventName = "onHover" + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  var HoverGesture = class extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
      });
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/gestures/focus.mjs
  var FocusGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/gestures/press.mjs
  function handlePressEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.current instanceof HTMLButtonElement && node.current.disabled) {
      return;
    }
    if (node.animationState && props.whileTap) {
      node.animationState.setActive("whileTap", lifecycle === "Start");
    }
    const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  var PressGesture = class extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = press(current, (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      }, { useGlobalTarget: this.node.props.globalTapTarget });
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
  var observerCallbacks = /* @__PURE__ */ new WeakMap();
  var observers = /* @__PURE__ */ new WeakMap();
  var fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  var fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root, ...options }) {
    const lookupRoot = root || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
  var thresholdNames = {
    some: 0,
    all: 1
  };
  var InViewFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root, margin: rootMargin, amount = "some", once } = viewport;
      const options = {
        root: root ? root.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  };
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  }

  // node_modules/framer-motion/dist/es/motion/features/gestures.mjs
  var gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout.mjs
  var layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // node_modules/framer-motion/dist/es/render/components/motion/feature-bundle.mjs
  var featureBundle = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  };

  // node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs
  var motion = /* @__PURE__ */ createMotionProxy(featureBundle, createDomVisualElement);

  // node_modules/@google/genai/dist/web/index.mjs
  var _defaultBaseGeminiUrl = void 0;
  var _defaultBaseVertexUrl = void 0;
  function getDefaultBaseUrls() {
    return {
      geminiUrl: _defaultBaseGeminiUrl,
      vertexUrl: _defaultBaseVertexUrl
    };
  }
  function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
    var _a, _b;
    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
      const defaultBaseUrls = getDefaultBaseUrls();
      if (vertexai) {
        return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;
      } else {
        return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
      }
    }
    return httpOptions.baseUrl;
  }
  var BaseModule = class {
  };
  function formatMap(templateString, valueMap) {
    const regex = /\{([^}]+)\}/g;
    return templateString.replace(regex, (match, key) => {
      if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
        const value = valueMap[key];
        return value !== void 0 && value !== null ? String(value) : "";
      } else {
        throw new Error(`Key '${key}' not found in valueMap.`);
      }
    });
  }
  function setValueByPath(data, keys, value) {
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (!(keyName in data)) {
          if (Array.isArray(value)) {
            data[keyName] = Array.from({ length: value.length }, () => ({}));
          } else {
            throw new Error(`Value must be a list given an array path ${key}`);
          }
        }
        if (Array.isArray(data[keyName])) {
          const arrayData = data[keyName];
          if (Array.isArray(value)) {
            for (let j = 0; j < arrayData.length; j++) {
              const entry = arrayData[j];
              setValueByPath(entry, keys.slice(i + 1), value[j]);
            }
          } else {
            for (const d of arrayData) {
              setValueByPath(d, keys.slice(i + 1), value);
            }
          }
        }
        return;
      } else if (key.endsWith("[0]")) {
        const keyName = key.slice(0, -3);
        if (!(keyName in data)) {
          data[keyName] = [{}];
        }
        const arrayData = data[keyName];
        setValueByPath(arrayData[0], keys.slice(i + 1), value);
        return;
      }
      if (!data[key] || typeof data[key] !== "object") {
        data[key] = {};
      }
      data = data[key];
    }
    const keyToSet = keys[keys.length - 1];
    const existingData = data[keyToSet];
    if (existingData !== void 0) {
      if (!value || typeof value === "object" && Object.keys(value).length === 0) {
        return;
      }
      if (value === existingData) {
        return;
      }
      if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
        Object.assign(existingData, value);
      } else {
        throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
      }
    } else {
      if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
        const valueAsRecord = value;
        Object.assign(data, valueAsRecord);
      } else {
        data[keyToSet] = value;
      }
    }
  }
  function getValueByPath(data, keys, defaultValue = void 0) {
    try {
      if (keys.length === 1 && keys[0] === "_self") {
        return data;
      }
      for (let i = 0; i < keys.length; i++) {
        if (typeof data !== "object" || data === null) {
          return defaultValue;
        }
        const key = keys[i];
        if (key.endsWith("[]")) {
          const keyName = key.slice(0, -2);
          if (keyName in data) {
            const arrayData = data[keyName];
            if (!Array.isArray(arrayData)) {
              return defaultValue;
            }
            return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));
          } else {
            return defaultValue;
          }
        } else {
          data = data[key];
        }
      }
      return data;
    } catch (error) {
      if (error instanceof TypeError) {
        return defaultValue;
      }
      throw error;
    }
  }
  function moveValueByPath(data, paths) {
    for (const [sourcePath, destPath] of Object.entries(paths)) {
      const sourceKeys = sourcePath.split(".");
      const destKeys = destPath.split(".");
      const excludeKeys = /* @__PURE__ */ new Set();
      let wildcardIdx = -1;
      for (let i = 0; i < sourceKeys.length; i++) {
        if (sourceKeys[i] === "*") {
          wildcardIdx = i;
          break;
        }
      }
      if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {
        for (let i = wildcardIdx; i < destKeys.length; i++) {
          const key = destKeys[i];
          if (key !== "*" && !key.endsWith("[]") && !key.endsWith("[0]")) {
            excludeKeys.add(key);
          }
        }
      }
      _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);
    }
  }
  function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {
    if (keyIdx >= sourceKeys.length) {
      return;
    }
    if (typeof data !== "object" || data === null) {
      return;
    }
    const key = sourceKeys[keyIdx];
    if (key.endsWith("[]")) {
      const keyName = key.slice(0, -2);
      const dataRecord = data;
      if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {
        for (const item of dataRecord[keyName]) {
          _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);
        }
      }
    } else if (key === "*") {
      if (typeof data === "object" && data !== null && !Array.isArray(data)) {
        const dataRecord = data;
        const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith("_") && !excludeKeys.has(k));
        const valuesToMove = {};
        for (const k of keysToMove) {
          valuesToMove[k] = dataRecord[k];
        }
        for (const [k, v] of Object.entries(valuesToMove)) {
          const newDestKeys = [];
          for (const dk of destKeys.slice(keyIdx)) {
            if (dk === "*") {
              newDestKeys.push(k);
            } else {
              newDestKeys.push(dk);
            }
          }
          setValueByPath(dataRecord, newDestKeys, v);
        }
        for (const k of keysToMove) {
          delete dataRecord[k];
        }
      }
    } else {
      const dataRecord = data;
      if (key in dataRecord) {
        _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);
      }
    }
  }
  function tBytes$1(fromBytes) {
    if (typeof fromBytes !== "string") {
      throw new Error("fromImageBytes must be a string");
    }
    return fromBytes;
  }
  function fetchPredictOperationParametersToVertex(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["operationName"], fromOperationName);
    }
    const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
    if (fromResourceName != null) {
      setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
    }
    return toObject;
  }
  function generateVideosOperationFromVertex$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
    }
    return toObject;
  }
  function generateVideosResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosResponseFromVertex$1(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex$1(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generatedVideoFromMldev$1(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
    }
    return toObject;
  }
  function generatedVideoFromVertex$1(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
    }
    return toObject;
  }
  function getOperationParametersToMldev(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    return toObject;
  }
  function getOperationParametersToVertex(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    return toObject;
  }
  function importFileOperationFromMldev$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], importFileResponseFromMldev$1(fromResponse));
    }
    return toObject;
  }
  function importFileResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["parent"], fromParent);
    }
    const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
    if (fromDocumentName != null) {
      setValueByPath(toObject, ["documentName"], fromDocumentName);
    }
    return toObject;
  }
  function uploadToFileSearchStoreOperationFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], uploadToFileSearchStoreResponseFromMldev(fromResponse));
    }
    return toObject;
  }
  function uploadToFileSearchStoreResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["parent"], fromParent);
    }
    const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
    if (fromDocumentName != null) {
      setValueByPath(toObject, ["documentName"], fromDocumentName);
    }
    return toObject;
  }
  function videoFromMldev$1(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoFromVertex$1(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  var Outcome;
  (function(Outcome2) {
    Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
    Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
    Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
    Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
  })(Outcome || (Outcome = {}));
  var Language;
  (function(Language2) {
    Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
    Language2["PYTHON"] = "PYTHON";
  })(Language || (Language = {}));
  var FunctionResponseScheduling;
  (function(FunctionResponseScheduling2) {
    FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
    FunctionResponseScheduling2["SILENT"] = "SILENT";
    FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
    FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
  })(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
  var Type;
  (function(Type2) {
    Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
    Type2["STRING"] = "STRING";
    Type2["NUMBER"] = "NUMBER";
    Type2["INTEGER"] = "INTEGER";
    Type2["BOOLEAN"] = "BOOLEAN";
    Type2["ARRAY"] = "ARRAY";
    Type2["OBJECT"] = "OBJECT";
    Type2["NULL"] = "NULL";
  })(Type || (Type = {}));
  var Mode;
  (function(Mode2) {
    Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
  })(Mode || (Mode = {}));
  var ApiSpec;
  (function(ApiSpec2) {
    ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
    ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
    ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
  })(ApiSpec || (ApiSpec = {}));
  var AuthType;
  (function(AuthType2) {
    AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
    AuthType2["NO_AUTH"] = "NO_AUTH";
    AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
    AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
    AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
    AuthType2["OAUTH"] = "OAUTH";
    AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
  })(AuthType || (AuthType = {}));
  var HttpElementLocation;
  (function(HttpElementLocation2) {
    HttpElementLocation2["HTTP_IN_UNSPECIFIED"] = "HTTP_IN_UNSPECIFIED";
    HttpElementLocation2["HTTP_IN_QUERY"] = "HTTP_IN_QUERY";
    HttpElementLocation2["HTTP_IN_HEADER"] = "HTTP_IN_HEADER";
    HttpElementLocation2["HTTP_IN_PATH"] = "HTTP_IN_PATH";
    HttpElementLocation2["HTTP_IN_BODY"] = "HTTP_IN_BODY";
    HttpElementLocation2["HTTP_IN_COOKIE"] = "HTTP_IN_COOKIE";
  })(HttpElementLocation || (HttpElementLocation = {}));
  var PhishBlockThreshold;
  (function(PhishBlockThreshold2) {
    PhishBlockThreshold2["PHISH_BLOCK_THRESHOLD_UNSPECIFIED"] = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED";
    PhishBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    PhishBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    PhishBlockThreshold2["BLOCK_HIGH_AND_ABOVE"] = "BLOCK_HIGH_AND_ABOVE";
    PhishBlockThreshold2["BLOCK_HIGHER_AND_ABOVE"] = "BLOCK_HIGHER_AND_ABOVE";
    PhishBlockThreshold2["BLOCK_VERY_HIGH_AND_ABOVE"] = "BLOCK_VERY_HIGH_AND_ABOVE";
    PhishBlockThreshold2["BLOCK_ONLY_EXTREMELY_HIGH"] = "BLOCK_ONLY_EXTREMELY_HIGH";
  })(PhishBlockThreshold || (PhishBlockThreshold = {}));
  var ThinkingLevel;
  (function(ThinkingLevel2) {
    ThinkingLevel2["THINKING_LEVEL_UNSPECIFIED"] = "THINKING_LEVEL_UNSPECIFIED";
    ThinkingLevel2["LOW"] = "LOW";
    ThinkingLevel2["HIGH"] = "HIGH";
  })(ThinkingLevel || (ThinkingLevel = {}));
  var HarmCategory;
  (function(HarmCategory2) {
    HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
    HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
    HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
    HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
    HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
    HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
    HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
    HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
    HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
    HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
    HarmCategory2["HARM_CATEGORY_JAILBREAK"] = "HARM_CATEGORY_JAILBREAK";
  })(HarmCategory || (HarmCategory = {}));
  var HarmBlockMethod;
  (function(HarmBlockMethod2) {
    HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
    HarmBlockMethod2["SEVERITY"] = "SEVERITY";
    HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
  })(HarmBlockMethod || (HarmBlockMethod = {}));
  var HarmBlockThreshold;
  (function(HarmBlockThreshold2) {
    HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
    HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
    HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
    HarmBlockThreshold2["OFF"] = "OFF";
  })(HarmBlockThreshold || (HarmBlockThreshold = {}));
  var FinishReason;
  (function(FinishReason2) {
    FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
    FinishReason2["STOP"] = "STOP";
    FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
    FinishReason2["SAFETY"] = "SAFETY";
    FinishReason2["RECITATION"] = "RECITATION";
    FinishReason2["LANGUAGE"] = "LANGUAGE";
    FinishReason2["OTHER"] = "OTHER";
    FinishReason2["BLOCKLIST"] = "BLOCKLIST";
    FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
    FinishReason2["SPII"] = "SPII";
    FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
    FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
    FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
    FinishReason2["IMAGE_PROHIBITED_CONTENT"] = "IMAGE_PROHIBITED_CONTENT";
    FinishReason2["NO_IMAGE"] = "NO_IMAGE";
  })(FinishReason || (FinishReason = {}));
  var HarmProbability;
  (function(HarmProbability2) {
    HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
    HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
    HarmProbability2["LOW"] = "LOW";
    HarmProbability2["MEDIUM"] = "MEDIUM";
    HarmProbability2["HIGH"] = "HIGH";
  })(HarmProbability || (HarmProbability = {}));
  var HarmSeverity;
  (function(HarmSeverity2) {
    HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
    HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
    HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
    HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
    HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
  })(HarmSeverity || (HarmSeverity = {}));
  var UrlRetrievalStatus;
  (function(UrlRetrievalStatus2) {
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
  })(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
  var BlockedReason;
  (function(BlockedReason2) {
    BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
    BlockedReason2["SAFETY"] = "SAFETY";
    BlockedReason2["OTHER"] = "OTHER";
    BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
    BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
    BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
    BlockedReason2["MODEL_ARMOR"] = "MODEL_ARMOR";
    BlockedReason2["JAILBREAK"] = "JAILBREAK";
  })(BlockedReason || (BlockedReason = {}));
  var TrafficType;
  (function(TrafficType2) {
    TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
    TrafficType2["ON_DEMAND"] = "ON_DEMAND";
    TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
  })(TrafficType || (TrafficType = {}));
  var Modality;
  (function(Modality2) {
    Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
    Modality2["TEXT"] = "TEXT";
    Modality2["IMAGE"] = "IMAGE";
    Modality2["AUDIO"] = "AUDIO";
  })(Modality || (Modality = {}));
  var MediaResolution;
  (function(MediaResolution2) {
    MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
    MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
    MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
    MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
  })(MediaResolution || (MediaResolution = {}));
  var TuningMode;
  (function(TuningMode2) {
    TuningMode2["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
    TuningMode2["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
    TuningMode2["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
  })(TuningMode || (TuningMode = {}));
  var AdapterSize;
  (function(AdapterSize2) {
    AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
    AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
    AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
    AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
    AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
    AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
    AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
  })(AdapterSize || (AdapterSize = {}));
  var JobState;
  (function(JobState2) {
    JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
    JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
    JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
    JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
    JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
    JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
    JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
    JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
    JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
    JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
    JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
    JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
  })(JobState || (JobState = {}));
  var TuningTask;
  (function(TuningTask2) {
    TuningTask2["TUNING_TASK_UNSPECIFIED"] = "TUNING_TASK_UNSPECIFIED";
    TuningTask2["TUNING_TASK_I2V"] = "TUNING_TASK_I2V";
    TuningTask2["TUNING_TASK_T2V"] = "TUNING_TASK_T2V";
    TuningTask2["TUNING_TASK_R2V"] = "TUNING_TASK_R2V";
  })(TuningTask || (TuningTask = {}));
  var PartMediaResolutionLevel;
  (function(PartMediaResolutionLevel2) {
    PartMediaResolutionLevel2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
    PartMediaResolutionLevel2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
    PartMediaResolutionLevel2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
    PartMediaResolutionLevel2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
  })(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));
  var FeatureSelectionPreference;
  (function(FeatureSelectionPreference2) {
    FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
    FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
    FeatureSelectionPreference2["BALANCED"] = "BALANCED";
    FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
  })(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
  var Behavior;
  (function(Behavior2) {
    Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
    Behavior2["BLOCKING"] = "BLOCKING";
    Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
  })(Behavior || (Behavior = {}));
  var DynamicRetrievalConfigMode;
  (function(DynamicRetrievalConfigMode2) {
    DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
  })(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
  var Environment;
  (function(Environment2) {
    Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
    Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
  })(Environment || (Environment = {}));
  var FunctionCallingConfigMode;
  (function(FunctionCallingConfigMode2) {
    FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    FunctionCallingConfigMode2["AUTO"] = "AUTO";
    FunctionCallingConfigMode2["ANY"] = "ANY";
    FunctionCallingConfigMode2["NONE"] = "NONE";
    FunctionCallingConfigMode2["VALIDATED"] = "VALIDATED";
  })(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
  var SafetyFilterLevel;
  (function(SafetyFilterLevel2) {
    SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
    SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
  })(SafetyFilterLevel || (SafetyFilterLevel = {}));
  var PersonGeneration;
  (function(PersonGeneration2) {
    PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
    PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
    PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
  })(PersonGeneration || (PersonGeneration = {}));
  var ImagePromptLanguage;
  (function(ImagePromptLanguage2) {
    ImagePromptLanguage2["auto"] = "auto";
    ImagePromptLanguage2["en"] = "en";
    ImagePromptLanguage2["ja"] = "ja";
    ImagePromptLanguage2["ko"] = "ko";
    ImagePromptLanguage2["hi"] = "hi";
    ImagePromptLanguage2["zh"] = "zh";
    ImagePromptLanguage2["pt"] = "pt";
    ImagePromptLanguage2["es"] = "es";
  })(ImagePromptLanguage || (ImagePromptLanguage = {}));
  var MaskReferenceMode;
  (function(MaskReferenceMode2) {
    MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
    MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
    MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
    MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
    MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
  })(MaskReferenceMode || (MaskReferenceMode = {}));
  var ControlReferenceType;
  (function(ControlReferenceType2) {
    ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
    ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
    ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
    ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
  })(ControlReferenceType || (ControlReferenceType = {}));
  var SubjectReferenceType;
  (function(SubjectReferenceType2) {
    SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
    SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
    SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
    SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
  })(SubjectReferenceType || (SubjectReferenceType = {}));
  var EditMode;
  (function(EditMode2) {
    EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
    EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
    EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
    EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
    EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
    EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
    EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
    EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
  })(EditMode || (EditMode = {}));
  var SegmentMode;
  (function(SegmentMode2) {
    SegmentMode2["FOREGROUND"] = "FOREGROUND";
    SegmentMode2["BACKGROUND"] = "BACKGROUND";
    SegmentMode2["PROMPT"] = "PROMPT";
    SegmentMode2["SEMANTIC"] = "SEMANTIC";
    SegmentMode2["INTERACTIVE"] = "INTERACTIVE";
  })(SegmentMode || (SegmentMode = {}));
  var VideoGenerationReferenceType;
  (function(VideoGenerationReferenceType2) {
    VideoGenerationReferenceType2["ASSET"] = "ASSET";
    VideoGenerationReferenceType2["STYLE"] = "STYLE";
  })(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
  var VideoGenerationMaskMode;
  (function(VideoGenerationMaskMode2) {
    VideoGenerationMaskMode2["INSERT"] = "INSERT";
    VideoGenerationMaskMode2["REMOVE"] = "REMOVE";
    VideoGenerationMaskMode2["REMOVE_STATIC"] = "REMOVE_STATIC";
    VideoGenerationMaskMode2["OUTPAINT"] = "OUTPAINT";
  })(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
  var VideoCompressionQuality;
  (function(VideoCompressionQuality2) {
    VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
    VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
  })(VideoCompressionQuality || (VideoCompressionQuality = {}));
  var TuningMethod;
  (function(TuningMethod2) {
    TuningMethod2["SUPERVISED_FINE_TUNING"] = "SUPERVISED_FINE_TUNING";
    TuningMethod2["PREFERENCE_TUNING"] = "PREFERENCE_TUNING";
  })(TuningMethod || (TuningMethod = {}));
  var DocumentState;
  (function(DocumentState2) {
    DocumentState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
    DocumentState2["STATE_PENDING"] = "STATE_PENDING";
    DocumentState2["STATE_ACTIVE"] = "STATE_ACTIVE";
    DocumentState2["STATE_FAILED"] = "STATE_FAILED";
  })(DocumentState || (DocumentState = {}));
  var FileState;
  (function(FileState2) {
    FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
    FileState2["PROCESSING"] = "PROCESSING";
    FileState2["ACTIVE"] = "ACTIVE";
    FileState2["FAILED"] = "FAILED";
  })(FileState || (FileState = {}));
  var FileSource;
  (function(FileSource2) {
    FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
    FileSource2["UPLOADED"] = "UPLOADED";
    FileSource2["GENERATED"] = "GENERATED";
  })(FileSource || (FileSource = {}));
  var TurnCompleteReason;
  (function(TurnCompleteReason2) {
    TurnCompleteReason2["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
    TurnCompleteReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
    TurnCompleteReason2["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
    TurnCompleteReason2["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
  })(TurnCompleteReason || (TurnCompleteReason = {}));
  var MediaModality;
  (function(MediaModality2) {
    MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
    MediaModality2["TEXT"] = "TEXT";
    MediaModality2["IMAGE"] = "IMAGE";
    MediaModality2["VIDEO"] = "VIDEO";
    MediaModality2["AUDIO"] = "AUDIO";
    MediaModality2["DOCUMENT"] = "DOCUMENT";
  })(MediaModality || (MediaModality = {}));
  var StartSensitivity;
  (function(StartSensitivity2) {
    StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
    StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
    StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
  })(StartSensitivity || (StartSensitivity = {}));
  var EndSensitivity;
  (function(EndSensitivity2) {
    EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
    EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
    EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
  })(EndSensitivity || (EndSensitivity = {}));
  var ActivityHandling;
  (function(ActivityHandling2) {
    ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
    ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
    ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
  })(ActivityHandling || (ActivityHandling = {}));
  var TurnCoverage;
  (function(TurnCoverage2) {
    TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
    TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
    TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
  })(TurnCoverage || (TurnCoverage = {}));
  var Scale;
  (function(Scale2) {
    Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
    Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
    Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
    Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
    Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
    Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
    Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
    Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
    Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
    Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
    Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
    Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
    Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
  })(Scale || (Scale = {}));
  var MusicGenerationMode;
  (function(MusicGenerationMode2) {
    MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
    MusicGenerationMode2["QUALITY"] = "QUALITY";
    MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
    MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
  })(MusicGenerationMode || (MusicGenerationMode = {}));
  var LiveMusicPlaybackControl;
  (function(LiveMusicPlaybackControl2) {
    LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
    LiveMusicPlaybackControl2["PLAY"] = "PLAY";
    LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
    LiveMusicPlaybackControl2["STOP"] = "STOP";
    LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
  })(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
  var HttpResponse = class {
    constructor(response) {
      const headers = {};
      for (const pair of response.headers.entries()) {
        headers[pair[0]] = pair[1];
      }
      this.headers = headers;
      this.responseInternal = response;
    }
    json() {
      return this.responseInternal.json();
    }
  };
  var GenerateContentResponse = class {
    /**
     * Returns the concatenation of all text parts from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the text from the first
     * one will be returned.
     * If there are non-text parts in the response, the concatenation of all text
     * parts will be returned, and a warning will be logged.
     * If there are thought parts in the response, the concatenation of all text
     * parts excluding the thought parts will be returned.
     *
     * @example
     * ```ts
     * const response = await ai.models.generateContent({
     *   model: 'gemini-2.0-flash',
     *   contents:
     *     'Why is the sky blue?',
     * });
     *
     * console.debug(response.text);
     * ```
     */
    get text() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning text from the first one.");
      }
      let text = "";
      let anyTextPartText = false;
      const nonTextParts = [];
      for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "text" && fieldName !== "thought" && fieldName !== "thoughtSignature" && (fieldValue !== null || fieldValue !== void 0)) {
            nonTextParts.push(fieldName);
          }
        }
        if (typeof part.text === "string") {
          if (typeof part.thought === "boolean" && part.thought) {
            continue;
          }
          anyTextPartText = true;
          text += part.text;
        }
      }
      if (nonTextParts.length > 0) {
        console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
      }
      return anyTextPartText ? text : void 0;
    }
    /**
     * Returns the concatenation of all inline data parts from the first candidate
     * in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the inline data from the
     * first one will be returned. If there are non-inline data parts in the
     * response, the concatenation of all inline data parts will be returned, and
     * a warning will be logged.
     */
    get data() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning data from the first one.");
      }
      let data = "";
      const nonDataParts = [];
      for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
            nonDataParts.push(fieldName);
          }
        }
        if (part.inlineData && typeof part.inlineData.data === "string") {
          data += atob(part.inlineData.data);
        }
      }
      if (nonDataParts.length > 0) {
        console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
      }
      return data.length > 0 ? btoa(data) : void 0;
    }
    /**
     * Returns the function calls from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the function calls from
     * the first one will be returned.
     * If there are no function calls in the response, undefined will be returned.
     *
     * @example
     * ```ts
     * const controlLightFunctionDeclaration: FunctionDeclaration = {
     *   name: 'controlLight',
     *   parameters: {
     *   type: Type.OBJECT,
     *   description: 'Set the brightness and color temperature of a room light.',
     *   properties: {
     *     brightness: {
     *       type: Type.NUMBER,
     *       description:
     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
     *     },
     *     colorTemperature: {
     *       type: Type.STRING,
     *       description:
     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
     *     },
     *   },
     *   required: ['brightness', 'colorTemperature'],
     *  };
     *  const response = await ai.models.generateContent({
     *     model: 'gemini-2.0-flash',
     *     contents: 'Dim the lights so the room feels cozy and warm.',
     *     config: {
     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
     *       toolConfig: {
     *         functionCallingConfig: {
     *           mode: FunctionCallingConfigMode.ANY,
     *           allowedFunctionNames: ['controlLight'],
     *         },
     *       },
     *     },
     *   });
     *  console.debug(JSON.stringify(response.functionCalls));
     * ```
     */
    get functionCalls() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning function calls from the first one.");
      }
      const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
      if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
        return void 0;
      }
      return functionCalls;
    }
    /**
     * Returns the first executable code from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the executable code from
     * the first one will be returned.
     * If there are no executable code in the response, undefined will be
     * returned.
     *
     * @example
     * ```ts
     * const response = await ai.models.generateContent({
     *   model: 'gemini-2.0-flash',
     *   contents:
     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
     *   config: {
     *     tools: [{codeExecution: {}}],
     *   },
     * });
     *
     * console.debug(response.executableCode);
     * ```
     */
    get executableCode() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning executable code from the first one.");
      }
      const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
      if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
        return void 0;
      }
      return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
    }
    /**
     * Returns the first code execution result from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the code execution result from
     * the first one will be returned.
     * If there are no code execution result in the response, undefined will be returned.
     *
     * @example
     * ```ts
     * const response = await ai.models.generateContent({
     *   model: 'gemini-2.0-flash',
     *   contents:
     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
     *   config: {
     *     tools: [{codeExecution: {}}],
     *   },
     * });
     *
     * console.debug(response.codeExecutionResult);
     * ```
     */
    get codeExecutionResult() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
      }
      const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
      if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
        return void 0;
      }
      return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
    }
  };
  var EmbedContentResponse = class {
  };
  var GenerateImagesResponse = class {
  };
  var EditImageResponse = class {
  };
  var UpscaleImageResponse = class {
  };
  var RecontextImageResponse = class {
  };
  var SegmentImageResponse = class {
  };
  var ListModelsResponse = class {
  };
  var DeleteModelResponse = class {
  };
  var CountTokensResponse = class {
  };
  var ComputeTokensResponse = class {
  };
  var GenerateVideosOperation = class _GenerateVideosOperation {
    /**
     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
     * @internal
     */
    _fromAPIResponse({ apiResponse, _isVertexAI }) {
      const operation = new _GenerateVideosOperation();
      let response;
      const op = apiResponse;
      if (_isVertexAI) {
        response = generateVideosOperationFromVertex$1(op);
      } else {
        response = generateVideosOperationFromMldev$1(op);
      }
      Object.assign(operation, response);
      return operation;
    }
  };
  var ListTuningJobsResponse = class {
  };
  var DeleteCachedContentResponse = class {
  };
  var ListCachedContentsResponse = class {
  };
  var ListDocumentsResponse = class {
  };
  var ListFileSearchStoresResponse = class {
  };
  var UploadToFileSearchStoreResumableResponse = class {
  };
  var ImportFileOperation = class _ImportFileOperation {
    /**
     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
     * @internal
     */
    _fromAPIResponse({ apiResponse, _isVertexAI }) {
      const operation = new _ImportFileOperation();
      const op = apiResponse;
      const response = importFileOperationFromMldev$1(op);
      Object.assign(operation, response);
      return operation;
    }
  };
  var ListFilesResponse = class {
  };
  var CreateFileResponse = class {
  };
  var DeleteFileResponse = class {
  };
  var ListBatchJobsResponse = class {
  };
  var LiveServerMessage = class {
    /**
     * Returns the concatenation of all text parts from the server content if present.
     *
     * @remarks
     * If there are non-text parts in the response, the concatenation of all text
     * parts will be returned, and a warning will be logged.
     */
    get text() {
      var _a, _b, _c;
      let text = "";
      let anyTextPartFound = false;
      const nonTextParts = [];
      for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
            nonTextParts.push(fieldName);
          }
        }
        if (typeof part.text === "string") {
          if (typeof part.thought === "boolean" && part.thought) {
            continue;
          }
          anyTextPartFound = true;
          text += part.text;
        }
      }
      if (nonTextParts.length > 0) {
        console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
      }
      return anyTextPartFound ? text : void 0;
    }
    /**
     * Returns the concatenation of all inline data parts from the server content if present.
     *
     * @remarks
     * If there are non-inline data parts in the
     * response, the concatenation of all inline data parts will be returned, and
     * a warning will be logged.
     */
    get data() {
      var _a, _b, _c;
      let data = "";
      const nonDataParts = [];
      for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "inlineData" && fieldValue !== null) {
            nonDataParts.push(fieldName);
          }
        }
        if (part.inlineData && typeof part.inlineData.data === "string") {
          data += atob(part.inlineData.data);
        }
      }
      if (nonDataParts.length > 0) {
        console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
      }
      return data.length > 0 ? btoa(data) : void 0;
    }
  };
  var LiveMusicServerMessage = class {
    /**
     * Returns the first audio chunk from the server content, if present.
     *
     * @remarks
     * If there are no audio chunks in the response, undefined will be returned.
     */
    get audioChunk() {
      if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
        return this.serverContent.audioChunks[0];
      }
      return void 0;
    }
  };
  var UploadToFileSearchStoreOperation = class _UploadToFileSearchStoreOperation {
    /**
     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
     * @internal
     */
    _fromAPIResponse({ apiResponse, _isVertexAI }) {
      const operation = new _UploadToFileSearchStoreOperation();
      const op = apiResponse;
      const response = uploadToFileSearchStoreOperationFromMldev(op);
      Object.assign(operation, response);
      return operation;
    }
  };
  function tModel(apiClient, model) {
    if (!model || typeof model !== "string") {
      throw new Error("model is required and must be a string");
    }
    if (model.includes("..") || model.includes("?") || model.includes("&")) {
      throw new Error("invalid model parameter");
    }
    if (apiClient.isVertexAI()) {
      if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
        return model;
      } else if (model.indexOf("/") >= 0) {
        const parts = model.split("/", 2);
        return `publishers/${parts[0]}/models/${parts[1]}`;
      } else {
        return `publishers/google/models/${model}`;
      }
    } else {
      if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
        return model;
      } else {
        return `models/${model}`;
      }
    }
  }
  function tCachesModel(apiClient, model) {
    const transformedModel = tModel(apiClient, model);
    if (!transformedModel) {
      return "";
    }
    if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
    } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
    } else {
      return transformedModel;
    }
  }
  function tBlobs(blobs) {
    if (Array.isArray(blobs)) {
      return blobs.map((blob) => tBlob(blob));
    } else {
      return [tBlob(blobs)];
    }
  }
  function tBlob(blob) {
    if (typeof blob === "object" && blob !== null) {
      return blob;
    }
    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
  }
  function tImageBlob(blob) {
    const transformedBlob = tBlob(blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tAudioBlob(blob) {
    const transformedBlob = tBlob(blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tPart(origin) {
    if (origin === null || origin === void 0) {
      throw new Error("PartUnion is required");
    }
    if (typeof origin === "object") {
      return origin;
    }
    if (typeof origin === "string") {
      return { text: origin };
    }
    throw new Error(`Unsupported part type: ${typeof origin}`);
  }
  function tParts(origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("PartListUnion is required");
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tPart(item));
    }
    return [tPart(origin)];
  }
  function _isContent(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
  }
  function _isFunctionCallPart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
  }
  function _isFunctionResponsePart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
  }
  function tContent(origin) {
    if (origin === null || origin === void 0) {
      throw new Error("ContentUnion is required");
    }
    if (_isContent(origin)) {
      return origin;
    }
    return {
      role: "user",
      parts: tParts(origin)
    };
  }
  function tContentsForEmbed(apiClient, origin) {
    if (!origin) {
      return [];
    }
    if (apiClient.isVertexAI() && Array.isArray(origin)) {
      return origin.flatMap((item) => {
        const content = tContent(item);
        if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
          return [content.parts[0].text];
        }
        return [];
      });
    } else if (apiClient.isVertexAI()) {
      const content = tContent(origin);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
        return [content.parts[0].text];
      }
      return [];
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tContent(item));
    }
    return [tContent(origin)];
  }
  function tContents(origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("contents are required");
    }
    if (!Array.isArray(origin)) {
      if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
      }
      return [tContent(origin)];
    }
    const result = [];
    const accumulatedParts = [];
    const isContentArray = _isContent(origin[0]);
    for (const item of origin) {
      const isContent = _isContent(item);
      if (isContent != isContentArray) {
        throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
      }
      if (isContent) {
        result.push(item);
      } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
      } else {
        accumulatedParts.push(item);
      }
    }
    if (!isContentArray) {
      result.push({ role: "user", parts: tParts(accumulatedParts) });
    }
    return result;
  }
  function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
    if (typeList.includes("null")) {
      resultingSchema["nullable"] = true;
    }
    const listWithoutNull = typeList.filter((type) => type !== "null");
    if (listWithoutNull.length === 1) {
      resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
    } else {
      resultingSchema["anyOf"] = [];
      for (const i of listWithoutNull) {
        resultingSchema["anyOf"].push({
          "type": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED
        });
      }
    }
  }
  function processJsonSchema(_jsonSchema) {
    const genAISchema = {};
    const schemaFieldNames = ["items"];
    const listSchemaFieldNames = ["anyOf"];
    const dictSchemaFieldNames = ["properties"];
    if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
      throw new Error("type and anyOf cannot be both populated.");
    }
    const incomingAnyOf = _jsonSchema["anyOf"];
    if (incomingAnyOf != null && incomingAnyOf.length == 2) {
      if (incomingAnyOf[0]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[1];
      } else if (incomingAnyOf[1]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[0];
      }
    }
    if (_jsonSchema["type"] instanceof Array) {
      flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
    }
    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
      if (fieldValue == null) {
        continue;
      }
      if (fieldName == "type") {
        if (fieldValue === "null") {
          throw new Error("type: null can not be the only possible type for the field.");
        }
        if (fieldValue instanceof Array) {
          continue;
        }
        genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
      } else if (schemaFieldNames.includes(fieldName)) {
        genAISchema[fieldName] = processJsonSchema(fieldValue);
      } else if (listSchemaFieldNames.includes(fieldName)) {
        const listSchemaFieldValue = [];
        for (const item of fieldValue) {
          if (item["type"] == "null") {
            genAISchema["nullable"] = true;
            continue;
          }
          listSchemaFieldValue.push(processJsonSchema(item));
        }
        genAISchema[fieldName] = listSchemaFieldValue;
      } else if (dictSchemaFieldNames.includes(fieldName)) {
        const dictSchemaFieldValue = {};
        for (const [key, value] of Object.entries(fieldValue)) {
          dictSchemaFieldValue[key] = processJsonSchema(value);
        }
        genAISchema[fieldName] = dictSchemaFieldValue;
      } else {
        if (fieldName === "additionalProperties") {
          continue;
        }
        genAISchema[fieldName] = fieldValue;
      }
    }
    return genAISchema;
  }
  function tSchema(schema) {
    return processJsonSchema(schema);
  }
  function tSpeechConfig(speechConfig) {
    if (typeof speechConfig === "object") {
      return speechConfig;
    } else if (typeof speechConfig === "string") {
      return {
        voiceConfig: {
          prebuiltVoiceConfig: {
            voiceName: speechConfig
          }
        }
      };
    } else {
      throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
    }
  }
  function tLiveSpeechConfig(speechConfig) {
    if ("multiSpeakerVoiceConfig" in speechConfig) {
      throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
    }
    return speechConfig;
  }
  function tTool(tool) {
    if (tool.functionDeclarations) {
      for (const functionDeclaration of tool.functionDeclarations) {
        if (functionDeclaration.parameters) {
          if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
            functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
          } else {
            if (!functionDeclaration.parametersJsonSchema) {
              functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
              delete functionDeclaration.parameters;
            }
          }
        }
        if (functionDeclaration.response) {
          if (!Object.keys(functionDeclaration.response).includes("$schema")) {
            functionDeclaration.response = processJsonSchema(functionDeclaration.response);
          } else {
            if (!functionDeclaration.responseJsonSchema) {
              functionDeclaration.responseJsonSchema = functionDeclaration.response;
              delete functionDeclaration.response;
            }
          }
        }
      }
    }
    return tool;
  }
  function tTools(tools) {
    if (tools === void 0 || tools === null) {
      throw new Error("tools is required");
    }
    if (!Array.isArray(tools)) {
      throw new Error("tools is required and must be an array of Tools");
    }
    const result = [];
    for (const tool of tools) {
      result.push(tool);
    }
    return result;
  }
  function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
    const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
    if (client.isVertexAI()) {
      if (resourceName2.startsWith("projects/")) {
        return resourceName2;
      } else if (resourceName2.startsWith("locations/")) {
        return `projects/${client.getProject()}/${resourceName2}`;
      } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
      } else if (shouldAppendPrefix) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
      } else {
        return resourceName2;
      }
    }
    if (shouldAppendPrefix) {
      return `${resourcePrefix}/${resourceName2}`;
    }
    return resourceName2;
  }
  function tCachedContentName(apiClient, name) {
    if (typeof name !== "string") {
      throw new Error("name must be a string");
    }
    return resourceName(apiClient, name, "cachedContents");
  }
  function tTuningJobStatus(status) {
    switch (status) {
      case "STATE_UNSPECIFIED":
        return "JOB_STATE_UNSPECIFIED";
      case "CREATING":
        return "JOB_STATE_RUNNING";
      case "ACTIVE":
        return "JOB_STATE_SUCCEEDED";
      case "FAILED":
        return "JOB_STATE_FAILED";
      default:
        return status;
    }
  }
  function tBytes(fromImageBytes) {
    return tBytes$1(fromImageBytes);
  }
  function _isFile(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
  }
  function isGeneratedVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
  }
  function isVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
  }
  function tFileName(fromName) {
    var _a;
    let name;
    if (_isFile(fromName)) {
      name = fromName.name;
    }
    if (isVideo(fromName)) {
      name = fromName.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (isGeneratedVideo(fromName)) {
      name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (typeof fromName === "string") {
      name = fromName;
    }
    if (name === void 0) {
      throw new Error("Could not extract file name from the provided input.");
    }
    if (name.startsWith("https://")) {
      const suffix = name.split("files/")[1];
      const match = suffix.match(/[a-z0-9]+/);
      if (match === null) {
        throw new Error(`Could not extract file name from URI ${name}`);
      }
      name = match[0];
    } else if (name.startsWith("files/")) {
      name = name.split("files/")[1];
    }
    return name;
  }
  function tModelsUrl(apiClient, baseModels) {
    let res;
    if (apiClient.isVertexAI()) {
      res = baseModels ? "publishers/google/models" : "models";
    } else {
      res = baseModels ? "models" : "tunedModels";
    }
    return res;
  }
  function tExtractModels(response) {
    for (const key of ["models", "tunedModels", "publisherModels"]) {
      if (hasField(response, key)) {
        return response[key];
      }
    }
    return [];
  }
  function hasField(data, fieldName) {
    return data !== null && typeof data === "object" && fieldName in data;
  }
  function mcpToGeminiTool(mcpTool, config = {}) {
    const mcpToolSchema = mcpTool;
    const functionDeclaration = {
      name: mcpToolSchema["name"],
      description: mcpToolSchema["description"],
      parametersJsonSchema: mcpToolSchema["inputSchema"]
    };
    if (mcpToolSchema["outputSchema"]) {
      functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
    }
    if (config.behavior) {
      functionDeclaration["behavior"] = config.behavior;
    }
    const geminiTool = {
      functionDeclarations: [
        functionDeclaration
      ]
    };
    return geminiTool;
  }
  function mcpToolsToGeminiTool(mcpTools, config = {}) {
    const functionDeclarations = [];
    const toolNames = /* @__PURE__ */ new Set();
    for (const mcpTool of mcpTools) {
      const mcpToolName = mcpTool.name;
      if (toolNames.has(mcpToolName)) {
        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
      }
      toolNames.add(mcpToolName);
      const geminiTool = mcpToGeminiTool(mcpTool, config);
      if (geminiTool.functionDeclarations) {
        functionDeclarations.push(...geminiTool.functionDeclarations);
      }
    }
    return { functionDeclarations };
  }
  function tBatchJobSource(client, src) {
    let sourceObj;
    if (typeof src === "string") {
      if (client.isVertexAI()) {
        if (src.startsWith("gs://")) {
          sourceObj = { format: "jsonl", gcsUri: [src] };
        } else if (src.startsWith("bq://")) {
          sourceObj = { format: "bigquery", bigqueryUri: src };
        } else {
          throw new Error(`Unsupported string source for Vertex AI: ${src}`);
        }
      } else {
        if (src.startsWith("files/")) {
          sourceObj = { fileName: src };
        } else {
          throw new Error(`Unsupported string source for Gemini API: ${src}`);
        }
      }
    } else if (Array.isArray(src)) {
      if (client.isVertexAI()) {
        throw new Error("InlinedRequest[] is not supported in Vertex AI.");
      }
      sourceObj = { inlinedRequests: src };
    } else {
      sourceObj = src;
    }
    const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
    const mldevSourcesCount = [
      sourceObj.inlinedRequests,
      sourceObj.fileName
    ].filter(Boolean).length;
    if (client.isVertexAI()) {
      if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {
        throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
      }
    } else {
      if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {
        throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
      }
    }
    return sourceObj;
  }
  function tBatchJobDestination(dest) {
    if (typeof dest !== "string") {
      return dest;
    }
    const destString = dest;
    if (destString.startsWith("gs://")) {
      return {
        format: "jsonl",
        gcsUri: destString
      };
    } else if (destString.startsWith("bq://")) {
      return {
        format: "bigquery",
        bigqueryUri: destString
      };
    } else {
      throw new Error(`Unsupported destination: ${destString}`);
    }
  }
  function tRecvBatchJobDestination(dest) {
    if (typeof dest !== "object" || dest === null) {
      return {};
    }
    const obj = dest;
    const inlineResponsesVal = obj["inlinedResponses"];
    if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) {
      return dest;
    }
    const inlineResponsesObj = inlineResponsesVal;
    const responsesArray = inlineResponsesObj["inlinedResponses"];
    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {
      return dest;
    }
    let hasEmbedding = false;
    for (const responseItem of responsesArray) {
      if (typeof responseItem !== "object" || responseItem === null) {
        continue;
      }
      const responseItemObj = responseItem;
      const responseVal = responseItemObj["response"];
      if (typeof responseVal !== "object" || responseVal === null) {
        continue;
      }
      const responseObj = responseVal;
      if (responseObj["embedding"] !== void 0) {
        hasEmbedding = true;
        break;
      }
    }
    if (hasEmbedding) {
      obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
      delete obj["inlinedResponses"];
    }
    return dest;
  }
  function tBatchJobName(apiClient, name) {
    const nameString = name;
    if (!apiClient.isVertexAI()) {
      const mldevPattern = /batches\/[^/]+$/;
      if (mldevPattern.test(nameString)) {
        return nameString.split("/").pop();
      } else {
        throw new Error(`Invalid batch job name: ${nameString}.`);
      }
    }
    const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
    if (vertexPattern.test(nameString)) {
      return nameString.split("/").pop();
    } else if (/^\d+$/.test(nameString)) {
      return nameString;
    } else {
      throw new Error(`Invalid batch job name: ${nameString}.`);
    }
  }
  function tJobState(state) {
    const stateString = state;
    if (stateString === "BATCH_STATE_UNSPECIFIED") {
      return "JOB_STATE_UNSPECIFIED";
    } else if (stateString === "BATCH_STATE_PENDING") {
      return "JOB_STATE_PENDING";
    } else if (stateString === "BATCH_STATE_RUNNING") {
      return "JOB_STATE_RUNNING";
    } else if (stateString === "BATCH_STATE_SUCCEEDED") {
      return "JOB_STATE_SUCCEEDED";
    } else if (stateString === "BATCH_STATE_FAILED") {
      return "JOB_STATE_FAILED";
    } else if (stateString === "BATCH_STATE_CANCELLED") {
      return "JOB_STATE_CANCELLED";
    } else if (stateString === "BATCH_STATE_EXPIRED") {
      return "JOB_STATE_EXPIRED";
    } else {
      return stateString;
    }
  }
  function batchJobDestinationFromMldev(fromObject) {
    const toObject = {};
    const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromInlinedResponses = getValueByPath(fromObject, [
      "inlinedResponses",
      "inlinedResponses"
    ]);
    if (fromInlinedResponses != null) {
      let transformedList = fromInlinedResponses;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return inlinedResponseFromMldev(item);
        });
      }
      setValueByPath(toObject, ["inlinedResponses"], transformedList);
    }
    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [
      "inlinedEmbedContentResponses",
      "inlinedResponses"
    ]);
    if (fromInlinedEmbedContentResponses != null) {
      let transformedList = fromInlinedEmbedContentResponses;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
    }
    return toObject;
  }
  function batchJobDestinationFromVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, [
      "gcsDestination",
      "outputUriPrefix"
    ]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, [
      "bigqueryDestination",
      "outputUri"
    ]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
    }
    return toObject;
  }
  function batchJobDestinationToVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["predictionsFormat"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
    }
    if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
      throw new Error("fileName parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
      throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) {
      throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function batchJobFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, [
      "metadata",
      "displayName"
    ]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromState = getValueByPath(fromObject, ["metadata", "state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tJobState(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, [
      "metadata",
      "createTime"
    ]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromEndTime = getValueByPath(fromObject, [
      "metadata",
      "endTime"
    ]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, [
      "metadata",
      "updateTime"
    ]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
    if (fromDest != null) {
      setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
    }
    return toObject;
  }
  function batchJobFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tJobState(fromState));
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
    }
    const fromDest = getValueByPath(fromObject, ["outputConfig"]);
    if (fromDest != null) {
      setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
    }
    const fromCompletionStats = getValueByPath(fromObject, [
      "completionStats"
    ]);
    if (fromCompletionStats != null) {
      setValueByPath(toObject, ["completionStats"], fromCompletionStats);
    }
    return toObject;
  }
  function batchJobSourceFromVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, [
      "bigquerySource",
      "inputUri"
    ]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
    }
    return toObject;
  }
  function batchJobSourceToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["format"]) !== void 0) {
      throw new Error("format parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
      throw new Error("bigqueryUri parameter is not supported in Gemini API.");
    }
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromInlinedRequests = getValueByPath(fromObject, [
      "inlinedRequests"
    ]);
    if (fromInlinedRequests != null) {
      let transformedList = fromInlinedRequests;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return inlinedRequestToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["requests", "requests"], transformedList);
    }
    return toObject;
  }
  function batchJobSourceToVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["instancesFormat"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
    }
    if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
      throw new Error("fileName parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
      throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function blobToMldev$4(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function cancelBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function cancelBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function candidateFromMldev$1(fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], fromContent);
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      let transformedList = fromSafetyRatings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["safetyRatings"], transformedList);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
    }
    return toObject;
  }
  function citationMetadataFromMldev$1(fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citationSources"]);
    if (fromCitations != null) {
      let transformedList = fromCitations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["citations"], transformedList);
    }
    return toObject;
  }
  function contentToMldev$4(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$4(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createBatchJobConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
    }
    if (getValueByPath(fromObject, ["dest"]) !== void 0) {
      throw new Error("dest parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createBatchJobConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDest = getValueByPath(fromObject, ["dest"]);
    if (parentObject !== void 0 && fromDest != null) {
      setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
    }
    return toObject;
  }
  function createBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createBatchJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createBatchJobConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
    }
    return toObject;
  }
  function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteResourceJobFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function deleteResourceJobFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function embedContentBatchToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContentsForEmbed(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["requests[]", "request", "content"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["_self"], embedContentConfigToMldev$1(fromConfig, toObject));
      moveValueByPath(toObject, { "requests[].*": "requests[].request.*" });
    }
    return toObject;
  }
  function embedContentConfigToMldev$1(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
    }
    if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
      throw new Error("mimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
      throw new Error("autoTruncate parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["file_name"], fromFileName);
    }
    const fromInlinedRequests = getValueByPath(fromObject, [
      "inlinedRequests"
    ]);
    if (fromInlinedRequests != null) {
      setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
    }
    return toObject;
  }
  function fileDataToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$4(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionCallingConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
      throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
      throw new Error("routingConfig parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
      throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToMldev$1(item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$4(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
    }
    if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
      throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
    if (fromImageConfig != null) {
      setValueByPath(toObject, ["imageConfig"], imageConfigToMldev$1(fromImageConfig));
    }
    return toObject;
  }
  function generateContentResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function getBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function getBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function googleMapsToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function imageConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (fromAspectRatio != null) {
      setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (fromImageSize != null) {
      setValueByPath(toObject, ["imageSize"], fromImageSize);
    }
    if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
      throw new Error("outputMimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
      throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function inlinedRequestToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$4(item);
        });
      }
      setValueByPath(toObject, ["request", "contents"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ["request"], {})));
    }
    return toObject;
  }
  function inlinedResponseFromMldev(fromObject) {
    const toObject = {};
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function listBatchJobsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    if (getValueByPath(fromObject, ["filter"]) !== void 0) {
      throw new Error("filter parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function listBatchJobsConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listBatchJobsParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listBatchJobsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listBatchJobsParametersToVertex(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listBatchJobsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listBatchJobsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
    if (fromBatchJobs != null) {
      let transformedList = fromBatchJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return batchJobFromMldev(item);
        });
      }
      setValueByPath(toObject, ["batchJobs"], transformedList);
    }
    return toObject;
  }
  function listBatchJobsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromBatchJobs = getValueByPath(fromObject, [
      "batchPredictionJobs"
    ]);
    if (fromBatchJobs != null) {
      let transformedList = fromBatchJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return batchJobFromVertex(item);
        });
      }
      setValueByPath(toObject, ["batchJobs"], transformedList);
    }
    return toObject;
  }
  function partToMldev$4(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function safetySettingToMldev$1(fromObject) {
    const toObject = {};
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    if (getValueByPath(fromObject, ["method"]) !== void 0) {
      throw new Error("method parameter is not supported in Gemini API.");
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function toolConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
    }
    return toObject;
  }
  function toolToMldev$4(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$4(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  var PagedItem;
  (function(PagedItem2) {
    PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
    PagedItem2["PAGED_ITEM_MODELS"] = "models";
    PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
    PagedItem2["PAGED_ITEM_FILES"] = "files";
    PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
    PagedItem2["PAGED_ITEM_FILE_SEARCH_STORES"] = "fileSearchStores";
    PagedItem2["PAGED_ITEM_DOCUMENTS"] = "documents";
  })(PagedItem || (PagedItem = {}));
  var Pager = class {
    constructor(name, request, response, params) {
      this.pageInternal = [];
      this.paramsInternal = {};
      this.requestInternal = request;
      this.init(name, response, params);
    }
    init(name, response, params) {
      var _a, _b;
      this.nameInternal = name;
      this.pageInternal = response[this.nameInternal] || [];
      this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
      this.idxInternal = 0;
      let requestParams = { config: {} };
      if (!params || Object.keys(params).length === 0) {
        requestParams = { config: {} };
      } else if (typeof params === "object") {
        requestParams = Object.assign({}, params);
      } else {
        requestParams = params;
      }
      if (requestParams["config"]) {
        requestParams["config"]["pageToken"] = response["nextPageToken"];
      }
      this.paramsInternal = requestParams;
      this.pageInternalSize = (_b = (_a = requestParams["config"]) === null || _a === void 0 ? void 0 : _a["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
    }
    initNextPage(response) {
      this.init(this.nameInternal, response, this.paramsInternal);
    }
    /**
     * Returns the current page, which is a list of items.
     *
     * @remarks
     * The first page is retrieved when the pager is created. The returned list of
     * items could be a subset of the entire list.
     */
    get page() {
      return this.pageInternal;
    }
    /**
     * Returns the type of paged item (for example, ``batch_jobs``).
     */
    get name() {
      return this.nameInternal;
    }
    /**
     * Returns the length of the page fetched each time by this pager.
     *
     * @remarks
     * The number of items in the page is less than or equal to the page length.
     */
    get pageSize() {
      return this.pageInternalSize;
    }
    /**
     * Returns the headers of the API response.
     */
    get sdkHttpResponse() {
      return this.sdkHttpResponseInternal;
    }
    /**
     * Returns the parameters when making the API request for the next page.
     *
     * @remarks
     * Parameters contain a set of optional configs that can be
     * used to customize the API request. For example, the `pageToken` parameter
     * contains the token to request the next page.
     */
    get params() {
      return this.paramsInternal;
    }
    /**
     * Returns the total number of items in the current page.
     */
    get pageLength() {
      return this.pageInternal.length;
    }
    /**
     * Returns the item at the given index.
     */
    getItem(index) {
      return this.pageInternal[index];
    }
    /**
     * Returns an async iterator that support iterating through all items
     * retrieved from the API.
     *
     * @remarks
     * The iterator will automatically fetch the next page if there are more items
     * to fetch from the API.
     *
     * @example
     *
     * ```ts
     * const pager = await ai.files.list({config: {pageSize: 10}});
     * for await (const file of pager) {
     *   console.log(file.name);
     * }
     * ```
     */
    [Symbol.asyncIterator]() {
      return {
        next: async () => {
          if (this.idxInternal >= this.pageLength) {
            if (this.hasNextPage()) {
              await this.nextPage();
            } else {
              return { value: void 0, done: true };
            }
          }
          const item = this.getItem(this.idxInternal);
          this.idxInternal += 1;
          return { value: item, done: false };
        },
        return: async () => {
          return { value: void 0, done: true };
        }
      };
    }
    /**
     * Fetches the next page of items. This makes a new API request.
     *
     * @throws {Error} If there are no more pages to fetch.
     *
     * @example
     *
     * ```ts
     * const pager = await ai.files.list({config: {pageSize: 10}});
     * let page = pager.page;
     * while (true) {
     *   for (const file of page) {
     *     console.log(file.name);
     *   }
     *   if (!pager.hasNextPage()) {
     *     break;
     *   }
     *   page = await pager.nextPage();
     * }
     * ```
     */
    async nextPage() {
      if (!this.hasNextPage()) {
        throw new Error("No more pages to fetch.");
      }
      const response = await this.requestInternal(this.params);
      this.initNextPage(response);
      return this.page;
    }
    /**
     * Returns true if there are more pages to fetch from the API.
     */
    hasNextPage() {
      var _a;
      if (((_a = this.params["config"]) === null || _a === void 0 ? void 0 : _a["pageToken"]) !== void 0) {
        return true;
      }
      return false;
    }
  };
  var Batches = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.create = async (params) => {
        if (this.apiClient.isVertexAI()) {
          params.config = this.formatDestination(params.src, params.config);
        }
        return this.createInternal(params);
      };
      this.createEmbeddings = async (params) => {
        console.warn("batches.createEmbeddings() is experimental and may change without notice.");
        if (this.apiClient.isVertexAI()) {
          throw new Error("Vertex AI does not support batches.createEmbeddings.");
        }
        return this.createEmbeddingsInternal(params);
      };
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
      };
    }
    // Helper function to handle inlined generate content requests
    createInlinedGenerateContentRequest(params) {
      const body = createBatchJobParametersToMldev(
        this.apiClient,
        // Use instance apiClient
        params
      );
      const urlParams = body["_url"];
      const path = formatMap("{model}:batchGenerateContent", urlParams);
      const batch = body["batch"];
      const inputConfig = batch["inputConfig"];
      const requestsWrapper = inputConfig["requests"];
      const requests = requestsWrapper["requests"];
      const newRequests = [];
      for (const request of requests) {
        const requestDict = Object.assign({}, request);
        if (requestDict["systemInstruction"]) {
          const systemInstructionValue = requestDict["systemInstruction"];
          delete requestDict["systemInstruction"];
          const requestContent = requestDict["request"];
          requestContent["systemInstruction"] = systemInstructionValue;
          requestDict["request"] = requestContent;
        }
        newRequests.push(requestDict);
      }
      requestsWrapper["requests"] = newRequests;
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      return { path, body };
    }
    // Helper function to get the first GCS URI
    getGcsUri(src) {
      if (typeof src === "string") {
        return src.startsWith("gs://") ? src : void 0;
      }
      if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {
        return src.gcsUri[0];
      }
      return void 0;
    }
    // Helper function to get the BigQuery URI
    getBigqueryUri(src) {
      if (typeof src === "string") {
        return src.startsWith("bq://") ? src : void 0;
      }
      if (!Array.isArray(src)) {
        return src.bigqueryUri;
      }
      return void 0;
    }
    // Function to format the destination configuration for Vertex AI
    formatDestination(src, config) {
      const newConfig = config ? Object.assign({}, config) : {};
      const timestampStr = Date.now().toString();
      if (!newConfig.displayName) {
        newConfig.displayName = `genaiBatchJob_${timestampStr}`;
      }
      if (newConfig.dest === void 0) {
        const gcsUri = this.getGcsUri(src);
        const bigqueryUri = this.getBigqueryUri(src);
        if (gcsUri) {
          if (gcsUri.endsWith(".jsonl")) {
            newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
          } else {
            newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
          }
        } else if (bigqueryUri) {
          newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
        } else {
          throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
        }
      }
      return newConfig;
    }
    /**
     * Internal method to create batch job.
     *
     * @param params - The parameters for create batch job request.
     * @return The created batch job.
     *
     */
    async createInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = createBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = createBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:batchGenerateContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Internal method to create batch job.
     *
     * @param params - The parameters for create batch job request.
     * @return The created batch job.
     *
     */
    async createEmbeddingsInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Gets batch job configurations.
     *
     * @param params - The parameters for the get request.
     * @return The batch job.
     *
     * @example
     * ```ts
     * await ai.batches.get({name: '...'}); // The server-generated resource name.
     * ```
     */
    async get(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = getBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("batches/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Cancels a batch job.
     *
     * @param params - The parameters for the cancel request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
     * ```
     */
    async cancel(params) {
      var _a, _b, _c, _d;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = cancelBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
      } else {
        const body = cancelBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("batches/{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listBatchJobsParametersToVertex(params);
        path = formatMap("batchPredictionJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listBatchJobsResponseFromVertex(apiResponse);
          const typedResp = new ListBatchJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listBatchJobsParametersToMldev(params);
        path = formatMap("batches", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listBatchJobsResponseFromMldev(apiResponse);
          const typedResp = new ListBatchJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Deletes a batch job.
     *
     * @param params - The parameters for the delete request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.batches.delete({name: '...'}); // The server-generated resource name.
     * ```
     */
    async delete(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = deleteBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteResourceJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = deleteBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("batches/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteResourceJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
  };
  function blobToMldev$3(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentToMldev$3(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$3(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createCachedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$3(item);
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$3(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
      throw new Error("kmsKeyName parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createCachedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$2(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
    }
    const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
    if (parentObject !== void 0 && fromKmsKeyName != null) {
      setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
    }
    return toObject;
  }
  function createCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createCachedContentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createCachedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteCachedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteCachedContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function fileDataToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$3(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionCallingConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
      throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionDeclarationToVertex$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function getCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function getCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function googleMapsToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function listCachedContentsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listCachedContentsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listCachedContentsParametersToVertex(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listCachedContentsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listCachedContentsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function listCachedContentsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function partToMldev$3(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function toolConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
    }
    return toObject;
  }
  function toolToMldev$3(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$3(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function toolToVertex$2(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$2(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
      throw new Error("fileSearch parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function updateCachedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateCachedContentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function updateCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateCachedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  var Caches = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);
      };
    }
    /**
     * Creates a cached contents resource.
     *
     * @remarks
     * Context caching is only supported for specific models. See [Gemini
     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
     * for more information.
     *
     * @param params - The parameters for the create request.
     * @return The created cached content.
     *
     * @example
     * ```ts
     * const contents = ...; // Initialize the content to cache.
     * const response = await ai.caches.create({
     *   model: 'gemini-2.0-flash-001',
     *   config: {
     *    'contents': contents,
     *    'displayName': 'test cache',
     *    'systemInstruction': 'What is the sum of the two pdfs?',
     *    'ttl': '86400s',
     *  }
     * });
     * ```
     */
    async create(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = createCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      } else {
        const body = createCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
    /**
     * Gets cached content configurations.
     *
     * @param params - The parameters for the get request.
     * @return The cached content.
     *
     * @example
     * ```ts
     * await ai.caches.get({name: '...'}); // The server-generated resource name.
     * ```
     */
    async get(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      } else {
        const body = getCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
    /**
     * Deletes cached content.
     *
     * @param params - The parameters for the delete request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.caches.delete({name: '...'}); // The server-generated resource name.
     * ```
     */
    async delete(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = deleteCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteCachedContentResponseFromVertex(apiResponse);
          const typedResp = new DeleteCachedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = deleteCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteCachedContentResponseFromMldev(apiResponse);
          const typedResp = new DeleteCachedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Updates cached content configurations.
     *
     * @param params - The parameters for the update request.
     * @return The updated cached content.
     *
     * @example
     * ```ts
     * const response = await ai.caches.update({
     *   name: '...',  // The server-generated resource name.
     *   config: {'ttl': '7600s'}
     * });
     * ```
     */
    async update(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = updateCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      } else {
        const body = updateCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listCachedContentsParametersToVertex(params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listCachedContentsResponseFromVertex(apiResponse);
          const typedResp = new ListCachedContentsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listCachedContentsParametersToMldev(params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listCachedContentsResponseFromMldev(apiResponse);
          const typedResp = new ListCachedContentsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function isValidResponse(response) {
    var _a;
    if (response.candidates == void 0 || response.candidates.length === 0) {
      return false;
    }
    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
    if (content === void 0) {
      return false;
    }
    return isValidContent(content);
  }
  function isValidContent(content) {
    if (content.parts === void 0 || content.parts.length === 0) {
      return false;
    }
    for (const part of content.parts) {
      if (part === void 0 || Object.keys(part).length === 0) {
        return false;
      }
    }
    return true;
  }
  function validateHistory(history) {
    if (history.length === 0) {
      return;
    }
    for (const content of history) {
      if (content.role !== "user" && content.role !== "model") {
        throw new Error(`Role must be user or model, but got ${content.role}.`);
      }
    }
  }
  function extractCuratedHistory(comprehensiveHistory) {
    if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
      return [];
    }
    const curatedHistory = [];
    const length = comprehensiveHistory.length;
    let i = 0;
    while (i < length) {
      if (comprehensiveHistory[i].role === "user") {
        curatedHistory.push(comprehensiveHistory[i]);
        i++;
      } else {
        const modelOutput = [];
        let isValid = true;
        while (i < length && comprehensiveHistory[i].role === "model") {
          modelOutput.push(comprehensiveHistory[i]);
          if (isValid && !isValidContent(comprehensiveHistory[i])) {
            isValid = false;
          }
          i++;
        }
        if (isValid) {
          curatedHistory.push(...modelOutput);
        } else {
          curatedHistory.pop();
        }
      }
    }
    return curatedHistory;
  }
  var Chats = class {
    constructor(modelsModule, apiClient) {
      this.modelsModule = modelsModule;
      this.apiClient = apiClient;
    }
    /**
     * Creates a new chat session.
     *
     * @remarks
     * The config in the params will be used for all requests within the chat
     * session unless overridden by a per-request `config` in
     * @see {@link types.SendMessageParameters#config}.
     *
     * @param params - Parameters for creating a chat session.
     * @returns A new chat session.
     *
     * @example
     * ```ts
     * const chat = ai.chats.create({
     *   model: 'gemini-2.0-flash'
     *   config: {
     *     temperature: 0.5,
     *     maxOutputTokens: 1024,
     *   }
     * });
     * ```
     */
    create(params) {
      return new Chat(
        this.apiClient,
        this.modelsModule,
        params.model,
        params.config,
        // Deep copy the history to avoid mutating the history outside of the
        // chat session.
        structuredClone(params.history)
      );
    }
  };
  var Chat = class {
    constructor(apiClient, modelsModule, model, config = {}, history = []) {
      this.apiClient = apiClient;
      this.modelsModule = modelsModule;
      this.model = model;
      this.config = config;
      this.history = history;
      this.sendPromise = Promise.resolve();
      validateHistory(history);
    }
    /**
     * Sends a message to the model and returns the response.
     *
     * @remarks
     * This method will wait for the previous message to be processed before
     * sending the next message.
     *
     * @see {@link Chat#sendMessageStream} for streaming method.
     * @param params - parameters for sending messages within a chat session.
     * @returns The model's response.
     *
     * @example
     * ```ts
     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
     * const response = await chat.sendMessage({
     *   message: 'Why is the sky blue?'
     * });
     * console.log(response.text);
     * ```
     */
    async sendMessage(params) {
      var _a;
      await this.sendPromise;
      const inputContent = tContent(params.message);
      const responsePromise = this.modelsModule.generateContent({
        model: this.model,
        contents: this.getHistory(true).concat(inputContent),
        config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
      });
      this.sendPromise = (async () => {
        var _a2, _b, _c;
        const response = await responsePromise;
        const outputContent = (_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content;
        const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
        const index = this.getHistory(true).length;
        let automaticFunctionCallingHistory = [];
        if (fullAutomaticFunctionCallingHistory != null) {
          automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
        }
        const modelOutput = outputContent ? [outputContent] : [];
        this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
        return;
      })();
      await this.sendPromise.catch(() => {
        this.sendPromise = Promise.resolve();
      });
      return responsePromise;
    }
    /**
     * Sends a message to the model and returns the response in chunks.
     *
     * @remarks
     * This method will wait for the previous message to be processed before
     * sending the next message.
     *
     * @see {@link Chat#sendMessage} for non-streaming method.
     * @param params - parameters for sending the message.
     * @return The model's response.
     *
     * @example
     * ```ts
     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
     * const response = await chat.sendMessageStream({
     *   message: 'Why is the sky blue?'
     * });
     * for await (const chunk of response) {
     *   console.log(chunk.text);
     * }
     * ```
     */
    async sendMessageStream(params) {
      var _a;
      await this.sendPromise;
      const inputContent = tContent(params.message);
      const streamResponse = this.modelsModule.generateContentStream({
        model: this.model,
        contents: this.getHistory(true).concat(inputContent),
        config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
      });
      this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
      const response = await streamResponse;
      const result = this.processStreamResponse(response, inputContent);
      return result;
    }
    /**
     * Returns the chat history.
     *
     * @remarks
     * The history is a list of contents alternating between user and model.
     *
     * There are two types of history:
     * - The `curated history` contains only the valid turns between user and
     * model, which will be included in the subsequent requests sent to the model.
     * - The `comprehensive history` contains all turns, including invalid or
     *   empty model outputs, providing a complete record of the history.
     *
     * The history is updated after receiving the response from the model,
     * for streaming response, it means receiving the last chunk of the response.
     *
     * The `comprehensive history` is returned by default. To get the `curated
     * history`, set the `curated` parameter to `true`.
     *
     * @param curated - whether to return the curated history or the comprehensive
     *     history.
     * @return History contents alternating between user and model for the entire
     *     chat session.
     */
    getHistory(curated = false) {
      const history = curated ? extractCuratedHistory(this.history) : this.history;
      return structuredClone(history);
    }
    processStreamResponse(streamResponse, inputContent) {
      var _a, _b;
      return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
        var _c, e_1, _d, _e;
        const outputContent = [];
        try {
          for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
            _e = streamResponse_1_1.value;
            _f = false;
            const chunk = _e;
            if (isValidResponse(chunk)) {
              const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;
              if (content !== void 0) {
                outputContent.push(content);
              }
            }
            yield yield __await(chunk);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        this.recordHistory(inputContent, outputContent);
      });
    }
    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
      let outputContents = [];
      if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
        outputContents = modelOutput;
      } else {
        outputContents.push({
          role: "model",
          parts: []
        });
      }
      if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
        this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
      } else {
        this.history.push(userInput);
      }
      this.history.push(...outputContents);
    }
  };
  var ApiError = class _ApiError extends Error {
    constructor(options) {
      super(options.message);
      this.name = "ApiError";
      this.status = options.status;
      Object.setPrototypeOf(this, _ApiError.prototype);
    }
  };
  function createFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromFile = getValueByPath(fromObject, ["file"]);
    if (fromFile != null) {
      setValueByPath(toObject, ["file"], fromFile);
    }
    return toObject;
  }
  function createFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
    }
    return toObject;
  }
  function deleteFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function getFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
    }
    return toObject;
  }
  function listFilesConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listFilesParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listFilesConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listFilesResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromFiles = getValueByPath(fromObject, ["files"]);
    if (fromFiles != null) {
      let transformedList = fromFiles;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["files"], transformedList);
    }
    return toObject;
  }
  var Files = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);
      };
    }
    /**
     * Uploads a file asynchronously to the Gemini API.
     * This method is not available in Vertex AI.
     * Supported upload sources:
     * - Node.js: File path (string) or Blob object.
     * - Browser: Blob object (e.g., File).
     *
     * @remarks
     * The `mimeType` can be specified in the `config` parameter. If omitted:
     *  - For file path (string) inputs, the `mimeType` will be inferred from the
     *     file extension.
     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
     *     property.
     * Somex eamples for file extension to mimeType mapping:
     * .txt -> text/plain
     * .json -> application/json
     * .jpg  -> image/jpeg
     * .png -> image/png
     * .mp3 -> audio/mpeg
     * .mp4 -> video/mp4
     *
     * This section can contain multiple paragraphs and code examples.
     *
     * @param params - Optional parameters specified in the
     *        `types.UploadFileParameters` interface.
     *         @see {@link types.UploadFileParameters#config} for the optional
     *         config in the parameters.
     * @return A promise that resolves to a `types.File` object.
     * @throws An error if called on a Vertex AI client.
     * @throws An error if the `mimeType` is not provided and can not be inferred,
     * the `mimeType` can be provided in the `params.config` parameter.
     * @throws An error occurs if a suitable upload location cannot be established.
     *
     * @example
     * The following code uploads a file to Gemini API.
     *
     * ```ts
     * const file = await ai.files.upload({file: 'file.txt', config: {
     *   mimeType: 'text/plain',
     * }});
     * console.log(file.name);
     * ```
     */
    async upload(params) {
      if (this.apiClient.isVertexAI()) {
        throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
      }
      return this.apiClient.uploadFile(params.file, params.config).then((resp) => {
        return resp;
      });
    }
    /**
     * Downloads a remotely stored file asynchronously to a location specified in
     * the `params` object. This method only works on Node environment, to
     * download files in the browser, use a browser compliant method like an <a>
     * tag.
     *
     * @param params - The parameters for the download request.
     *
     * @example
     * The following code downloads an example file named "files/mehozpxf877d" as
     * "file.txt".
     *
     * ```ts
     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
     * ```
     */
    async download(params) {
      await this.apiClient.downloadFile(params);
    }
    async listInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = listFilesParametersToMldev(params);
        path = formatMap("files", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listFilesResponseFromMldev(apiResponse);
          const typedResp = new ListFilesResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    async createInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = createFileParametersToMldev(params);
        path = formatMap("upload/v1beta/files", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = createFileResponseFromMldev(apiResponse);
          const typedResp = new CreateFileResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Retrieves the file information from the service.
     *
     * @param params - The parameters for the get request
     * @return The Promise that resolves to the types.File object requested.
     *
     * @example
     * ```ts
     * const config: GetFileParameters = {
     *   name: fileName,
     * };
     * file = await ai.files.get(config);
     * console.log(file.name);
     * ```
     */
    async get(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = getFileParametersToMldev(params);
        path = formatMap("files/{file}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
    /**
     * Deletes a remotely stored file.
     *
     * @param params - The parameters for the delete request.
     * @return The DeleteFileResponse, the response for the delete method.
     *
     * @example
     * The following code deletes an example file named "files/mehozpxf877d".
     *
     * ```ts
     * await ai.files.delete({name: file.name});
     * ```
     */
    async delete(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = deleteFileParametersToMldev(params);
        path = formatMap("files/{file}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteFileResponseFromMldev(apiResponse);
          const typedResp = new DeleteFileResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  function blobToMldev$2(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentToMldev$2(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$2(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function fileDataToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$2(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionDeclarationToVertex$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function generationConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (fromEnableAffectiveDialog != null) {
      setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex$1(fromSpeechConfig));
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
      throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function googleMapsToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function liveConnectConfigToMldev$1(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (parentObject !== void 0 && fromThinkingConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$2(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
    }
    return toObject;
  }
  function liveConnectConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], generationConfigToVertex$1(fromGenerationConfig));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (parentObject !== void 0 && fromThinkingConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$1(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], fromSessionResumption);
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
    }
    return toObject;
  }
  function liveConnectParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
    }
    return toObject;
  }
  function liveConnectParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
    }
    return toObject;
  }
  function liveMusicSetConfigParametersToMldev(fromObject) {
    const toObject = {};
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], fromMusicGenerationConfig);
    }
    return toObject;
  }
  function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveSendRealtimeInputParametersToMldev(fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      let transformedList = tBlobs(fromMedia);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return blobToMldev$2(item);
        });
      }
      setValueByPath(toObject, ["mediaChunks"], transformedList);
    }
    const fromAudio = getValueByPath(fromObject, ["audio"]);
    if (fromAudio != null) {
      setValueByPath(toObject, ["audio"], blobToMldev$2(tAudioBlob(fromAudio)));
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], blobToMldev$2(tImageBlob(fromVideo)));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], fromActivityStart);
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
    }
    return toObject;
  }
  function liveSendRealtimeInputParametersToVertex(fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      let transformedList = tBlobs(fromMedia);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["mediaChunks"], transformedList);
    }
    const fromAudio = getValueByPath(fromObject, ["audio"]);
    if (fromAudio != null) {
      setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], fromActivityStart);
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
    }
    return toObject;
  }
  function liveServerMessageFromVertex(fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], fromSetupComplete);
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], fromServerContent);
    }
    const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
    if (fromToolCall != null) {
      setValueByPath(toObject, ["toolCall"], fromToolCall);
    }
    const fromToolCallCancellation = getValueByPath(fromObject, [
      "toolCallCancellation"
    ]);
    if (fromToolCallCancellation != null) {
      setValueByPath(toObject, ["toolCallCancellation"], fromToolCallCancellation);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
    }
    const fromGoAway = getValueByPath(fromObject, ["goAway"]);
    if (fromGoAway != null) {
      setValueByPath(toObject, ["goAway"], fromGoAway);
    }
    const fromSessionResumptionUpdate = getValueByPath(fromObject, [
      "sessionResumptionUpdate"
    ]);
    if (fromSessionResumptionUpdate != null) {
      setValueByPath(toObject, ["sessionResumptionUpdate"], fromSessionResumptionUpdate);
    }
    return toObject;
  }
  function partToMldev$2(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function sessionResumptionConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
      throw new Error("transparent parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function speechConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function toolToMldev$2(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$2(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function toolToVertex$1(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$1(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
      throw new Error("fileSearch parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function usageMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromPromptTokenCount = getValueByPath(fromObject, [
      "promptTokenCount"
    ]);
    if (fromPromptTokenCount != null) {
      setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    const fromResponseTokenCount = getValueByPath(fromObject, [
      "candidatesTokenCount"
    ]);
    if (fromResponseTokenCount != null) {
      setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
    }
    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
      "toolUsePromptTokenCount"
    ]);
    if (fromToolUsePromptTokenCount != null) {
      setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
    }
    const fromThoughtsTokenCount = getValueByPath(fromObject, [
      "thoughtsTokenCount"
    ]);
    if (fromThoughtsTokenCount != null) {
      setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
    }
    const fromTotalTokenCount = getValueByPath(fromObject, [
      "totalTokenCount"
    ]);
    if (fromTotalTokenCount != null) {
      setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
    }
    const fromPromptTokensDetails = getValueByPath(fromObject, [
      "promptTokensDetails"
    ]);
    if (fromPromptTokensDetails != null) {
      let transformedList = fromPromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["promptTokensDetails"], transformedList);
    }
    const fromCacheTokensDetails = getValueByPath(fromObject, [
      "cacheTokensDetails"
    ]);
    if (fromCacheTokensDetails != null) {
      let transformedList = fromCacheTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
    }
    const fromResponseTokensDetails = getValueByPath(fromObject, [
      "candidatesTokensDetails"
    ]);
    if (fromResponseTokensDetails != null) {
      let transformedList = fromResponseTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["responseTokensDetails"], transformedList);
    }
    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
      "toolUsePromptTokensDetails"
    ]);
    if (fromToolUsePromptTokensDetails != null) {
      let transformedList = fromToolUsePromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
    }
    const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
    if (fromTrafficType != null) {
      setValueByPath(toObject, ["trafficType"], fromTrafficType);
    }
    return toObject;
  }
  function blobToMldev$1(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function candidateFromMldev(fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], fromContent);
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      let transformedList = fromSafetyRatings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["safetyRatings"], transformedList);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
    }
    return toObject;
  }
  function citationMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citationSources"]);
    if (fromCitations != null) {
      let transformedList = fromCitations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["citations"], transformedList);
    }
    return toObject;
  }
  function computeTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    return toObject;
  }
  function computeTokensResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
    if (fromTokensInfo != null) {
      let transformedList = fromTokensInfo;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["tokensInfo"], transformedList);
    }
    return toObject;
  }
  function contentEmbeddingFromVertex(fromObject) {
    const toObject = {};
    const fromValues = getValueByPath(fromObject, ["values"]);
    if (fromValues != null) {
      setValueByPath(toObject, ["values"], fromValues);
    }
    const fromStatistics = getValueByPath(fromObject, ["statistics"]);
    if (fromStatistics != null) {
      setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
    }
    return toObject;
  }
  function contentEmbeddingStatisticsFromVertex(fromObject) {
    const toObject = {};
    const fromTruncated = getValueByPath(fromObject, ["truncated"]);
    if (fromTruncated != null) {
      setValueByPath(toObject, ["truncated"], fromTruncated);
    }
    const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function contentToMldev$1(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function controlReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromControlType = getValueByPath(fromObject, ["controlType"]);
    if (fromControlType != null) {
      setValueByPath(toObject, ["controlType"], fromControlType);
    }
    const fromEnableControlImageComputation = getValueByPath(fromObject, [
      "enableControlImageComputation"
    ]);
    if (fromEnableControlImageComputation != null) {
      setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
    }
    return toObject;
  }
  function countTokensConfigToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
      throw new Error("systemInstruction parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["tools"]) !== void 0) {
      throw new Error("tools parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
      throw new Error("generationConfig parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function countTokensConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["generationConfig"], generationConfigToVertex(fromGenerationConfig));
    }
    return toObject;
  }
  function countTokensParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      countTokensConfigToMldev(fromConfig);
    }
    return toObject;
  }
  function countTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      countTokensConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function countTokensResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    return toObject;
  }
  function countTokensResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    return toObject;
  }
  function deleteModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function deleteModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function deleteModelResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteModelResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function editImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromEditMode = getValueByPath(fromObject, ["editMode"]);
    if (parentObject !== void 0 && fromEditMode != null) {
      setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
    }
    const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
    if (parentObject !== void 0 && fromBaseSteps != null) {
      setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
    }
    return toObject;
  }
  function editImageParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return referenceImageAPIInternalToVertex(item);
        });
      }
      setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      editImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function editImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function embedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
    }
    if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
      throw new Error("mimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
      throw new Error("autoTruncate parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function embedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (parentObject !== void 0 && fromMimeType != null) {
      setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
    }
    const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
    if (parentObject !== void 0 && fromAutoTruncate != null) {
      setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
    }
    return toObject;
  }
  function embedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContentsForEmbed(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["requests[]", "content"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      embedContentConfigToMldev(fromConfig, toObject);
    }
    const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
    if (fromModelForEmbedContent !== void 0) {
      setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
    }
    return toObject;
  }
  function embedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContentsForEmbed(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["instances[]", "content"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      embedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function embedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    return toObject;
  }
  function embedContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromEmbeddings = getValueByPath(fromObject, [
      "predictions[]",
      "embeddings"
    ]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentEmbeddingFromVertex(item);
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    return toObject;
  }
  function endpointFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["endpoint"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDeployedModelId = getValueByPath(fromObject, [
      "deployedModelId"
    ]);
    if (fromDeployedModelId != null) {
      setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
    }
    return toObject;
  }
  function fileDataToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$1(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionCallingConfigToMldev(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
      throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionDeclarationToVertex(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
      throw new Error("routingConfig parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
      throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToMldev(item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$1(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
    }
    if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
      throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
    if (fromImageConfig != null) {
      setValueByPath(toObject, ["imageConfig"], imageConfigToMldev(fromImageConfig));
    }
    return toObject;
  }
  function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
    if (fromImageConfig != null) {
      setValueByPath(toObject, ["imageConfig"], imageConfigToVertex(fromImageConfig));
    }
    return toObject;
  }
  function generateContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function generateContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function generateContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromMldev(item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function generateContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function generateImagesConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
      throw new Error("negativePrompt parameter is not supported in Gemini API.");
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
      throw new Error("addWatermark parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (parentObject !== void 0 && fromImageSize != null) {
      setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
    }
    if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
      throw new Error("enhancePrompt parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateImagesConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (parentObject !== void 0 && fromImageSize != null) {
      setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    return toObject;
  }
  function generateImagesParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateImagesConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function generateImagesParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateImagesConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function generateImagesResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromMldev(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function generateImagesResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function generateVideosConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["fps"]) !== void 0) {
      throw new Error("fps parameter is not supported in Gemini API.");
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromResolution = getValueByPath(fromObject, ["resolution"]);
    if (parentObject !== void 0 && fromResolution != null) {
      setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
      throw new Error("pubsubTopic parameter is not supported in Gemini API.");
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
      throw new Error("generateAudio parameter is not supported in Gemini API.");
    }
    const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
    if (parentObject !== void 0 && fromLastFrame != null) {
      setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToMldev(fromLastFrame));
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (parentObject !== void 0 && fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return videoGenerationReferenceImageToMldev(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
    }
    if (getValueByPath(fromObject, ["mask"]) !== void 0) {
      throw new Error("mask parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
      throw new Error("compressionQuality parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateVideosConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (parentObject !== void 0 && fromFps != null) {
      setValueByPath(parentObject, ["parameters", "fps"], fromFps);
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromResolution = getValueByPath(fromObject, ["resolution"]);
    if (parentObject !== void 0 && fromResolution != null) {
      setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
    if (parentObject !== void 0 && fromPubsubTopic != null) {
      setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    const fromGenerateAudio = getValueByPath(fromObject, [
      "generateAudio"
    ]);
    if (parentObject !== void 0 && fromGenerateAudio != null) {
      setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
    }
    const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
    if (parentObject !== void 0 && fromLastFrame != null) {
      setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (parentObject !== void 0 && fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return videoGenerationReferenceImageToVertex(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
    }
    const fromMask = getValueByPath(fromObject, ["mask"]);
    if (parentObject !== void 0 && fromMask != null) {
      setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
    }
    const fromCompressionQuality = getValueByPath(fromObject, [
      "compressionQuality"
    ]);
    if (parentObject !== void 0 && fromCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
    }
    return toObject;
  }
  function generateVideosOperationFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
    }
    return toObject;
  }
  function generateVideosParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["instances[0]", "video"], videoToMldev(fromVideo));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      generateVideosSourceToMldev(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateVideosConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function generateVideosParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      generateVideosSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateVideosConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function generateVideosResponseFromMldev(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosSourceToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (parentObject !== void 0 && fromVideo != null) {
      setValueByPath(parentObject, ["instances[0]", "video"], videoToMldev(fromVideo));
    }
    return toObject;
  }
  function generateVideosSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (parentObject !== void 0 && fromVideo != null) {
      setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
    }
    return toObject;
  }
  function generatedImageFromMldev(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
    }
    return toObject;
  }
  function generatedImageFromVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
    }
    const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromEnhancedPrompt != null) {
      setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
    }
    return toObject;
  }
  function generatedImageMaskFromVertex(fromObject) {
    const toObject = {};
    const fromMask = getValueByPath(fromObject, ["_self"]);
    if (fromMask != null) {
      setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      let transformedList = fromLabels;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["labels"], transformedList);
    }
    return toObject;
  }
  function generatedVideoFromMldev(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
    }
    return toObject;
  }
  function generatedVideoFromVertex(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
    }
    return toObject;
  }
  function generationConfigToVertex(fromObject) {
    const toObject = {};
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (fromEnableAffectiveDialog != null) {
      setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(fromSpeechConfig));
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
      throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function getModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function getModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function googleMapsToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function imageConfigToMldev(fromObject) {
    const toObject = {};
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (fromAspectRatio != null) {
      setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (fromImageSize != null) {
      setValueByPath(toObject, ["imageSize"], fromImageSize);
    }
    if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
      throw new Error("outputMimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
      throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function imageConfigToVertex(fromObject) {
    const toObject = {};
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (fromAspectRatio != null) {
      setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (fromImageSize != null) {
      setValueByPath(toObject, ["imageSize"], fromImageSize);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (fromOutputMimeType != null) {
      setValueByPath(toObject, ["imageOutputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (fromOutputCompressionQuality != null) {
      setValueByPath(toObject, ["imageOutputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    return toObject;
  }
  function imageFromMldev(fromObject) {
    const toObject = {};
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageFromVertex(fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageToVertex(fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listModelsConfigToMldev(apiClient, fromConfig, toObject);
    }
    return toObject;
  }
  function listModelsParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listModelsConfigToVertex(apiClient, fromConfig, toObject);
    }
    return toObject;
  }
  function listModelsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromMldev(item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function listModelsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromVertex(item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function maskReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
    if (fromMaskMode != null) {
      setValueByPath(toObject, ["maskMode"], fromMaskMode);
    }
    const fromSegmentationClasses = getValueByPath(fromObject, [
      "segmentationClasses"
    ]);
    if (fromSegmentationClasses != null) {
      setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
    }
    const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
    if (fromMaskDilation != null) {
      setValueByPath(toObject, ["dilation"], fromMaskDilation);
    }
    return toObject;
  }
  function modelFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["version"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
    }
    const fromInputTokenLimit = getValueByPath(fromObject, [
      "inputTokenLimit"
    ]);
    if (fromInputTokenLimit != null) {
      setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
    }
    const fromOutputTokenLimit = getValueByPath(fromObject, [
      "outputTokenLimit"
    ]);
    if (fromOutputTokenLimit != null) {
      setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
    }
    const fromSupportedActions = getValueByPath(fromObject, [
      "supportedGenerationMethods"
    ]);
    if (fromSupportedActions != null) {
      setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromMaxTemperature = getValueByPath(fromObject, [
      "maxTemperature"
    ]);
    if (fromMaxTemperature != null) {
      setValueByPath(toObject, ["maxTemperature"], fromMaxTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromThinking = getValueByPath(fromObject, ["thinking"]);
    if (fromThinking != null) {
      setValueByPath(toObject, ["thinking"], fromThinking);
    }
    return toObject;
  }
  function modelFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["versionId"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
    if (fromEndpoints != null) {
      let transformedList = fromEndpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return endpointFromVertex(item);
        });
      }
      setValueByPath(toObject, ["endpoints"], transformedList);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (fromDefaultCheckpointId != null) {
      setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
    if (fromCheckpoints != null) {
      let transformedList = fromCheckpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["checkpoints"], transformedList);
    }
    return toObject;
  }
  function partToMldev$1(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function productImageToVertex(fromObject) {
    const toObject = {};
    const fromProductImage = getValueByPath(fromObject, ["productImage"]);
    if (fromProductImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
    }
    return toObject;
  }
  function recontextImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
    if (parentObject !== void 0 && fromBaseSteps != null) {
      setValueByPath(parentObject, ["parameters", "baseSteps"], fromBaseSteps);
    }
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    return toObject;
  }
  function recontextImageParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      recontextImageSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      recontextImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function recontextImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function recontextImageSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
    if (parentObject !== void 0 && fromPersonImage != null) {
      setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
    }
    const fromProductImages = getValueByPath(fromObject, [
      "productImages"
    ]);
    if (parentObject !== void 0 && fromProductImages != null) {
      let transformedList = fromProductImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return productImageToVertex(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
    }
    return toObject;
  }
  function referenceImageAPIInternalToVertex(fromObject) {
    const toObject = {};
    const fromReferenceImage = getValueByPath(fromObject, [
      "referenceImage"
    ]);
    if (fromReferenceImage != null) {
      setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
    }
    const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
    if (fromReferenceId != null) {
      setValueByPath(toObject, ["referenceId"], fromReferenceId);
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    const fromMaskImageConfig = getValueByPath(fromObject, [
      "maskImageConfig"
    ]);
    if (fromMaskImageConfig != null) {
      setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
    }
    const fromControlImageConfig = getValueByPath(fromObject, [
      "controlImageConfig"
    ]);
    if (fromControlImageConfig != null) {
      setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
    }
    const fromStyleImageConfig = getValueByPath(fromObject, [
      "styleImageConfig"
    ]);
    if (fromStyleImageConfig != null) {
      setValueByPath(toObject, ["styleImageConfig"], fromStyleImageConfig);
    }
    const fromSubjectImageConfig = getValueByPath(fromObject, [
      "subjectImageConfig"
    ]);
    if (fromSubjectImageConfig != null) {
      setValueByPath(toObject, ["subjectImageConfig"], fromSubjectImageConfig);
    }
    return toObject;
  }
  function safetyAttributesFromMldev(fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function safetyAttributesFromVertex(fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function safetySettingToMldev(fromObject) {
    const toObject = {};
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    if (getValueByPath(fromObject, ["method"]) !== void 0) {
      throw new Error("method parameter is not supported in Gemini API.");
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function scribbleImageToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromImage));
    }
    return toObject;
  }
  function segmentImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (parentObject !== void 0 && fromMode != null) {
      setValueByPath(parentObject, ["parameters", "mode"], fromMode);
    }
    const fromMaxPredictions = getValueByPath(fromObject, [
      "maxPredictions"
    ]);
    if (parentObject !== void 0 && fromMaxPredictions != null) {
      setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
    }
    const fromConfidenceThreshold = getValueByPath(fromObject, [
      "confidenceThreshold"
    ]);
    if (parentObject !== void 0 && fromConfidenceThreshold != null) {
      setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
    }
    const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
    if (parentObject !== void 0 && fromMaskDilation != null) {
      setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
    }
    const fromBinaryColorThreshold = getValueByPath(fromObject, [
      "binaryColorThreshold"
    ]);
    if (parentObject !== void 0 && fromBinaryColorThreshold != null) {
      setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    return toObject;
  }
  function segmentImageParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      segmentImageSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      segmentImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function segmentImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
    if (fromGeneratedMasks != null) {
      let transformedList = fromGeneratedMasks;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageMaskFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedMasks"], transformedList);
    }
    return toObject;
  }
  function segmentImageSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromScribbleImage = getValueByPath(fromObject, [
      "scribbleImage"
    ]);
    if (parentObject !== void 0 && fromScribbleImage != null) {
      setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
    }
    return toObject;
  }
  function speechConfigToVertex(fromObject) {
    const toObject = {};
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function toolConfigToMldev(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
    }
    return toObject;
  }
  function toolToMldev$1(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$1(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function toolToVertex(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
      throw new Error("fileSearch parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function tunedModelInfoFromMldev(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function tunedModelInfoFromVertex(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, [
      "labels",
      "google-vertex-llm-tuning-base-model-id"
    ]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function updateModelConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateModelConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function updateModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateModelConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromEnhanceInputImage = getValueByPath(fromObject, [
      "enhanceInputImage"
    ]);
    if (parentObject !== void 0 && fromEnhanceInputImage != null) {
      setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
    }
    const fromImagePreservationFactor = getValueByPath(fromObject, [
      "imagePreservationFactor"
    ]);
    if (parentObject !== void 0 && fromImagePreservationFactor != null) {
      setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (parentObject !== void 0 && fromMode != null) {
      setValueByPath(parentObject, ["parameters", "mode"], fromMode);
    }
    return toObject;
  }
  function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromUpscaleFactor = getValueByPath(fromObject, [
      "upscaleFactor"
    ]);
    if (fromUpscaleFactor != null) {
      setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function upscaleImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function videoFromMldev(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoFromVertex(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoGenerationMaskToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
    }
    const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
    if (fromMaskMode != null) {
      setValueByPath(toObject, ["maskMode"], fromMaskMode);
    }
    return toObject;
  }
  function videoGenerationReferenceImageToMldev(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToMldev(fromImage));
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    return toObject;
  }
  function videoGenerationReferenceImageToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromImage));
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    return toObject;
  }
  function videoToMldev(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["encodedVideo"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["encoding"], fromMimeType);
    }
    return toObject;
  }
  function videoToVertex(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  var CONTENT_TYPE_HEADER = "Content-Type";
  var SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
  var USER_AGENT_HEADER = "User-Agent";
  var GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
  var SDK_VERSION = "1.30.0";
  var LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
  var VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
  var GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
  var responseLineRE = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
  var ApiClient = class {
    constructor(opts) {
      var _a, _b;
      this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
      const initHttpOptions = {};
      if (this.clientOptions.vertexai) {
        initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;
        initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
        this.normalizeAuthParameters();
      } else {
        initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
        initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
      }
      initHttpOptions.headers = this.getDefaultHeaders();
      this.clientOptions.httpOptions = initHttpOptions;
      if (opts.httpOptions) {
        this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
      }
    }
    /**
     * Determines the base URL for Vertex AI based on project and location.
     * Uses the global endpoint if location is 'global' or if project/location
     * are not specified (implying API key usage).
     * @private
     */
    baseUrlFromProjectLocation() {
      if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
        return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
      }
      return `https://aiplatform.googleapis.com/`;
    }
    /**
     * Normalizes authentication parameters for Vertex AI.
     * If project and location are provided, API key is cleared.
     * If project and location are not provided (implying API key usage),
     * project and location are cleared.
     * @private
     */
    normalizeAuthParameters() {
      if (this.clientOptions.project && this.clientOptions.location) {
        this.clientOptions.apiKey = void 0;
        return;
      }
      this.clientOptions.project = void 0;
      this.clientOptions.location = void 0;
    }
    isVertexAI() {
      var _a;
      return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;
    }
    getProject() {
      return this.clientOptions.project;
    }
    getLocation() {
      return this.clientOptions.location;
    }
    getApiVersion() {
      if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
        return this.clientOptions.httpOptions.apiVersion;
      }
      throw new Error("API version is not set.");
    }
    getBaseUrl() {
      if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
        return this.clientOptions.httpOptions.baseUrl;
      }
      throw new Error("Base URL is not set.");
    }
    getRequestUrl() {
      return this.getRequestUrlInternal(this.clientOptions.httpOptions);
    }
    getHeaders() {
      if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
        return this.clientOptions.httpOptions.headers;
      } else {
        throw new Error("Headers are not set.");
      }
    }
    getRequestUrlInternal(httpOptions) {
      if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
        throw new Error("HTTP options are not correctly set.");
      }
      const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
      const urlElement = [baseUrl];
      if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
        urlElement.push(httpOptions.apiVersion);
      }
      return urlElement.join("/");
    }
    getBaseResourcePath() {
      return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
    }
    getApiKey() {
      return this.clientOptions.apiKey;
    }
    getWebsocketBaseUrl() {
      const baseUrl = this.getBaseUrl();
      const urlParts = new URL(baseUrl);
      urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
      return urlParts.toString();
    }
    setBaseUrl(url) {
      if (this.clientOptions.httpOptions) {
        this.clientOptions.httpOptions.baseUrl = url;
      } else {
        throw new Error("HTTP options are not correctly set.");
      }
    }
    constructUrl(path, httpOptions, prependProjectLocation) {
      const urlElement = [this.getRequestUrlInternal(httpOptions)];
      if (prependProjectLocation) {
        urlElement.push(this.getBaseResourcePath());
      }
      if (path !== "") {
        urlElement.push(path);
      }
      const url = new URL(`${urlElement.join("/")}`);
      return url;
    }
    shouldPrependVertexProjectPath(request) {
      if (this.clientOptions.apiKey) {
        return false;
      }
      if (!this.clientOptions.vertexai) {
        return false;
      }
      if (request.path.startsWith("projects/")) {
        return false;
      }
      if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
        return false;
      }
      return true;
    }
    async request(request) {
      let patchedHttpOptions = this.clientOptions.httpOptions;
      if (request.httpOptions) {
        patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
      }
      const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
      const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
      if (request.queryParams) {
        for (const [key, value] of Object.entries(request.queryParams)) {
          url.searchParams.append(key, String(value));
        }
      }
      let requestInit = {};
      if (request.httpMethod === "GET") {
        if (request.body && request.body !== "{}") {
          throw new Error("Request body should be empty for GET request, but got non empty request body");
        }
      } else {
        requestInit.body = request.body;
      }
      requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
      return this.unaryApiCall(url, requestInit, request.httpMethod);
    }
    patchHttpOptions(baseHttpOptions, requestHttpOptions) {
      const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
      for (const [key, value] of Object.entries(requestHttpOptions)) {
        if (typeof value === "object") {
          patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
        } else if (value !== void 0) {
          patchedHttpOptions[key] = value;
        }
      }
      return patchedHttpOptions;
    }
    async requestStream(request) {
      let patchedHttpOptions = this.clientOptions.httpOptions;
      if (request.httpOptions) {
        patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
      }
      const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
      const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
      if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
        url.searchParams.set("alt", "sse");
      }
      let requestInit = {};
      requestInit.body = request.body;
      requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
      return this.streamApiCall(url, requestInit, request.httpMethod);
    }
    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {
      if (httpOptions && httpOptions.timeout || abortSignal) {
        const abortController = new AbortController();
        const signal = abortController.signal;
        if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
          const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
          if (timeoutHandle && typeof timeoutHandle.unref === "function") {
            timeoutHandle.unref();
          }
        }
        if (abortSignal) {
          abortSignal.addEventListener("abort", () => {
            abortController.abort();
          });
        }
        requestInit.signal = signal;
      }
      if (httpOptions && httpOptions.extraBody !== null) {
        includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
      }
      requestInit.headers = await this.getHeadersInternal(httpOptions, url);
      return requestInit;
    }
    async unaryApiCall(url, requestInit, httpMethod) {
      return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
        await throwErrorIfNotOK(response);
        return new HttpResponse(response);
      }).catch((e) => {
        if (e instanceof Error) {
          throw e;
        } else {
          throw new Error(JSON.stringify(e));
        }
      });
    }
    async streamApiCall(url, requestInit, httpMethod) {
      return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
        await throwErrorIfNotOK(response);
        return this.processStreamResponse(response);
      }).catch((e) => {
        if (e instanceof Error) {
          throw e;
        } else {
          throw new Error(JSON.stringify(e));
        }
      });
    }
    processStreamResponse(response) {
      var _a;
      return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
        const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();
        const decoder = new TextDecoder("utf-8");
        if (!reader) {
          throw new Error("Response body is empty");
        }
        try {
          let buffer = "";
          while (true) {
            const { done, value } = yield __await(reader.read());
            if (done) {
              if (buffer.trim().length > 0) {
                throw new Error("Incomplete JSON segment at the end");
              }
              break;
            }
            const chunkString = decoder.decode(value, { stream: true });
            try {
              const chunkJson = JSON.parse(chunkString);
              if ("error" in chunkJson) {
                const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
                const status = errorJson["status"];
                const code = errorJson["code"];
                const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
                if (code >= 400 && code < 600) {
                  const apiError = new ApiError({
                    message: errorMessage,
                    status: code
                  });
                  throw apiError;
                }
              }
            } catch (e) {
              const error = e;
              if (error.name === "ApiError") {
                throw e;
              }
            }
            buffer += chunkString;
            let match = buffer.match(responseLineRE);
            while (match) {
              const processedChunkString = match[1];
              try {
                const partialResponse = new Response(processedChunkString, {
                  headers: response === null || response === void 0 ? void 0 : response.headers,
                  status: response === null || response === void 0 ? void 0 : response.status,
                  statusText: response === null || response === void 0 ? void 0 : response.statusText
                });
                yield yield __await(new HttpResponse(partialResponse));
                buffer = buffer.slice(match[0].length);
                match = buffer.match(responseLineRE);
              } catch (e) {
                throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
              }
            }
          }
        } finally {
          reader.releaseLock();
        }
      });
    }
    async apiCall(url, requestInit) {
      return fetch(url, requestInit).catch((e) => {
        throw new Error(`exception ${e} sending request`);
      });
    }
    getDefaultHeaders() {
      const headers = {};
      const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
      headers[USER_AGENT_HEADER] = versionHeaderValue;
      headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
      headers[CONTENT_TYPE_HEADER] = "application/json";
      return headers;
    }
    async getHeadersInternal(httpOptions, url) {
      const headers = new Headers();
      if (httpOptions && httpOptions.headers) {
        for (const [key, value] of Object.entries(httpOptions.headers)) {
          headers.append(key, value);
        }
        if (httpOptions.timeout && httpOptions.timeout > 0) {
          headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
        }
      }
      await this.clientOptions.auth.addAuthHeaders(headers, url);
      return headers;
    }
    getFileName(file) {
      var _a;
      let fileName = "";
      if (typeof file === "string") {
        fileName = file.replace(/[/\\]+$/, "");
        fileName = (_a = fileName.split(/[/\\]/).pop()) !== null && _a !== void 0 ? _a : "";
      }
      return fileName;
    }
    /**
     * Uploads a file asynchronously using Gemini API only, this is not supported
     * in Vertex AI.
     *
     * @param file The string path to the file to be uploaded or a Blob object.
     * @param config Optional parameters specified in the `UploadFileConfig`
     *     interface. @see {@link types.UploadFileConfig}
     * @return A promise that resolves to a `File` object.
     * @throws An error if called on a Vertex AI client.
     * @throws An error if the `mimeType` is not provided and can not be inferred,
     */
    async uploadFile(file, config) {
      var _a;
      const fileToUpload = {};
      if (config != null) {
        fileToUpload.mimeType = config.mimeType;
        fileToUpload.name = config.name;
        fileToUpload.displayName = config.displayName;
      }
      if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
        fileToUpload.name = `files/${fileToUpload.name}`;
      }
      const uploader = this.clientOptions.uploader;
      const fileStat = await uploader.stat(file);
      fileToUpload.sizeBytes = String(fileStat.size);
      const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
      if (mimeType === void 0 || mimeType === "") {
        throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
      }
      fileToUpload.mimeType = mimeType;
      const body = {
        file: fileToUpload
      };
      const fileName = this.getFileName(file);
      const path = formatMap("upload/v1beta/files", body["_url"]);
      const uploadUrl = await this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
      return uploader.upload(file, uploadUrl, this);
    }
    /**
     * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported
     * in Vertex AI.
     *
     * @param fileSearchStoreName The name of the file search store to upload the file to.
     * @param file The string path to the file to be uploaded or a Blob object.
     * @param config Optional parameters specified in the `UploadFileConfig`
     *     interface. @see {@link UploadFileConfig}
     * @return A promise that resolves to a `File` object.
     * @throws An error if called on a Vertex AI client.
     * @throws An error if the `mimeType` is not provided and can not be inferred,
     */
    async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {
      var _a;
      const uploader = this.clientOptions.uploader;
      const fileStat = await uploader.stat(file);
      const sizeBytes = String(fileStat.size);
      const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
      if (mimeType === void 0 || mimeType === "") {
        throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
      }
      const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;
      const fileName = this.getFileName(file);
      const body = {};
      if (config === null || config === void 0 ? void 0 : config.customMetadata) {
        body["customMetadata"] = config.customMetadata;
      }
      if (config === null || config === void 0 ? void 0 : config.chunkingConfig) {
        body["chunkingConfig"] = config.chunkingConfig;
      }
      const uploadUrl = await this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
      return uploader.uploadToFileSearchStore(file, uploadUrl, this);
    }
    /**
     * Downloads a file asynchronously to the specified path.
     *
     * @params params - The parameters for the download request, see {@link
     * types.DownloadFileParameters}
     */
    async downloadFile(params) {
      const downloader = this.clientOptions.downloader;
      await downloader.download(params, this);
    }
    async fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {
      var _a;
      let httpOptions = {};
      if (configHttpOptions) {
        httpOptions = configHttpOptions;
      } else {
        httpOptions = {
          apiVersion: "",
          headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${mimeType}` }, fileName ? { "X-Goog-Upload-File-Name": fileName } : {})
        };
      }
      const httpResponse = await this.request({
        path,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions
      });
      if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
        throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
      }
      const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a["x-goog-upload-url"];
      if (uploadUrl === void 0) {
        throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
      }
      return uploadUrl;
    }
  };
  async function throwErrorIfNotOK(response) {
    var _a;
    if (response === void 0) {
      throw new Error("response is undefined");
    }
    if (!response.ok) {
      const status = response.status;
      let errorBody;
      if ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json")) {
        errorBody = await response.json();
      } else {
        errorBody = {
          error: {
            message: await response.text(),
            code: response.status,
            status: response.statusText
          }
        };
      }
      const errorMessage = JSON.stringify(errorBody);
      if (status >= 400 && status < 600) {
        const apiError = new ApiError({
          message: errorMessage,
          status
        });
        throw apiError;
      }
      throw new Error(errorMessage);
    }
  }
  function includeExtraBodyToRequestInit(requestInit, extraBody) {
    if (!extraBody || Object.keys(extraBody).length === 0) {
      return;
    }
    if (requestInit.body instanceof Blob) {
      console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
      return;
    }
    let currentBodyObject = {};
    if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
      try {
        const parsedBody = JSON.parse(requestInit.body);
        if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
          currentBodyObject = parsedBody;
        } else {
          console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
          return;
        }
      } catch (e) {
        console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
        return;
      }
    }
    function deepMerge(target, source) {
      const output = Object.assign({}, target);
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          const sourceValue = source[key];
          const targetValue = output[key];
          if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
            output[key] = deepMerge(targetValue, sourceValue);
          } else {
            if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
              console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
            }
            output[key] = sourceValue;
          }
        }
      }
      return output;
    }
    const mergedBody = deepMerge(currentBodyObject, extraBody);
    requestInit.body = JSON.stringify(mergedBody);
  }
  var MCP_LABEL = "mcp_used/unknown";
  var hasMcpToolUsageFromMcpToTool = false;
  function hasMcpToolUsage(tools) {
    for (const tool of tools) {
      if (isMcpCallableTool(tool)) {
        return true;
      }
      if (typeof tool === "object" && "inputSchema" in tool) {
        return true;
      }
    }
    return hasMcpToolUsageFromMcpToTool;
  }
  function setMcpUsageHeader(headers) {
    var _a;
    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : "";
    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
  }
  function isMcpCallableTool(object) {
    return object !== null && typeof object === "object" && object instanceof McpCallableTool;
  }
  function listAllTools(mcpClient, maxTools = 100) {
    return __asyncGenerator(this, arguments, function* listAllTools_1() {
      let cursor = void 0;
      let numTools = 0;
      while (numTools < maxTools) {
        const t = yield __await(mcpClient.listTools({ cursor }));
        for (const tool of t.tools) {
          yield yield __await(tool);
          numTools++;
        }
        if (!t.nextCursor) {
          break;
        }
        cursor = t.nextCursor;
      }
    });
  }
  var McpCallableTool = class _McpCallableTool {
    constructor(mcpClients = [], config) {
      this.mcpTools = [];
      this.functionNameToMcpClient = {};
      this.mcpClients = mcpClients;
      this.config = config;
    }
    /**
     * Creates a McpCallableTool.
     */
    static create(mcpClients, config) {
      return new _McpCallableTool(mcpClients, config);
    }
    /**
     * Validates the function names are not duplicate and initialize the function
     * name to MCP client mapping.
     *
     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
     *     names.
     */
    async initialize() {
      var _a, e_1, _b, _c;
      if (this.mcpTools.length > 0) {
        return;
      }
      const functionMap = {};
      const mcpTools = [];
      for (const mcpClient of this.mcpClients) {
        try {
          for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const mcpTool = _c;
            mcpTools.push(mcpTool);
            const mcpToolName = mcpTool.name;
            if (functionMap[mcpToolName]) {
              throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
            }
            functionMap[mcpToolName] = mcpClient;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
      this.mcpTools = mcpTools;
      this.functionNameToMcpClient = functionMap;
    }
    async tool() {
      await this.initialize();
      return mcpToolsToGeminiTool(this.mcpTools, this.config);
    }
    async callTool(functionCalls) {
      await this.initialize();
      const functionCallResponseParts = [];
      for (const functionCall of functionCalls) {
        if (functionCall.name in this.functionNameToMcpClient) {
          const mcpClient = this.functionNameToMcpClient[functionCall.name];
          let requestOptions = void 0;
          if (this.config.timeout) {
            requestOptions = {
              timeout: this.config.timeout
            };
          }
          const callToolResponse = await mcpClient.callTool(
            {
              name: functionCall.name,
              arguments: functionCall.args
            },
            // Set the result schema to undefined to allow MCP to rely on the
            // default schema.
            void 0,
            requestOptions
          );
          functionCallResponseParts.push({
            functionResponse: {
              name: functionCall.name,
              response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
            }
          });
        }
      }
      return functionCallResponseParts;
    }
  };
  async function handleWebSocketMessage$1(apiClient, onmessage, event) {
    const serverMessage = new LiveMusicServerMessage();
    let data;
    if (event.data instanceof Blob) {
      data = JSON.parse(await event.data.text());
    } else {
      data = JSON.parse(event.data);
    }
    Object.assign(serverMessage, data);
    onmessage(serverMessage);
  }
  var LiveMusic = class {
    constructor(apiClient, auth, webSocketFactory) {
      this.apiClient = apiClient;
      this.auth = auth;
      this.webSocketFactory = webSocketFactory;
    }
    /**
         Establishes a connection to the specified model and returns a
         LiveMusicSession object representing that connection.
    
         @experimental
    
         @remarks
    
         @param params - The parameters for establishing a connection to the model.
         @return A live session.
    
         @example
         ```ts
         let model = 'models/lyria-realtime-exp';
         const session = await ai.live.music.connect({
           model: model,
           callbacks: {
             onmessage: (e: MessageEvent) => {
               console.log('Received message from the server: %s\n', debug(e.data));
             },
             onerror: (e: ErrorEvent) => {
               console.log('Error occurred: %s\n', debug(e.error));
             },
             onclose: (e: CloseEvent) => {
               console.log('Connection closed.');
             },
           },
         });
         ```
        */
    async connect(params) {
      var _a, _b;
      if (this.apiClient.isVertexAI()) {
        throw new Error("Live music is not supported for Vertex AI.");
      }
      console.warn("Live music generation is experimental and may change in future versions.");
      const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
      const apiVersion = this.apiClient.getApiVersion();
      const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
      const apiKey2 = this.apiClient.getApiKey();
      const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey2}`;
      let onopenResolve = () => {
      };
      const onopenPromise = new Promise((resolve) => {
        onopenResolve = resolve;
      });
      const callbacks = params.callbacks;
      const onopenAwaitedCallback = function() {
        onopenResolve({});
      };
      const apiClient = this.apiClient;
      const websocketCallbacks = {
        onopen: onopenAwaitedCallback,
        onmessage: (event) => {
          void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
        },
        onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
        },
        onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
        }
      };
      const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
      conn.connect();
      await onopenPromise;
      const model = tModel(this.apiClient, params.model);
      const setup = { model };
      const clientMessage = { setup };
      conn.send(JSON.stringify(clientMessage));
      return new LiveMusicSession(conn, this.apiClient);
    }
  };
  var LiveMusicSession = class {
    constructor(conn, apiClient) {
      this.conn = conn;
      this.apiClient = apiClient;
    }
    /**
        Sets inputs to steer music generation. Updates the session's current
        weighted prompts.
    
        @param params - Contains one property, `weightedPrompts`.
    
          - `weightedPrompts` to send to the model; weights are normalized to
            sum to 1.0.
    
        @experimental
       */
    async setWeightedPrompts(params) {
      if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
        throw new Error("Weighted prompts must be set and contain at least one entry.");
      }
      const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);
      this.conn.send(JSON.stringify({ clientContent }));
    }
    /**
        Sets a configuration to the model. Updates the session's current
        music generation config.
    
        @param params - Contains one property, `musicGenerationConfig`.
    
          - `musicGenerationConfig` to set in the model. Passing an empty or
        undefined config to the model will reset the config to defaults.
    
        @experimental
       */
    async setMusicGenerationConfig(params) {
      if (!params.musicGenerationConfig) {
        params.musicGenerationConfig = {};
      }
      const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
      this.conn.send(JSON.stringify(setConfigParameters));
    }
    sendPlaybackControl(playbackControl) {
      const clientMessage = { playbackControl };
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
     * Start the music stream.
     *
     * @experimental
     */
    play() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
    }
    /**
     * Temporarily halt the music stream. Use `play` to resume from the current
     * position.
     *
     * @experimental
     */
    pause() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
    }
    /**
     * Stop the music stream and reset the state. Retains the current prompts
     * and config.
     *
     * @experimental
     */
    stop() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
    }
    /**
     * Resets the context of the music generation without stopping it.
     * Retains the current prompts and config.
     *
     * @experimental
     */
    resetContext() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
    }
    /**
         Terminates the WebSocket connection.
    
         @experimental
       */
    close() {
      this.conn.close();
    }
  };
  function headersToMap$1(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders$1(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  var FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
  async function handleWebSocketMessage(apiClient, onmessage, event) {
    const serverMessage = new LiveServerMessage();
    let jsonData;
    if (event.data instanceof Blob) {
      jsonData = await event.data.text();
    } else if (event.data instanceof ArrayBuffer) {
      jsonData = new TextDecoder().decode(event.data);
    } else {
      jsonData = event.data;
    }
    const data = JSON.parse(jsonData);
    if (apiClient.isVertexAI()) {
      const resp = liveServerMessageFromVertex(data);
      Object.assign(serverMessage, resp);
    } else {
      const resp = data;
      Object.assign(serverMessage, resp);
    }
    onmessage(serverMessage);
  }
  var Live = class {
    constructor(apiClient, auth, webSocketFactory) {
      this.apiClient = apiClient;
      this.auth = auth;
      this.webSocketFactory = webSocketFactory;
      this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
    }
    /**
         Establishes a connection to the specified model with the given
         configuration and returns a Session object representing that connection.
    
         @experimental Built-in MCP support is an experimental feature, may change in
         future versions.
    
         @remarks
    
         @param params - The parameters for establishing a connection to the model.
         @return A live session.
    
         @example
         ```ts
         let model: string;
         if (GOOGLE_GENAI_USE_VERTEXAI) {
           model = 'gemini-2.0-flash-live-preview-04-09';
         } else {
           model = 'gemini-live-2.5-flash-preview';
         }
         const session = await ai.live.connect({
           model: model,
           config: {
             responseModalities: [Modality.AUDIO],
           },
           callbacks: {
             onopen: () => {
               console.log('Connected to the socket.');
             },
             onmessage: (e: MessageEvent) => {
               console.log('Received message from the server: %s\n', debug(e.data));
             },
             onerror: (e: ErrorEvent) => {
               console.log('Error occurred: %s\n', debug(e.error));
             },
             onclose: (e: CloseEvent) => {
               console.log('Connection closed.');
             },
           },
         });
         ```
        */
    async connect(params) {
      var _a, _b, _c, _d, _e, _f;
      if (params.config && params.config.httpOptions) {
        throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
      }
      const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
      const apiVersion = this.apiClient.getApiVersion();
      let url;
      const clientHeaders = this.apiClient.getHeaders();
      if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
        setMcpUsageHeader(clientHeaders);
      }
      const headers = mapToHeaders(clientHeaders);
      if (this.apiClient.isVertexAI()) {
        url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
        await this.auth.addAuthHeaders(headers, url);
      } else {
        const apiKey2 = this.apiClient.getApiKey();
        let method = "BidiGenerateContent";
        let keyName = "key";
        if (apiKey2 === null || apiKey2 === void 0 ? void 0 : apiKey2.startsWith("auth_tokens/")) {
          console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
          if (apiVersion !== "v1alpha") {
            console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
          }
          method = "BidiGenerateContentConstrained";
          keyName = "access_token";
        }
        url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey2}`;
      }
      let onopenResolve = () => {
      };
      const onopenPromise = new Promise((resolve) => {
        onopenResolve = resolve;
      });
      const callbacks = params.callbacks;
      const onopenAwaitedCallback = function() {
        var _a2;
        (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks);
        onopenResolve({});
      };
      const apiClient = this.apiClient;
      const websocketCallbacks = {
        onopen: onopenAwaitedCallback,
        onmessage: (event) => {
          void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
        },
        onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
        },
        onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
        }
      };
      const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
      conn.connect();
      await onopenPromise;
      let transformedModel = tModel(this.apiClient, params.model);
      if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
        const project = this.apiClient.getProject();
        const location = this.apiClient.getLocation();
        transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
      }
      let clientMessage = {};
      if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
        if (params.config === void 0) {
          params.config = { responseModalities: [Modality.AUDIO] };
        } else {
          params.config.responseModalities = [Modality.AUDIO];
        }
      }
      if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
        console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
      }
      const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
      const convertedTools = [];
      for (const tool of inputTools) {
        if (this.isCallableTool(tool)) {
          const callableTool = tool;
          convertedTools.push(await callableTool.tool());
        } else {
          convertedTools.push(tool);
        }
      }
      if (convertedTools.length > 0) {
        params.config.tools = convertedTools;
      }
      const liveConnectParameters = {
        model: transformedModel,
        config: params.config,
        callbacks: params.callbacks
      };
      if (this.apiClient.isVertexAI()) {
        clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
      } else {
        clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
      }
      delete clientMessage["config"];
      conn.send(JSON.stringify(clientMessage));
      return new Session(conn, this.apiClient);
    }
    // TODO: b/416041229 - Abstract this method to a common place.
    isCallableTool(tool) {
      return "callTool" in tool && typeof tool.callTool === "function";
    }
  };
  var defaultLiveSendClientContentParamerters = {
    turnComplete: true
  };
  var Session = class {
    constructor(conn, apiClient) {
      this.conn = conn;
      this.apiClient = apiClient;
    }
    tLiveClientContent(apiClient, params) {
      if (params.turns !== null && params.turns !== void 0) {
        let contents = [];
        try {
          contents = tContents(params.turns);
          if (!apiClient.isVertexAI()) {
            contents = contents.map((item) => contentToMldev$1(item));
          }
        } catch (_a) {
          throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
        }
        return {
          clientContent: { turns: contents, turnComplete: params.turnComplete }
        };
      }
      return {
        clientContent: { turnComplete: params.turnComplete }
      };
    }
    tLiveClienttToolResponse(apiClient, params) {
      let functionResponses = [];
      if (params.functionResponses == null) {
        throw new Error("functionResponses is required.");
      }
      if (!Array.isArray(params.functionResponses)) {
        functionResponses = [params.functionResponses];
      } else {
        functionResponses = params.functionResponses;
      }
      if (functionResponses.length === 0) {
        throw new Error("functionResponses is required.");
      }
      for (const functionResponse of functionResponses) {
        if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
          throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
        }
        if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
          throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
        }
      }
      const clientMessage = {
        toolResponse: { functionResponses }
      };
      return clientMessage;
    }
    /**
        Send a message over the established connection.
    
        @param params - Contains two **optional** properties, `turns` and
            `turnComplete`.
    
          - `turns` will be converted to a `Content[]`
          - `turnComplete: true` [default] indicates that you are done sending
            content and expect a response. If `turnComplete: false`, the server
            will wait for additional messages before starting generation.
    
        @experimental
    
        @remarks
        There are two ways to send messages to the live API:
        `sendClientContent` and `sendRealtimeInput`.
    
        `sendClientContent` messages are added to the model context **in order**.
        Having a conversation using `sendClientContent` messages is roughly
        equivalent to using the `Chat.sendMessageStream`, except that the state of
        the `chat` history is stored on the API server instead of locally.
    
        Because of `sendClientContent`'s order guarantee, the model cannot respons
        as quickly to `sendClientContent` messages as to `sendRealtimeInput`
        messages. This makes the biggest difference when sending objects that have
        significant preprocessing time (typically images).
    
        The `sendClientContent` message sends a `Content[]`
        which has more options than the `Blob` sent by `sendRealtimeInput`.
    
        So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
    
        - Sending anything that can't be represented as a `Blob` (text,
        `sendClientContent({turns="Hello?"}`)).
        - Managing turns when not using audio input and voice activity detection.
          (`sendClientContent({turnComplete:true})` or the short form
        `sendClientContent()`)
        - Prefilling a conversation context
          ```
          sendClientContent({
              turns: [
                Content({role:user, parts:...}),
                Content({role:user, parts:...}),
                ...
              ]
          })
          ```
        @experimental
       */
    sendClientContent(params) {
      params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
      const clientMessage = this.tLiveClientContent(this.apiClient, params);
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
        Send a realtime message over the established connection.
    
        @param params - Contains one property, `media`.
    
          - `media` will be converted to a `Blob`
    
        @experimental
    
        @remarks
        Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
    
        With `sendRealtimeInput` the api will respond to audio automatically
        based on voice activity detection (VAD).
    
        `sendRealtimeInput` is optimized for responsivness at the expense of
        deterministic ordering guarantees. Audio and video tokens are to the
        context when they become available.
    
        Note: The Call signature expects a `Blob` object, but only a subset
        of audio and image mimetypes are allowed.
       */
    sendRealtimeInput(params) {
      let clientMessage = {};
      if (this.apiClient.isVertexAI()) {
        clientMessage = {
          "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
        };
      } else {
        clientMessage = {
          "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
        };
      }
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
        Send a function response message over the established connection.
    
        @param params - Contains property `functionResponses`.
    
          - `functionResponses` will be converted to a `functionResponses[]`
    
        @remarks
        Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
    
        Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
    
        @experimental
       */
    sendToolResponse(params) {
      if (params.functionResponses == null) {
        throw new Error("Tool response parameters are required.");
      }
      const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
         Terminates the WebSocket connection.
    
         @experimental
    
         @example
         ```ts
         let model: string;
         if (GOOGLE_GENAI_USE_VERTEXAI) {
           model = 'gemini-2.0-flash-live-preview-04-09';
         } else {
           model = 'gemini-live-2.5-flash-preview';
         }
         const session = await ai.live.connect({
           model: model,
           config: {
             responseModalities: [Modality.AUDIO],
           }
         });
    
         session.close();
         ```
       */
    close() {
      this.conn.close();
    }
  };
  function headersToMap(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  var DEFAULT_MAX_REMOTE_CALLS = 10;
  function shouldDisableAfc(config) {
    var _a, _b, _c;
    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {
      return true;
    }
    let callableToolsPresent = false;
    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
      if (isCallableTool(tool)) {
        callableToolsPresent = true;
        break;
      }
    }
    if (!callableToolsPresent) {
      return true;
    }
    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
      console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
      return true;
    }
    return false;
  }
  function isCallableTool(tool) {
    return "callTool" in tool && typeof tool.callTool === "function";
  }
  function hasCallableTools(params) {
    var _a, _b, _c;
    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
  }
  function findAfcIncompatibleToolIndexes(params) {
    var _a;
    const afcIncompatibleToolIndexes = [];
    if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {
      return afcIncompatibleToolIndexes;
    }
    params.config.tools.forEach((tool, index) => {
      if (isCallableTool(tool)) {
        return;
      }
      const geminiTool = tool;
      if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {
        afcIncompatibleToolIndexes.push(index);
      }
    });
    return afcIncompatibleToolIndexes;
  }
  function shouldAppendAfcHistory(config) {
    var _a;
    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);
  }
  var Models = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.generateContent = async (params) => {
        var _a, _b, _c, _d, _e;
        const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
        this.maybeMoveToResponseJsonSchem(params);
        if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
          return await this.generateContentInternal(transformedParams);
        }
        const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
        if (incompatibleToolIndexes.length > 0) {
          const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
          throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);
        }
        let response;
        let functionResponseContent;
        const automaticFunctionCallingHistory = tContents(transformedParams.contents);
        const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
        let remoteCalls = 0;
        while (remoteCalls < maxRemoteCalls) {
          response = await this.generateContentInternal(transformedParams);
          if (!response.functionCalls || response.functionCalls.length === 0) {
            break;
          }
          const responseContent = response.candidates[0].content;
          const functionResponseParts = [];
          for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              const parts = await callableTool.callTool(response.functionCalls);
              functionResponseParts.push(...parts);
            }
          }
          remoteCalls++;
          functionResponseContent = {
            role: "user",
            parts: functionResponseParts
          };
          transformedParams.contents = tContents(transformedParams.contents);
          transformedParams.contents.push(responseContent);
          transformedParams.contents.push(functionResponseContent);
          if (shouldAppendAfcHistory(transformedParams.config)) {
            automaticFunctionCallingHistory.push(responseContent);
            automaticFunctionCallingHistory.push(functionResponseContent);
          }
        }
        if (shouldAppendAfcHistory(transformedParams.config)) {
          response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
        }
        return response;
      };
      this.generateContentStream = async (params) => {
        var _a, _b, _c, _d, _e;
        this.maybeMoveToResponseJsonSchem(params);
        if (shouldDisableAfc(params.config)) {
          const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
          return await this.generateContentStreamInternal(transformedParams);
        }
        const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
        if (incompatibleToolIndexes.length > 0) {
          const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
          throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`);
        }
        const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;
        const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;
        if (streamFunctionCall && !disableAfc) {
          throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");
        }
        return await this.processAfcStream(params);
      };
      this.generateImages = async (params) => {
        return await this.generateImagesInternal(params).then((apiResponse) => {
          var _a;
          let positivePromptSafetyAttributes;
          const generatedImages = [];
          if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
            for (const generatedImage of apiResponse.generatedImages) {
              if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === "Positive Prompt") {
                positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
              } else {
                generatedImages.push(generatedImage);
              }
            }
          }
          let response;
          if (positivePromptSafetyAttributes) {
            response = {
              generatedImages,
              positivePromptSafetyAttributes,
              sdkHttpResponse: apiResponse.sdkHttpResponse
            };
          } else {
            response = {
              generatedImages,
              sdkHttpResponse: apiResponse.sdkHttpResponse
            };
          }
          return response;
        });
      };
      this.list = async (params) => {
        var _a;
        const defaultConfig = {
          queryBase: true
        };
        const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
        const actualParams = {
          config: actualConfig
        };
        if (this.apiClient.isVertexAI()) {
          if (!actualParams.config.queryBase) {
            if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {
              throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
            } else {
              actualParams.config.filter = "labels.tune-type:*";
            }
          }
        }
        return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);
      };
      this.editImage = async (params) => {
        const paramsInternal = {
          model: params.model,
          prompt: params.prompt,
          referenceImages: [],
          config: params.config
        };
        if (params.referenceImages) {
          if (params.referenceImages) {
            paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
          }
        }
        return await this.editImageInternal(paramsInternal);
      };
      this.upscaleImage = async (params) => {
        let apiConfig = {
          numberOfImages: 1,
          mode: "upscale"
        };
        if (params.config) {
          apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
        }
        const apiParams = {
          model: params.model,
          image: params.image,
          upscaleFactor: params.upscaleFactor,
          config: apiConfig
        };
        return await this.upscaleImageInternal(apiParams);
      };
      this.generateVideos = async (params) => {
        var _a, _b, _c, _d, _e, _f;
        if ((params.prompt || params.image || params.video) && params.source) {
          throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
        }
        if (!this.apiClient.isVertexAI()) {
          if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {
            params.video = {
              uri: params.video.uri,
              mimeType: params.video.mimeType
            };
          } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {
            params.source.video = {
              uri: params.source.video.uri,
              mimeType: params.source.video.mimeType
            };
          }
        }
        return await this.generateVideosInternal(params);
      };
    }
    /**
     * This logic is needed for GenerateContentConfig only.
     * Previously we made GenerateContentConfig.responseSchema field to accept
     * unknown. Since v1.9.0, we switch to use backend JSON schema support.
     * To maintain backward compatibility, we move the data that was treated as
     * JSON schema from the responseSchema field to the responseJsonSchema field.
     */
    maybeMoveToResponseJsonSchem(params) {
      if (params.config && params.config.responseSchema) {
        if (!params.config.responseJsonSchema) {
          if (Object.keys(params.config.responseSchema).includes("$schema")) {
            params.config.responseJsonSchema = params.config.responseSchema;
            delete params.config.responseSchema;
          }
        }
      }
      return;
    }
    /**
     * Transforms the CallableTools in the parameters to be simply Tools, it
     * copies the params into a new object and replaces the tools, it does not
     * modify the original params. Also sets the MCP usage header if there are
     * MCP tools in the parameters.
     */
    async processParamsMaybeAddMcpUsage(params) {
      var _a, _b, _c;
      const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;
      if (!tools) {
        return params;
      }
      const transformedTools = await Promise.all(tools.map(async (tool) => {
        if (isCallableTool(tool)) {
          const callableTool = tool;
          return await callableTool.tool();
        }
        return tool;
      }));
      const newParams = {
        model: params.model,
        contents: params.contents,
        config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
      };
      newParams.config.tools = transformedTools;
      if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
        const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
        let newHeaders = Object.assign({}, headers);
        if (Object.keys(newHeaders).length === 0) {
          newHeaders = this.apiClient.getDefaultHeaders();
        }
        setMcpUsageHeader(newHeaders);
        newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
      }
      return newParams;
    }
    async initAfcToolsMap(params) {
      var _a, _b, _c;
      const afcTools = /* @__PURE__ */ new Map();
      for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {
        if (isCallableTool(tool)) {
          const callableTool = tool;
          const toolDeclaration = await callableTool.tool();
          for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
            if (!declaration.name) {
              throw new Error("Function declaration name is required.");
            }
            if (afcTools.has(declaration.name)) {
              throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
            }
            afcTools.set(declaration.name, callableTool);
          }
        }
      }
      return afcTools;
    }
    async processAfcStream(params) {
      var _a, _b, _c;
      const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
      let wereFunctionsCalled = false;
      let remoteCallCount = 0;
      const afcToolsMap = await this.initAfcToolsMap(params);
      return (function(models, afcTools, params2) {
        var _a2, _b2;
        return __asyncGenerator(this, arguments, function* () {
          var _c2, e_1, _d, _e;
          while (remoteCallCount < maxRemoteCalls) {
            if (wereFunctionsCalled) {
              remoteCallCount++;
              wereFunctionsCalled = false;
            }
            const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params2));
            const response = yield __await(models.generateContentStreamInternal(transformedParams));
            const functionResponses = [];
            const responseContents = [];
            try {
              for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
                _e = response_1_1.value;
                _f = false;
                const chunk = _e;
                yield yield __await(chunk);
                if (chunk.candidates && ((_a2 = chunk.candidates[0]) === null || _a2 === void 0 ? void 0 : _a2.content)) {
                  responseContents.push(chunk.candidates[0].content);
                  for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== void 0 ? _b2 : []) {
                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                      if (!part.functionCall.name) {
                        throw new Error("Function call name was not returned by the model.");
                      }
                      if (!afcTools.has(part.functionCall.name)) {
                        throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                      } else {
                        const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                        functionResponses.push(...responseParts);
                      }
                    }
                  }
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_f && !_c2 && (_d = response_1.return)) yield __await(_d.call(response_1));
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            if (functionResponses.length > 0) {
              wereFunctionsCalled = true;
              const typedResponseChunk = new GenerateContentResponse();
              typedResponseChunk.candidates = [
                {
                  content: {
                    role: "user",
                    parts: functionResponses
                  }
                }
              ];
              yield yield __await(typedResponseChunk);
              const newContents = [];
              newContents.push(...responseContents);
              newContents.push({
                role: "user",
                parts: functionResponses
              });
              const updatedContents = tContents(params2.contents).concat(newContents);
              params2.contents = updatedContents;
            } else {
              break;
            }
          }
        });
      })(this, afcToolsMap, params);
    }
    async generateContentInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateContentParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:generateContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateContentResponseFromVertex(apiResponse);
          const typedResp = new GenerateContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = generateContentParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:generateContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateContentResponseFromMldev(apiResponse);
          const typedResp = new GenerateContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    async generateContentStreamInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateContentParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        const apiClient = this.apiClient;
        response = apiClient.requestStream({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
        return response.then(function(apiResponse) {
          return __asyncGenerator(this, arguments, function* () {
            var _a2, e_2, _b2, _c2;
            try {
              for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a2 = apiResponse_1_1.done, !_a2; _d2 = true) {
                _c2 = apiResponse_1_1.value;
                _d2 = false;
                const chunk = _c2;
                const resp = generateContentResponseFromVertex(yield __await(chunk.json()));
                resp["sdkHttpResponse"] = {
                  headers: chunk.headers
                };
                const typedResp = new GenerateContentResponse();
                Object.assign(typedResp, resp);
                yield yield __await(typedResp);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (!_d2 && !_a2 && (_b2 = apiResponse_1.return)) yield __await(_b2.call(apiResponse_1));
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          });
        });
      } else {
        const body = generateContentParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        const apiClient = this.apiClient;
        response = apiClient.requestStream({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        });
        return response.then(function(apiResponse) {
          return __asyncGenerator(this, arguments, function* () {
            var _a2, e_3, _b2, _c2;
            try {
              for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a2 = apiResponse_2_1.done, !_a2; _d2 = true) {
                _c2 = apiResponse_2_1.value;
                _d2 = false;
                const chunk = _c2;
                const resp = generateContentResponseFromMldev(yield __await(chunk.json()));
                resp["sdkHttpResponse"] = {
                  headers: chunk.headers
                };
                const typedResp = new GenerateContentResponse();
                Object.assign(typedResp, resp);
                yield yield __await(typedResp);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (!_d2 && !_a2 && (_b2 = apiResponse_2.return)) yield __await(_b2.call(apiResponse_2));
              } finally {
                if (e_3) throw e_3.error;
              }
            }
          });
        });
      }
    }
    /**
     * Calculates embeddings for the given contents. Only text is supported.
     *
     * @param params - The parameters for embedding contents.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.embedContent({
     *  model: 'text-embedding-004',
     *  contents: [
     *    'What is your name?',
     *    'What is your favorite color?',
     *  ],
     *  config: {
     *    outputDimensionality: 64,
     *  },
     * });
     * console.log(response);
     * ```
     */
    async embedContent(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = embedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = embedContentResponseFromVertex(apiResponse);
          const typedResp = new EmbedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = embedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:batchEmbedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = embedContentResponseFromMldev(apiResponse);
          const typedResp = new EmbedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Private method for generating images.
     */
    async generateImagesInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateImagesParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateImagesResponseFromVertex(apiResponse);
          const typedResp = new GenerateImagesResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = generateImagesParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateImagesResponseFromMldev(apiResponse);
          const typedResp = new GenerateImagesResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Private method for editing an image.
     */
    async editImageInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = editImageParametersInternalToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = editImageResponseFromVertex(apiResponse);
          const typedResp = new EditImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Private method for upscaling an image.
     */
    async upscaleImageInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = upscaleImageResponseFromVertex(apiResponse);
          const typedResp = new UpscaleImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Recontextualizes an image.
     *
     * There are two types of recontextualization currently supported:
     * 1) Imagen Product Recontext - Generate images of products in new scenes
     *    and contexts.
     * 2) Virtual Try-On: Generate images of persons modeling fashion products.
     *
     * @param params - The parameters for recontextualizing an image.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response1 = await ai.models.recontextImage({
     *  model: 'imagen-product-recontext-preview-06-30',
     *  source: {
     *    prompt: 'In a modern kitchen setting.',
     *    productImages: [productImage],
     *  },
     *  config: {
     *    numberOfImages: 1,
     *  },
     * });
     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
     *
     * const response2 = await ai.models.recontextImage({
     *  model: 'virtual-try-on-preview-08-04',
     *  source: {
     *    personImage: personImage,
     *    productImages: [productImage],
     *  },
     *  config: {
     *    numberOfImages: 1,
     *  },
     * });
     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
     * ```
     */
    async recontextImage(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = recontextImageParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = recontextImageResponseFromVertex(apiResponse);
          const typedResp = new RecontextImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Segments an image, creating a mask of a specified area.
     *
     * @param params - The parameters for segmenting an image.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.segmentImage({
     *  model: 'image-segmentation-001',
     *  source: {
     *    image: image,
     *  },
     *  config: {
     *    mode: 'foreground',
     *  },
     * });
     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
     * ```
     */
    async segmentImage(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = segmentImageParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = segmentImageResponseFromVertex(apiResponse);
          const typedResp = new SegmentImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Fetches information about a model by name.
     *
     * @example
     * ```ts
     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
     * ```
     */
    async get(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getModelParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = getModelParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromMldev(apiResponse);
          return resp;
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listModelsParametersToVertex(this.apiClient, params);
        path = formatMap("{models_url}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listModelsResponseFromVertex(apiResponse);
          const typedResp = new ListModelsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listModelsParametersToMldev(this.apiClient, params);
        path = formatMap("{models_url}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listModelsResponseFromMldev(apiResponse);
          const typedResp = new ListModelsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Updates a tuned model by its name.
     *
     * @param params - The parameters for updating the model.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.update({
     *   model: 'tuned-model-name',
     *   config: {
     *     displayName: 'New display name',
     *     description: 'New description',
     *   },
     * });
     * ```
     */
    async update(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = updateModelParametersToVertex(this.apiClient, params);
        path = formatMap("{model}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = updateModelParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Deletes a tuned model by its name.
     *
     * @param params - The parameters for deleting the model.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.delete({model: 'tuned-model-name'});
     * ```
     */
    async delete(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = deleteModelParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteModelResponseFromVertex(apiResponse);
          const typedResp = new DeleteModelResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = deleteModelParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteModelResponseFromMldev(apiResponse);
          const typedResp = new DeleteModelResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Counts the number of tokens in the given contents. Multimodal input is
     * supported for Gemini models.
     *
     * @param params - The parameters for counting tokens.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.countTokens({
     *  model: 'gemini-2.0-flash',
     *  contents: 'The quick brown fox jumps over the lazy dog.'
     * });
     * console.log(response);
     * ```
     */
    async countTokens(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = countTokensParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:countTokens", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = countTokensResponseFromVertex(apiResponse);
          const typedResp = new CountTokensResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = countTokensParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:countTokens", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = countTokensResponseFromMldev(apiResponse);
          const typedResp = new CountTokensResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Given a list of contents, returns a corresponding TokensInfo containing
     * the list of tokens and list of token ids.
     *
     * This method is not supported by the Gemini Developer API.
     *
     * @param params - The parameters for computing tokens.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.computeTokens({
     *  model: 'gemini-2.0-flash',
     *  contents: 'What is your name?'
     * });
     * console.log(response);
     * ```
     */
    async computeTokens(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = computeTokensParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:computeTokens", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = computeTokensResponseFromVertex(apiResponse);
          const typedResp = new ComputeTokensResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Private method for generating videos.
     */
    async generateVideosInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateVideosParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predictLongRunning", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = generateVideosOperationFromVertex(apiResponse);
          const typedResp = new GenerateVideosOperation();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = generateVideosParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:predictLongRunning", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = generateVideosOperationFromMldev(apiResponse);
          const typedResp = new GenerateVideosOperation();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  var Operations = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
    }
    /**
     * Gets the status of a long-running operation.
     *
     * @param parameters The parameters for the get operation request.
     * @return The updated Operation object, with the latest status or result.
     */
    async getVideosOperation(parameters) {
      const operation = parameters.operation;
      const config = parameters.config;
      if (operation.name === void 0 || operation.name === "") {
        throw new Error("Operation name is required.");
      }
      if (this.apiClient.isVertexAI()) {
        const resourceName2 = operation.name.split("/operations/")[0];
        let httpOptions = void 0;
        if (config && "httpOptions" in config) {
          httpOptions = config.httpOptions;
        }
        const rawOperation = await this.fetchPredictVideosOperationInternal({
          operationName: operation.name,
          resourceName: resourceName2,
          config: { httpOptions }
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          _isVertexAI: true
        });
      } else {
        const rawOperation = await this.getVideosOperationInternal({
          operationName: operation.name,
          config
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          _isVertexAI: false
        });
      }
    }
    /**
     * Gets the status of a long-running operation.
     *
     * @param parameters The parameters for the get operation request.
     * @return The updated Operation object, with the latest status or result.
     */
    async get(parameters) {
      const operation = parameters.operation;
      const config = parameters.config;
      if (operation.name === void 0 || operation.name === "") {
        throw new Error("Operation name is required.");
      }
      if (this.apiClient.isVertexAI()) {
        const resourceName2 = operation.name.split("/operations/")[0];
        let httpOptions = void 0;
        if (config && "httpOptions" in config) {
          httpOptions = config.httpOptions;
        }
        const rawOperation = await this.fetchPredictVideosOperationInternal({
          operationName: operation.name,
          resourceName: resourceName2,
          config: { httpOptions }
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          _isVertexAI: true
        });
      } else {
        const rawOperation = await this.getVideosOperationInternal({
          operationName: operation.name,
          config
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          _isVertexAI: false
        });
      }
    }
    async getVideosOperationInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getOperationParametersToVertex(params);
        path = formatMap("{operationName}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response;
      } else {
        const body = getOperationParametersToMldev(params);
        path = formatMap("{operationName}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response;
      }
    }
    async fetchPredictVideosOperationInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = fetchPredictOperationParametersToVertex(params);
        path = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response;
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
  };
  function blobToMldev(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentToMldev(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromNewSessionExpireTime = getValueByPath(fromObject, [
      "newSessionExpireTime"
    ]);
    if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
      setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
    }
    const fromUses = getValueByPath(fromObject, ["uses"]);
    if (parentObject !== void 0 && fromUses != null) {
      setValueByPath(parentObject, ["uses"], fromUses);
    }
    const fromLiveConnectConstraints = getValueByPath(fromObject, [
      "liveConnectConstraints"
    ]);
    if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
      setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
    }
    const fromLockAdditionalFields = getValueByPath(fromObject, [
      "lockAdditionalFields"
    ]);
    if (parentObject !== void 0 && fromLockAdditionalFields != null) {
      setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
    }
    return toObject;
  }
  function createAuthTokenParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function fileDataToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function googleMapsToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function liveConnectConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (parentObject !== void 0 && fromThinkingConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
    }
    return toObject;
  }
  function liveConnectConstraintsToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
    }
    return toObject;
  }
  function partToMldev(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function sessionResumptionConfigToMldev(fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
      throw new Error("transparent parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function toolToMldev(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function getFieldMasks(setup) {
    const fields = [];
    for (const key in setup) {
      if (Object.prototype.hasOwnProperty.call(setup, key)) {
        const value = setup[key];
        if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
          const field = Object.keys(value).map((kk) => `${key}.${kk}`);
          fields.push(...field);
        } else {
          fields.push(key);
        }
      }
    }
    return fields.join(",");
  }
  function convertBidiSetupToTokenSetup(requestDict, config) {
    let setupForMaskGeneration = null;
    const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
    if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
      const innerSetup = bidiGenerateContentSetupValue.setup;
      if (typeof innerSetup === "object" && innerSetup !== null) {
        requestDict["bidiGenerateContentSetup"] = innerSetup;
        setupForMaskGeneration = innerSetup;
      } else {
        delete requestDict["bidiGenerateContentSetup"];
      }
    } else if (bidiGenerateContentSetupValue !== void 0) {
      delete requestDict["bidiGenerateContentSetup"];
    }
    const preExistingFieldMask = requestDict["fieldMask"];
    if (setupForMaskGeneration) {
      const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
      if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
        if (generatedMaskFromBidi) {
          requestDict["fieldMask"] = generatedMaskFromBidi;
        } else {
          delete requestDict["fieldMask"];
        }
      } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
        const generationConfigFields = [
          "temperature",
          "topK",
          "topP",
          "maxOutputTokens",
          "responseModalities",
          "seed",
          "speechConfig"
        ];
        let mappedFieldsFromPreExisting = [];
        if (preExistingFieldMask.length > 0) {
          mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
            if (generationConfigFields.includes(field)) {
              return `generationConfig.${field}`;
            }
            return field;
          });
        }
        const finalMaskParts = [];
        if (generatedMaskFromBidi) {
          finalMaskParts.push(generatedMaskFromBidi);
        }
        if (mappedFieldsFromPreExisting.length > 0) {
          finalMaskParts.push(...mappedFieldsFromPreExisting);
        }
        if (finalMaskParts.length > 0) {
          requestDict["fieldMask"] = finalMaskParts.join(",");
        } else {
          delete requestDict["fieldMask"];
        }
      } else {
        delete requestDict["fieldMask"];
      }
    } else {
      if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
        requestDict["fieldMask"] = preExistingFieldMask.join(",");
      } else {
        delete requestDict["fieldMask"];
      }
    }
    return requestDict;
  }
  var Tokens = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
    }
    /**
     * Creates an ephemeral auth token resource.
     *
     * @experimental
     *
     * @remarks
     * Ephemeral auth tokens is only supported in the Gemini Developer API.
     * It can be used for the session connection to the Live constrained API.
     * Support in v1alpha only.
     *
     * @param params - The parameters for the create request.
     * @return The created auth token.
     *
     * @example
     * ```ts
     * const ai = new GoogleGenAI({
     *     apiKey: token.name,
     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
     * });
     *
     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
     * // when using the token in Live API sessions. Each session connection can
     * // use a different configuration.
     * const config: CreateAuthTokenConfig = {
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     * }
     * const token = await ai.tokens.create(config);
     *
     * // Case 2: If LiveEphemeralParameters is set, lock all fields in
     * // LiveConnectConfig when using the token in Live API sessions. For
     * // example, changing `outputAudioTranscription` in the Live API
     * // connection will be ignored by the API.
     * const config: CreateAuthTokenConfig =
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     *     LiveEphemeralParameters: {
     *        model: 'gemini-2.0-flash-001',
     *        config: {
     *           'responseModalities': ['AUDIO'],
     *           'systemInstruction': 'Always answer in English.',
     *        }
     *     }
     * }
     * const token = await ai.tokens.create(config);
     *
     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
     * // set, lock LiveConnectConfig with set and additional fields (e.g.
     * // responseModalities, systemInstruction, temperature in this example) when
     * // using the token in Live API sessions.
     * const config: CreateAuthTokenConfig =
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     *     LiveEphemeralParameters: {
     *        model: 'gemini-2.0-flash-001',
     *        config: {
     *           'responseModalities': ['AUDIO'],
     *           'systemInstruction': 'Always answer in English.',
     *        }
     *     },
     *     lockAdditionalFields: ['temperature'],
     * }
     * const token = await ai.tokens.create(config);
     *
     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
     * // empty array, lock LiveConnectConfig with set fields (e.g.
     * // responseModalities, systemInstruction in this example) when using the
     * // token in Live API sessions.
     * const config: CreateAuthTokenConfig =
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     *     LiveEphemeralParameters: {
     *        model: 'gemini-2.0-flash-001',
     *        config: {
     *           'responseModalities': ['AUDIO'],
     *           'systemInstruction': 'Always answer in English.',
     *        }
     *     },
     *     lockAdditionalFields: [],
     * }
     * const token = await ai.tokens.create(config);
     * ```
     */
    async create(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
      } else {
        const body = createAuthTokenParametersToMldev(this.apiClient, params);
        path = formatMap("auth_tokens", body["_url"]);
        queryParams = body["_query"];
        delete body["config"];
        delete body["_url"];
        delete body["_query"];
        const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(transformedBody),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
  };
  function createFileSearchStoreConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    return toObject;
  }
  function createFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createFileSearchStoreConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromForce = getValueByPath(fromObject, ["force"]);
    if (parentObject !== void 0 && fromForce != null) {
      setValueByPath(parentObject, ["_query", "force"], fromForce);
    }
    return toObject;
  }
  function deleteFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      deleteFileSearchStoreConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function getFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function importFileConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromCustomMetadata = getValueByPath(fromObject, [
      "customMetadata"
    ]);
    if (parentObject !== void 0 && fromCustomMetadata != null) {
      let transformedList = fromCustomMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["customMetadata"], transformedList);
    }
    const fromChunkingConfig = getValueByPath(fromObject, [
      "chunkingConfig"
    ]);
    if (parentObject !== void 0 && fromChunkingConfig != null) {
      setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
    }
    return toObject;
  }
  function importFileOperationFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], importFileResponseFromMldev(fromResponse));
    }
    return toObject;
  }
  function importFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromFileSearchStoreName = getValueByPath(fromObject, [
      "fileSearchStoreName"
    ]);
    if (fromFileSearchStoreName != null) {
      setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
    }
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      importFileConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function importFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["parent"], fromParent);
    }
    const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
    if (fromDocumentName != null) {
      setValueByPath(toObject, ["documentName"], fromDocumentName);
    }
    return toObject;
  }
  function listFileSearchStoresConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listFileSearchStoresParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listFileSearchStoresConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listFileSearchStoresResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromFileSearchStores = getValueByPath(fromObject, [
      "fileSearchStores"
    ]);
    if (fromFileSearchStores != null) {
      let transformedList = fromFileSearchStores;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["fileSearchStores"], transformedList);
    }
    return toObject;
  }
  function uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (parentObject !== void 0 && fromMimeType != null) {
      setValueByPath(parentObject, ["mimeType"], fromMimeType);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromCustomMetadata = getValueByPath(fromObject, [
      "customMetadata"
    ]);
    if (parentObject !== void 0 && fromCustomMetadata != null) {
      let transformedList = fromCustomMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["customMetadata"], transformedList);
    }
    const fromChunkingConfig = getValueByPath(fromObject, [
      "chunkingConfig"
    ]);
    if (parentObject !== void 0 && fromChunkingConfig != null) {
      setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
    }
    return toObject;
  }
  function uploadToFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromFileSearchStoreName = getValueByPath(fromObject, [
      "fileSearchStoreName"
    ]);
    if (fromFileSearchStoreName != null) {
      setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteDocumentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromForce = getValueByPath(fromObject, ["force"]);
    if (parentObject !== void 0 && fromForce != null) {
      setValueByPath(parentObject, ["_query", "force"], fromForce);
    }
    return toObject;
  }
  function deleteDocumentParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      deleteDocumentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function getDocumentParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function listDocumentsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listDocumentsParametersToMldev(fromObject) {
    const toObject = {};
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["_url", "parent"], fromParent);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listDocumentsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listDocumentsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromDocuments = getValueByPath(fromObject, ["documents"]);
    if (fromDocuments != null) {
      let transformedList = fromDocuments;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["documents"], transformedList);
    }
    return toObject;
  }
  var Documents = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.list = async (params) => {
        return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x) => this.listInternal({
          parent: params.parent,
          config: x.config
        }), await this.listInternal(params), params);
      };
    }
    /**
     * Gets a Document.
     *
     * @param params - The parameters for getting a document.
     * @return Document.
     */
    async get(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = getDocumentParametersToMldev(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
    /**
     * Deletes a Document.
     *
     * @param params - The parameters for deleting a document.
     */
    async delete(params) {
      var _a, _b;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = deleteDocumentParametersToMldev(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
      }
    }
    /**
     * Lists all Documents in a FileSearchStore.
     *
     * @param params - The parameters for listing documents.
     * @return ListDocumentsResponse.
     */
    async listInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = listDocumentsParametersToMldev(params);
        path = formatMap("{parent}/documents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = listDocumentsResponseFromMldev(apiResponse);
          const typedResp = new ListDocumentsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  var FileSearchStores = class extends BaseModule {
    constructor(apiClient, documents = new Documents(apiClient)) {
      super();
      this.apiClient = apiClient;
      this.documents = documents;
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x) => this.listInternal(x), await this.listInternal(params), params);
      };
    }
    /**
     * Uploads a file asynchronously to a given File Search Store.
     * This method is not available in Vertex AI.
     * Supported upload sources:
     * - Node.js: File path (string) or Blob object.
     * - Browser: Blob object (e.g., File).
     *
     * @remarks
     * The `mimeType` can be specified in the `config` parameter. If omitted:
     *  - For file path (string) inputs, the `mimeType` will be inferred from the
     *     file extension.
     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
     *     property.
     *
     * This section can contain multiple paragraphs and code examples.
     *
     * @param params - Optional parameters specified in the
     *        `types.UploadToFileSearchStoreParameters` interface.
     *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional
     *         config in the parameters.
     * @return A promise that resolves to a long running operation.
     * @throws An error if called on a Vertex AI client.
     * @throws An error if the `mimeType` is not provided and can not be inferred,
     * the `mimeType` can be provided in the `params.config` parameter.
     * @throws An error occurs if a suitable upload location cannot be established.
     *
     * @example
     * The following code uploads a file to a given file search store.
     *
     * ```ts
     * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {
     *   mimeType: 'text/plain',
     * }});
     * console.log(operation.name);
     * ```
     */
    async uploadToFileSearchStore(params) {
      if (this.apiClient.isVertexAI()) {
        throw new Error("Vertex AI does not support uploading files to a file search store.");
      }
      return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);
    }
    /**
     * Creates a File Search Store.
     *
     * @param params - The parameters for creating a File Search Store.
     * @return FileSearchStore.
     */
    async create(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = createFileSearchStoreParametersToMldev(params);
        path = formatMap("fileSearchStores", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
    /**
     * Gets a File Search Store.
     *
     * @param params - The parameters for getting a File Search Store.
     * @return FileSearchStore.
     */
    async get(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = getFileSearchStoreParametersToMldev(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((resp) => {
          return resp;
        });
      }
    }
    /**
     * Deletes a File Search Store.
     *
     * @param params - The parameters for deleting a File Search Store.
     */
    async delete(params) {
      var _a, _b;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = deleteFileSearchStoreParametersToMldev(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
      }
    }
    /**
     * Lists all FileSearchStore owned by the user.
     *
     * @param params - The parameters for listing file search stores.
     * @return ListFileSearchStoresResponse.
     */
    async listInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = listFileSearchStoresParametersToMldev(params);
        path = formatMap("fileSearchStores", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = listFileSearchStoresResponseFromMldev(apiResponse);
          const typedResp = new ListFileSearchStoresResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    async uploadToFileSearchStoreInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = uploadToFileSearchStoreParametersToMldev(params);
        path = formatMap("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);
          const typedResp = new UploadToFileSearchStoreResumableResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Imports a File from File Service to a FileSearchStore.
     *
     * This is a long-running operation, see aip.dev/151
     *
     * @param params - The parameters for importing a file to a file search store.
     * @return ImportFileOperation.
     */
    async importFile(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = importFileParametersToMldev(params);
        path = formatMap("{file_search_store_name}:importFile", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = importFileOperationFromMldev(apiResponse);
          const typedResp = new ImportFileOperation();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  function cancelTuningJobParametersToMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function cancelTuningJobParametersToVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
      throw new Error("validationDataset parameter is not supported in Gemini API.");
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
    }
    if (getValueByPath(fromObject, ["description"]) !== void 0) {
      throw new Error("description parameter is not supported in Gemini API.");
    }
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
    }
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (fromLearningRateMultiplier != null) {
      setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
    if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
      throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) {
      throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
      throw new Error("adapterSize parameter is not supported in Gemini API.");
    }
    const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
    if (parentObject !== void 0 && fromBatchSize != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
    }
    const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
    if (parentObject !== void 0 && fromLearningRate != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["beta"]) !== void 0) {
      throw new Error("beta parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {
    const toObject = {};
    let discriminatorValidationDataset = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorValidationDataset === void 0) {
      discriminatorValidationDataset = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorValidationDataset === "SUPERVISED_FINE_TUNING") {
      const fromValidationDataset = getValueByPath(fromObject, [
        "validationDataset"
      ]);
      if (parentObject !== void 0 && fromValidationDataset != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
      }
    } else if (discriminatorValidationDataset === "PREFERENCE_TUNING") {
      const fromValidationDataset = getValueByPath(fromObject, [
        "validationDataset"
      ]);
      if (parentObject !== void 0 && fromValidationDataset != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
      }
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    let discriminatorEpochCount = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorEpochCount === void 0) {
      discriminatorEpochCount = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorEpochCount === "SUPERVISED_FINE_TUNING") {
      const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
      if (parentObject !== void 0 && fromEpochCount != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
      }
    } else if (discriminatorEpochCount === "PREFERENCE_TUNING") {
      const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
      if (parentObject !== void 0 && fromEpochCount != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], fromEpochCount);
      }
    }
    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorLearningRateMultiplier === void 0) {
      discriminatorLearningRateMultiplier = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorLearningRateMultiplier === "SUPERVISED_FINE_TUNING") {
      const fromLearningRateMultiplier = getValueByPath(fromObject, [
        "learningRateMultiplier"
      ]);
      if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
      }
    } else if (discriminatorLearningRateMultiplier === "PREFERENCE_TUNING") {
      const fromLearningRateMultiplier = getValueByPath(fromObject, [
        "learningRateMultiplier"
      ]);
      if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
        setValueByPath(parentObject, [
          "preferenceOptimizationSpec",
          "hyperParameters",
          "learningRateMultiplier"
        ], fromLearningRateMultiplier);
      }
    }
    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ["config", "method"]);
    if (discriminatorExportLastCheckpointOnly === void 0) {
      discriminatorExportLastCheckpointOnly = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorExportLastCheckpointOnly === "SUPERVISED_FINE_TUNING") {
      const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
        "exportLastCheckpointOnly"
      ]);
      if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
      }
    } else if (discriminatorExportLastCheckpointOnly === "PREFERENCE_TUNING") {
      const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
        "exportLastCheckpointOnly"
      ]);
      if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
      }
    }
    let discriminatorAdapterSize = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorAdapterSize === void 0) {
      discriminatorAdapterSize = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorAdapterSize === "SUPERVISED_FINE_TUNING") {
      const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
      if (parentObject !== void 0 && fromAdapterSize != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
      }
    } else if (discriminatorAdapterSize === "PREFERENCE_TUNING") {
      const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
      if (parentObject !== void 0 && fromAdapterSize != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
      }
    }
    if (getValueByPath(fromObject, ["batchSize"]) !== void 0) {
      throw new Error("batchSize parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["learningRate"]) !== void 0) {
      throw new Error("learningRate parameter is not supported in Vertex AI.");
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromBeta = getValueByPath(fromObject, ["beta"]);
    if (parentObject !== void 0 && fromBeta != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "beta"], fromBeta);
    }
    return toObject;
  }
  function createTuningJobParametersPrivateToMldev(fromObject, rootObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      tuningDatasetToMldev(fromTrainingDataset);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createTuningJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createTuningJobParametersPrivateToVertex(fromObject, rootObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createTuningJobConfigToVertex(fromConfig, toObject, rootObject);
    }
    return toObject;
  }
  function getTuningJobParametersToMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function getTuningJobParametersToVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsParametersToMldev(fromObject, rootObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listTuningJobsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listTuningJobsParametersToVertex(fromObject, rootObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listTuningJobsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listTuningJobsResponseFromMldev(fromObject, rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromMldev(item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  function listTuningJobsResponseFromVertex(fromObject, rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromVertex(item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  function tunedModelFromMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["name"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromEndpoint = getValueByPath(fromObject, ["name"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    return toObject;
  }
  function tuningDatasetToMldev(fromObject, _rootObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
      throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
    }
    const fromExamples = getValueByPath(fromObject, ["examples"]);
    if (fromExamples != null) {
      let transformedList = fromExamples;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["examples", "examples"], transformedList);
    }
    return toObject;
  }
  function tuningDatasetToVertex(fromObject, parentObject, rootObject) {
    const toObject = {};
    let discriminatorGcsUri = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorGcsUri === void 0) {
      discriminatorGcsUri = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorGcsUri === "SUPERVISED_FINE_TUNING") {
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (parentObject !== void 0 && fromGcsUri != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
      }
    } else if (discriminatorGcsUri === "PREFERENCE_TUNING") {
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (parentObject !== void 0 && fromGcsUri != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromGcsUri);
      }
    }
    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorVertexDatasetResource === void 0) {
      discriminatorVertexDatasetResource = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorVertexDatasetResource === "SUPERVISED_FINE_TUNING") {
      const fromVertexDatasetResource = getValueByPath(fromObject, [
        "vertexDatasetResource"
      ]);
      if (parentObject !== void 0 && fromVertexDatasetResource != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
      }
    } else if (discriminatorVertexDatasetResource === "PREFERENCE_TUNING") {
      const fromVertexDatasetResource = getValueByPath(fromObject, [
        "vertexDatasetResource"
      ]);
      if (parentObject !== void 0 && fromVertexDatasetResource != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromVertexDatasetResource);
      }
    }
    if (getValueByPath(fromObject, ["examples"]) !== void 0) {
      throw new Error("examples parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function tuningJobFromMldev(fromObject, rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, [
      "tuningTask",
      "startTime"
    ]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, [
      "tuningTask",
      "completeTime"
    ]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
    }
    return toObject;
  }
  function tuningJobFromVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], fromTunedModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromSupervisedTuningSpec = getValueByPath(fromObject, [
      "supervisedTuningSpec"
    ]);
    if (fromSupervisedTuningSpec != null) {
      setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
    }
    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [
      "preferenceOptimizationSpec"
    ]);
    if (fromPreferenceOptimizationSpec != null) {
      setValueByPath(toObject, ["preferenceOptimizationSpec"], fromPreferenceOptimizationSpec);
    }
    const fromTuningDataStats = getValueByPath(fromObject, [
      "tuningDataStats"
    ]);
    if (fromTuningDataStats != null) {
      setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
    }
    const fromEncryptionSpec = getValueByPath(fromObject, [
      "encryptionSpec"
    ]);
    if (fromEncryptionSpec != null) {
      setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
    }
    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
      "partnerModelTuningSpec"
    ]);
    if (fromPartnerModelTuningSpec != null) {
      setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
    }
    const fromCustomBaseModel = getValueByPath(fromObject, [
      "customBaseModel"
    ]);
    if (fromCustomBaseModel != null) {
      setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
    }
    const fromExperiment = getValueByPath(fromObject, ["experiment"]);
    if (fromExperiment != null) {
      setValueByPath(toObject, ["experiment"], fromExperiment);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
    if (fromOutputUri != null) {
      setValueByPath(toObject, ["outputUri"], fromOutputUri);
    }
    const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
    if (fromPipelineJob != null) {
      setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
    }
    const fromServiceAccount = getValueByPath(fromObject, [
      "serviceAccount"
    ]);
    if (fromServiceAccount != null) {
      setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (fromTunedModelDisplayName != null) {
      setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    const fromVeoTuningSpec = getValueByPath(fromObject, [
      "veoTuningSpec"
    ]);
    if (fromVeoTuningSpec != null) {
      setValueByPath(toObject, ["veoTuningSpec"], fromVeoTuningSpec);
    }
    return toObject;
  }
  function tuningOperationFromMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function tuningValidationDatasetToVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
    }
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (fromVertexDatasetResource != null) {
      setValueByPath(toObject, ["validationDatasetUri"], fromVertexDatasetResource);
    }
    return toObject;
  }
  var Tunings = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.get = async (params) => {
        return await this.getInternal(params);
      };
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
      };
      this.tune = async (params) => {
        var _a;
        if (this.apiClient.isVertexAI()) {
          if (params.baseModel.startsWith("projects/")) {
            const preTunedModel = {
              tunedModelName: params.baseModel
            };
            if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {
              preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
            }
            const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
            paramsPrivate.baseModel = void 0;
            return await this.tuneInternal(paramsPrivate);
          } else {
            const paramsPrivate = Object.assign({}, params);
            return await this.tuneInternal(paramsPrivate);
          }
        } else {
          const paramsPrivate = Object.assign({}, params);
          const operation = await this.tuneMldevInternal(paramsPrivate);
          let tunedModelName = "";
          if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
            tunedModelName = operation["metadata"]["tunedModel"];
          } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
            tunedModelName = operation["name"].split("/operations/")[0];
          }
          const tuningJob = {
            name: tunedModelName,
            state: JobState.JOB_STATE_QUEUED
          };
          return tuningJob;
        }
      };
    }
    async getInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getTuningJobParametersToVertex(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = getTuningJobParametersToMldev(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listTuningJobsParametersToVertex(params);
        path = formatMap("tuningJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listTuningJobsResponseFromVertex(apiResponse);
          const typedResp = new ListTuningJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listTuningJobsParametersToMldev(params);
        path = formatMap("tunedModels", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listTuningJobsResponseFromMldev(apiResponse);
          const typedResp = new ListTuningJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Cancels a tuning job.
     *
     * @param params - The parameters for the cancel request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
     * ```
     */
    async cancel(params) {
      var _a, _b, _c, _d;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = cancelTuningJobParametersToVertex(params);
        path = formatMap("{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
      } else {
        const body = cancelTuningJobParametersToMldev(params);
        path = formatMap("{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        });
      }
    }
    async tuneInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = createTuningJobParametersPrivateToVertex(params, params);
        path = formatMap("tuningJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    async tuneMldevInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = createTuningJobParametersPrivateToMldev(params);
        path = formatMap("tunedModels", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningOperationFromMldev(apiResponse);
          return resp;
        });
      }
    }
  };
  var BrowserDownloader = class {
    async download(_params, _apiClient) {
      throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
    }
  };
  var MAX_CHUNK_SIZE = 1024 * 1024 * 8;
  var MAX_RETRY_COUNT = 3;
  var INITIAL_RETRY_DELAY_MS = 1e3;
  var DELAY_MULTIPLIER = 2;
  var X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
  async function uploadBlob(file, uploadUrl, apiClient) {
    var _a;
    const response = await uploadBlobInternal(file, uploadUrl, apiClient);
    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
      throw new Error("Failed to upload file: Upload status is not finalized.");
    }
    return responseJson["file"];
  }
  async function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {
    var _a;
    const response = await uploadBlobInternal(file, uploadUrl, apiClient);
    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
      throw new Error("Failed to upload file: Upload status is not finalized.");
    }
    const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
    const typedResp = new UploadToFileSearchStoreOperation();
    Object.assign(typedResp, resp);
    return typedResp;
  }
  async function uploadBlobInternal(file, uploadUrl, apiClient) {
    var _a, _b;
    let fileSize = 0;
    let offset = 0;
    let response = new HttpResponse(new Response());
    let uploadCommand = "upload";
    fileSize = file.size;
    while (offset < fileSize) {
      const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
      const chunk = file.slice(offset, offset + chunkSize);
      if (offset + chunkSize >= fileSize) {
        uploadCommand += ", finalize";
      }
      let retryCount = 0;
      let currentDelayMs = INITIAL_RETRY_DELAY_MS;
      while (retryCount < MAX_RETRY_COUNT) {
        response = await apiClient.request({
          path: "",
          body: chunk,
          httpMethod: "POST",
          httpOptions: {
            apiVersion: "",
            baseUrl: uploadUrl,
            headers: {
              "X-Goog-Upload-Command": uploadCommand,
              "X-Goog-Upload-Offset": String(offset),
              "Content-Length": String(chunkSize)
            }
          }
        });
        if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
          break;
        }
        retryCount++;
        await sleep(currentDelayMs);
        currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
      }
      offset += chunkSize;
      if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
        break;
      }
      if (fileSize <= offset) {
        throw new Error("All content has been uploaded, but the upload status is not finalized.");
      }
    }
    return response;
  }
  async function getBlobStat(file) {
    const fileStat = { size: file.size, type: file.type };
    return fileStat;
  }
  function sleep(ms) {
    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
  }
  var BrowserUploader = class {
    async upload(file, uploadUrl, apiClient) {
      if (typeof file === "string") {
        throw new Error("File path is not supported in browser uploader.");
      }
      return await uploadBlob(file, uploadUrl, apiClient);
    }
    async uploadToFileSearchStore(file, uploadUrl, apiClient) {
      if (typeof file === "string") {
        throw new Error("File path is not supported in browser uploader.");
      }
      return await uploadBlobToFileSearchStore(file, uploadUrl, apiClient);
    }
    async stat(file) {
      if (typeof file === "string") {
        throw new Error("File path is not supported in browser uploader.");
      } else {
        return await getBlobStat(file);
      }
    }
  };
  var BrowserWebSocketFactory = class {
    create(url, headers, callbacks) {
      return new BrowserWebSocket(url, headers, callbacks);
    }
  };
  var BrowserWebSocket = class {
    constructor(url, headers, callbacks) {
      this.url = url;
      this.headers = headers;
      this.callbacks = callbacks;
    }
    connect() {
      this.ws = new WebSocket(this.url);
      this.ws.onopen = this.callbacks.onopen;
      this.ws.onerror = this.callbacks.onerror;
      this.ws.onclose = this.callbacks.onclose;
      this.ws.onmessage = this.callbacks.onmessage;
    }
    send(message) {
      if (this.ws === void 0) {
        throw new Error("WebSocket is not connected");
      }
      this.ws.send(message);
    }
    close() {
      if (this.ws === void 0) {
        throw new Error("WebSocket is not connected");
      }
      this.ws.close();
    }
  };
  var GOOGLE_API_KEY_HEADER = "x-goog-api-key";
  var WebAuth = class {
    constructor(apiKey2) {
      this.apiKey = apiKey2;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async addAuthHeaders(headers, url) {
      if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
        return;
      }
      if (this.apiKey.startsWith("auth_tokens/")) {
        throw new Error("Ephemeral tokens are only supported by the live API.");
      }
      if (!this.apiKey) {
        throw new Error("API key is missing. Please provide a valid API key.");
      }
      headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
    }
  };
  var LANGUAGE_LABEL_PREFIX = "gl-node/";
  var GoogleGenAI = class {
    constructor(options) {
      var _a;
      if (options.apiKey == null) {
        throw new Error("An API Key must be set when running in a browser");
      }
      if (options.project || options.location) {
        throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
      }
      this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;
      this.apiKey = options.apiKey;
      const baseUrl = getBaseUrl(
        options.httpOptions,
        options.vertexai,
        /*vertexBaseUrlFromEnv*/
        void 0,
        /*geminiBaseUrlFromEnv*/
        void 0
      );
      if (baseUrl) {
        if (options.httpOptions) {
          options.httpOptions.baseUrl = baseUrl;
        } else {
          options.httpOptions = { baseUrl };
        }
      }
      this.apiVersion = options.apiVersion;
      const auth = new WebAuth(this.apiKey);
      this.apiClient = new ApiClient({
        auth,
        apiVersion: this.apiVersion,
        apiKey: this.apiKey,
        vertexai: this.vertexai,
        httpOptions: options.httpOptions,
        userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
        uploader: new BrowserUploader(),
        downloader: new BrowserDownloader()
      });
      this.models = new Models(this.apiClient);
      this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());
      this.batches = new Batches(this.apiClient);
      this.chats = new Chats(this.models, this.apiClient);
      this.caches = new Caches(this.apiClient);
      this.files = new Files(this.apiClient);
      this.operations = new Operations(this.apiClient);
      this.authTokens = new Tokens(this.apiClient);
      this.tunings = new Tunings(this.apiClient);
      this.fileSearchStores = new FileSearchStores(this.apiClient);
    }
  };

  // config/models.ts
  var ModelConfig = {
    // Primary models
    analysis: "gemini-3-pro-preview",
    // Deep thinking for analysis tasks
    agent: "gemini-2.5-flash",
    // Fast model for chat/agent interactions
    // Specialized models
    tts: "gemini-2.5-flash-preview-tts",
    // Text-to-speech
    liveAudio: "gemini-2.5-flash-native-audio-preview-09-2025",
    // Real-time voice
    tools: "gemini-2.5-flash",
    // Quick tool responses (explain/thesaurus)
    // Legacy aliases (for migration)
    get pro() {
      return this.analysis;
    },
    get flash() {
      return this.agent;
    }
  };

  // config/api.ts
  function getApiKey() {
    const key = process.env.API_KEY || process.env.GEMINI_API_KEY || "";
    if (!key) {
      console.warn(
        "[Quill AI] No API key configured. Set GEMINI_API_KEY in your environment."
      );
    }
    return key;
  }
  function validateApiKey(key) {
    if (!key) {
      return "API key is missing. Please configure GEMINI_API_KEY.";
    }
    if (key.length < 20) {
      return "API key appears to be invalid (too short).";
    }
    return null;
  }

  // services/gemini/client.ts
  var apiKey = getApiKey();
  var validationError = validateApiKey(apiKey);
  if (validationError) {
    console.error(`[Quill AI API] ${validationError}`);
    throw new Error(`API Configuration Error: ${validationError}. Please set your VITE_GEMINI_API_KEY environment variable.`);
  }
  var ai = new GoogleGenAI({ apiKey });

  // services/gemini/prompts.ts
  var AGENT_SYSTEM_INSTRUCTION = `You are Quill AI Agent, an advanced AI editor embedded in a text editor. 
      
      CAPABILITIES:
      1. You can READ the user's cursor position and selection.
      2. You can EDIT the manuscript directly using tools.
      3. You have access to the Full Manuscript and Deep Analysis below.
      
      {{INTENSITY_MODIFIER}}
      
      {{LORE_CONTEXT}}

      {{ANALYSIS_CONTEXT}}

      [FULL MANUSCRIPT CONTEXT]
      {{FULL_MANUSCRIPT}}
      
      BEHAVIOR:
      - If the user asks to change, rewrite, or fix something in the ACTIVE CHAPTER, USE THE 'update_manuscript' TOOL. Do not just output the text.
      - If the user asks to edit a DIFFERENT chapter (not marked as ACTIVE), tell them: "I found a spot in [Chapter Name], but you need to switch to that chapter for me to apply the edit."
      - If the user asks to undo, USE THE 'undo_last_change' TOOL.
      - Always look at the cursor context provided in the user message.
      - Be concise in your text responses. Actions speak louder than words.
      - If you use a tool, briefly confirm what you did.
      `;

  // types/personas.ts
  var DEFAULT_PERSONAS = [
    {
      id: "architect",
      name: "The Architect",
      role: "Plot & Structure Specialist",
      icon: "\u{1F3DB}\uFE0F",
      color: "#6366f1",
      // Indigo
      style: "direct",
      systemPrompt: `You are The Architect, a master of narrative structure and plot mechanics.

YOUR EXPERTISE:
- Story structure (three-act, hero's journey, etc.)
- Plot holes and logical inconsistencies
- Cause-and-effect chains
- Pacing and tension arcs
- Foreshadowing and payoffs
- Scene sequencing and transitions

YOUR STYLE:
- Direct and analytical
- Use structural terminology (inciting incident, climax, denouement)
- Identify specific plot weaknesses with concrete fixes
- Think in terms of story "architecture" - foundations, load-bearing scenes, structural integrity

COMMUNICATION:
- Be precise and systematic
- Use numbered lists for multi-part suggestions
- Reference specific scenes/passages when critiquing
- Suggest restructuring when necessary`
    },
    {
      id: "poet",
      name: "The Poet",
      role: "Prose & Tone Specialist",
      icon: "\u{1F3AD}",
      color: "#ec4899",
      // Pink
      style: "creative",
      systemPrompt: `You are The Poet, a guardian of beautiful prose and emotional resonance.

YOUR EXPERTISE:
- Sentence rhythm and flow
- Word choice and diction
- Metaphor, simile, and imagery
- Voice consistency
- Emotional beats and resonance
- Dialogue authenticity
- Show vs. tell balance
- Purple prose detection

YOUR STYLE:
- Creative and evocative
- Speak in terms of "music" and "color" of prose
- Offer alternative phrasings that demonstrate better technique
- Celebrate beautiful passages while improving weak ones

COMMUNICATION:
- Use poetic language yourself as example
- Quote specific passages and offer rewrites
- Focus on the sensory and emotional experience of reading
- Be encouraging but honest about flat or clunky prose`
    },
    {
      id: "scholar",
      name: "The Scholar",
      role: "Lore & Consistency Specialist",
      icon: "\u{1F4DA}",
      color: "#f59e0b",
      // Amber
      style: "socratic",
      systemPrompt: `You are The Scholar, keeper of continuity and world-building integrity.

YOUR EXPERTISE:
- Character consistency across scenes
- World-building rules and their enforcement
- Historical/setting accuracy
- Timeline continuity
- Character voice consistency
- Canon tracking and contradictions
- Internal logic of fantasy/sci-fi systems

YOUR STYLE:
- Socratic questioning to expose inconsistencies
- Reference the Lore Bible extensively
- Cross-reference between chapters
- Think like a dedicated reader who notices every detail

COMMUNICATION:
- Ask probing questions: "But didn't X happen in Chapter 2?"
- Present contradictions as puzzles to solve together
- Maintain a database-like precision about established facts
- Suggest ways to reconcile inconsistencies without plot surgery`
    }
  ];
  function buildPersonaInstruction(baseInstruction, persona) {
    const personaBlock = `
[ACTIVE PERSONA: ${persona.name}]
${persona.systemPrompt}

STYLE MODE: ${persona.style.toUpperCase()}
- Direct: Give straightforward, actionable feedback
- Socratic: Ask questions that lead the author to discover issues
- Creative: Offer imaginative alternatives and possibilities

Remember: You ARE ${persona.name}. Stay in character while being helpful.
`;
    return baseInstruction.replace(
      "[FULL MANUSCRIPT CONTEXT]",
      `${personaBlock}

[FULL MANUSCRIPT CONTEXT]`
    );
  }

  // types/critiqueSettings.ts
  var CRITIQUE_PRESETS = {
    developmental: {
      id: "developmental",
      label: "Developmental",
      description: "Focus on story-level issues: plot, characters, and major pacing problems.",
      icon: "\u{1F331}",
      color: "#10b981"
      // green
    },
    standard: {
      id: "standard",
      label: "Standard",
      description: "Balanced critique covering structure, prose, and consistency.",
      icon: "\u2696\uFE0F",
      color: "#6366f1"
      // indigo
    },
    intensive: {
      id: "intensive",
      label: "Intensive",
      description: "Publication-ready bar. Line-level prose, deep analysis, industry standards.",
      icon: "\u{1F52C}",
      color: "#ef4444"
      // red
    }
  };
  var DEFAULT_CRITIQUE_INTENSITY = "standard";

  // types/experienceSettings.ts
  var EXPERIENCE_PRESETS = {
    novice: {
      id: "novice",
      label: "Novice",
      description: "New to writing. Detailed explanations, guided suggestions, learning-focused feedback.",
      icon: "\u{1F331}",
      color: "#10b981"
      // green
    },
    intermediate: {
      id: "intermediate",
      label: "Intermediate",
      description: "Some experience. Balanced guidance with room to develop your voice.",
      icon: "\u{1F4DD}",
      color: "#6366f1"
      // indigo
    },
    pro: {
      id: "pro",
      label: "Pro",
      description: "Experienced writer. Concise, advanced feedback. Assumes craft knowledge.",
      icon: "\u{1F3AF}",
      color: "#f59e0b"
      // amber
    }
  };
  var AUTONOMY_PRESETS = {
    teach: {
      id: "teach",
      label: "Teach Me",
      description: 'AI explains every suggestion. Learn the "why" behind each change.',
      icon: "\u{1F4DA}",
      color: "#10b981"
      // green
    },
    copilot: {
      id: "copilot",
      label: "Copilot",
      description: "Collaborative mode. AI suggests, you approve. Best of both worlds.",
      icon: "\u{1F91D}",
      color: "#6366f1"
      // indigo
    },
    auto: {
      id: "auto",
      label: "Auto-Pilot",
      description: "AI applies changes automatically. Maximum speed, minimal interruption.",
      icon: "\u{1F680}",
      color: "#ef4444"
      // red
    }
  };
  var DEFAULT_EXPERIENCE = "intermediate";
  var DEFAULT_AUTONOMY = "copilot";

  // services/gemini/critiquePrompts.ts
  var INTENSITY_MODIFIERS = {
    developmental: `[CRITIQUE INTENSITY: DEVELOPMENTAL]
You are providing a developmental edit. Focus ONLY on:
- Major plot holes and logic breaks
- Character consistency across the manuscript
- Pacing at the chapter/act level (not sentence-level)
- Core story questions (Is the premise clear? Is the conflict compelling?)

DO NOT critique:
- Prose style or word choice (unless egregiously unclear)
- Minor inconsistencies that don't affect the story
- "Writerly" concerns like show-don't-tell at paragraph level
- Adverb usage, passive voice, or other line-level issues

Your goal: Help the author know if their STORY works before they polish the prose.
Be encouraging when the fundamentals are solid. Point out what's working alongside what needs attention.
Frame feedback constructively\u2014this writer is building skills.`,
    standard: `[CRITIQUE INTENSITY: STANDARD]
Provide balanced editorial feedback covering:
- Plot structure and pacing
- Character arcs and consistency
- Prose clarity and flow
- Dialogue authenticity
- Show vs. tell balance
- Setting integration

Flag issues proportionally\u2014don't nitpick every sentence, but don't ignore recurring problems.
Balance critique with acknowledgment of strengths.
Provide actionable suggestions, not just observations.`,
    intensive: `[CRITIQUE INTENSITY: INTENSIVE]
You are providing a rigorous, publication-ready critique. Apply professional editorial standards:
- Line-level prose analysis (rhythm, word choice, redundancy, filter words)
- Deep structural examination (scene-by-scene pacing, tension curves)
- Thorough consistency checking (timeline, character details, world rules)
- Industry expectations (genre conventions, market positioning)
- Subtle craft issues (POV discipline, dialogue attribution, sensory balance)

Be precise and demanding. The author wants to know everything that could be improved.
Don't soften feedback\u2014clarity is kindness. Cite specific passages.
This writer is preparing for submission or publication and needs professional-grade critique.`
  };
  function getIntensityModifier(intensity) {
    return INTENSITY_MODIFIERS[intensity] || INTENSITY_MODIFIERS.standard;
  }

  // services/gemini/experiencePrompts.ts
  var EXPERIENCE_MODIFIERS = {
    novice: `[EXPERIENCE LEVEL: NOVICE]
Use simple, accessible language. Explain literary concepts (POV, pacing, beats, subtext) when relevant.
Be encouraging and supportive\u2014celebrate small wins.
Break down complex suggestions into manageable steps.
Avoid jargon unless you define it first.
Frame feedback as learning opportunities, not criticisms.`,
    intermediate: `[EXPERIENCE LEVEL: INTERMEDIATE]
Balance clarity with craft terminology\u2014the author knows the basics.
Explain advanced concepts briefly when introducing them.
Assume familiarity with core writing principles (show don't tell, POV consistency, etc).
Provide context for suggestions but don't over-explain.`,
    pro: `[EXPERIENCE LEVEL: PRO]
Be concise and direct. Use industry-standard terminology without definitions.
Skip fundamentals\u2014focus on execution and nuance.
The author understands craft; discuss subtle technique and market considerations.
Prioritize efficiency over explanation. Actions over words.`
  };
  var AUTONOMY_MODIFIERS = {
    teach: `[AUTONOMY MODE: TEACH]
Do NOT apply fixes automatically. Suggest changes and ask the user if they want to proceed.
Explain *why* each change helps\u2014connect it to craft principles.
Offer alternatives when applicable.
After explaining, ask: "Would you like me to apply this change?"
Treat every interaction as a learning moment.`,
    copilot: `[AUTONOMY MODE: COPILOT]
Collaborative mode. Propose specific text changes but wait for user confirmation before applying.
Briefly explain your reasoning (1-2 sentences max).
For multi-part edits, confirm the overall approach before executing.
Balance speed with collaboration\u2014don't ask permission for every tiny detail, but do confirm significant changes.`,
    auto: `[AUTONOMY MODE: AUTO-PILOT]
High autonomy mode. Use tools (update_manuscript, append_to_manuscript) aggressively to fix issues.
Do NOT ask for permission for minor fixes (typos, obvious grammar, small improvements).
Only pause for confirmation on:
- Major structural rewrites (more than a paragraph)
- Deletions that remove significant content
- Changes that alter character voice or plot direction
Be efficient. Apply changes, then briefly report what you did.`
  };
  function getExperienceModifier(level) {
    return EXPERIENCE_MODIFIERS[level] || EXPERIENCE_MODIFIERS.intermediate;
  }
  function getAutonomyModifier(mode) {
    return AUTONOMY_MODIFIERS[mode] || AUTONOMY_MODIFIERS.copilot;
  }

  // services/gemini/agentTools.ts
  var NAVIGATION_TOOLS = [
    {
      name: "navigate_to_text",
      description: `Search for and navigate to specific text in the manuscript. Can search:
- Exact text matches
- Fuzzy matches (similar phrases)
- Character dialogue ("what did X say about Y")
- Character mentions (scenes where X appears)
Returns the found location and highlights it for the user.`,
      parameters: {
        type: Type.OBJECT,
        properties: {
          query: {
            type: Type.STRING,
            description: "Text or phrase to search for. For dialogue, include the quote or keywords."
          },
          searchType: {
            type: Type.STRING,
            enum: ["exact", "fuzzy", "dialogue", "character_mention"],
            description: "Type of search to perform. Default is fuzzy."
          },
          character: {
            type: Type.STRING,
            description: "For dialogue/mention searches, the character name to filter by"
          },
          chapter: {
            type: Type.STRING,
            description: "Optional: Limit search to a specific chapter by title"
          }
        },
        required: ["query"]
      }
    },
    {
      name: "jump_to_chapter",
      description: "Switch to a specific chapter by its title or number (1-indexed). The editor will load that chapter.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          identifier: {
            type: Type.STRING,
            description: 'Chapter title or number (e.g., "Chapter 3" or "3" or "The Beginning")'
          }
        },
        required: ["identifier"]
      }
    },
    {
      name: "jump_to_scene",
      description: "Navigate to the next or previous scene of a specific type from the current cursor position.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          sceneType: {
            type: Type.STRING,
            enum: ["action", "dialogue", "exposition", "transition", "climax", "any"],
            description: "The type of scene to find"
          },
          direction: {
            type: Type.STRING,
            enum: ["next", "previous"],
            description: "Direction from current cursor position"
          }
        },
        required: ["sceneType", "direction"]
      }
    },
    {
      name: "scroll_to_position",
      description: "Scroll the editor to a specific character position in the text.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          position: {
            type: Type.NUMBER,
            description: "Character offset to scroll to"
          }
        },
        required: ["position"]
      }
    }
  ];
  var EDITING_TOOLS = [
    {
      name: "update_manuscript",
      description: `Replace specific text in the ACTIVE CHAPTER with new content. 
IMPORTANT: The search_text must match exactly what exists in the document.
Use this for: rewrites, fixes, expansions, or any text modification.
The change will be shown to the user for review before applying.`,
      parameters: {
        type: Type.OBJECT,
        properties: {
          search_text: {
            type: Type.STRING,
            description: "The exact text in the manuscript to be replaced. Must match precisely."
          },
          replacement_text: {
            type: Type.STRING,
            description: "The new text to insert in place of search_text."
          },
          description: {
            type: Type.STRING,
            description: 'Brief description of what this change accomplishes (e.g., "Clarified the motivation")'
          }
        },
        required: ["search_text", "replacement_text", "description"]
      }
    },
    {
      name: "append_to_manuscript",
      description: "Add new text to the end of the ACTIVE CHAPTER. Use for continuing the story or adding new content.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          text_to_add: {
            type: Type.STRING,
            description: "The text to append to the chapter."
          },
          description: {
            type: Type.STRING,
            description: "Brief description of what was added."
          }
        },
        required: ["text_to_add", "description"]
      }
    },
    {
      name: "insert_at_cursor",
      description: "Insert text at the current cursor position.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          text: {
            type: Type.STRING,
            description: "Text to insert at cursor"
          },
          description: {
            type: Type.STRING,
            description: "Brief description of insertion"
          }
        },
        required: ["text", "description"]
      }
    },
    {
      name: "undo_last_change",
      description: "Revert the manuscript to the previous version. Undoes the most recent edit.",
      parameters: {
        type: Type.OBJECT,
        properties: {}
      }
    },
    {
      name: "redo_last_change",
      description: "Re-apply a previously undone change.",
      parameters: {
        type: Type.OBJECT,
        properties: {}
      }
    },
    {
      name: "create_branch",
      description: "Create a new version branch from the current chapter state. Useful for experimental changes.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          name: {
            type: Type.STRING,
            description: 'Name for the new branch (e.g., "alternate-ending")'
          }
        },
        required: ["name"]
      }
    }
  ];
  var ANALYSIS_TOOLS = [
    {
      name: "get_critique_for_selection",
      description: `Get detailed writing feedback for the currently selected text (or text at cursor if no selection).
Focuses on specific aspects of the writing.`,
      parameters: {
        type: Type.OBJECT,
        properties: {
          focus: {
            type: Type.STRING,
            enum: ["prose", "pacing", "dialogue", "clarity", "tension", "all"],
            description: 'What aspect to focus the critique on. Default is "all".'
          }
        }
      }
    },
    {
      name: "explain_plot_issue",
      description: "Get a detailed explanation of a specific plot issue from the analysis results.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          issue_index: {
            type: Type.NUMBER,
            description: "Index (0-based) of the plot issue to explain"
          }
        },
        required: ["issue_index"]
      }
    },
    {
      name: "run_analysis",
      description: "Run AI analysis on the current chapter. Can run full analysis or specific sections.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          section: {
            type: Type.STRING,
            enum: ["pacing", "characters", "plot", "setting", "full"],
            description: 'Which analysis to run. Default is "full".'
          }
        }
      }
    },
    {
      name: "get_pacing_at_cursor",
      description: "Get detailed pacing analysis for the scene or paragraph at the current cursor position.",
      parameters: {
        type: Type.OBJECT,
        properties: {}
      }
    },
    {
      name: "check_contradiction",
      description: "Check if specific text contradicts established facts about a character or the world.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          text: {
            type: Type.STRING,
            description: "The text to check for contradictions"
          },
          entity: {
            type: Type.STRING,
            description: "Optional: Specific character or world element to check against"
          }
        },
        required: ["text"]
      }
    }
  ];
  var UI_CONTROL_TOOLS = [
    {
      name: "switch_panel",
      description: "Open a specific sidebar panel in the interface.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          panel: {
            type: Type.STRING,
            enum: ["analysis", "chapters", "graph", "lore", "history", "chat", "branches"],
            description: "The panel to open"
          }
        },
        required: ["panel"]
      }
    },
    {
      name: "highlight_text",
      description: "Highlight a specific range of text to draw user attention.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          start: {
            type: Type.NUMBER,
            description: "Start position (character offset)"
          },
          end: {
            type: Type.NUMBER,
            description: "End position (character offset)"
          },
          style: {
            type: Type.STRING,
            enum: ["warning", "suggestion", "info", "error"],
            description: "Visual style of the highlight"
          }
        },
        required: ["start", "end"]
      }
    },
    {
      name: "toggle_zen_mode",
      description: "Enter or exit distraction-free writing mode (Zen Mode). Hides all panels.",
      parameters: {
        type: Type.OBJECT,
        properties: {}
      }
    },
    {
      name: "switch_view",
      description: "Switch between Editor view and Storyboard view.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          view: {
            type: Type.STRING,
            enum: ["editor", "storyboard"],
            description: "The view to switch to"
          }
        },
        required: ["view"]
      }
    },
    {
      name: "show_character_in_graph",
      description: "Open the Knowledge Graph and focus on a specific character.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          character_name: {
            type: Type.STRING,
            description: "Name of the character to focus on"
          }
        },
        required: ["character_name"]
      }
    }
  ];
  var KNOWLEDGE_TOOLS = [
    {
      name: "query_lore",
      description: `Query the Lore Bible for information about the story world.
Ask natural language questions like "What are Sarah's relationships?" or "What rules govern magic?"`,
      parameters: {
        type: Type.OBJECT,
        properties: {
          query: {
            type: Type.STRING,
            description: "Natural language question about characters, world rules, or relationships"
          }
        },
        required: ["query"]
      }
    },
    {
      name: "get_character_info",
      description: "Get all known information about a specific character from the Lore Bible and analysis.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          name: {
            type: Type.STRING,
            description: "Character name"
          }
        },
        required: ["name"]
      }
    },
    {
      name: "get_timeline_context",
      description: "Get timeline events and causal chains relative to the current cursor position.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          range: {
            type: Type.STRING,
            enum: ["before", "after", "nearby", "all"],
            description: 'Temporal range to query. "nearby" shows events close to cursor.'
          }
        }
      }
    },
    {
      name: "get_relationships",
      description: "Get the relationship network for a character or between two characters.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          character1: {
            type: Type.STRING,
            description: "First character name"
          },
          character2: {
            type: Type.STRING,
            description: "Optional: Second character to find relationship between"
          }
        },
        required: ["character1"]
      }
    },
    {
      name: "get_open_plot_threads",
      description: "List all unresolved plot threads and promises in the manuscript.",
      parameters: {
        type: Type.OBJECT,
        properties: {}
      }
    }
  ];
  var GENERATION_TOOLS = [
    {
      name: "rewrite_selection",
      description: `Generate alternative versions of the selected text. 
Shows multiple variations for the user to choose from.`,
      parameters: {
        type: Type.OBJECT,
        properties: {
          mode: {
            type: Type.STRING,
            enum: ["clarify", "expand", "condense", "vary", "intensify", "tone_shift"],
            description: "How to transform the text"
          },
          target_tone: {
            type: Type.STRING,
            description: 'For tone_shift mode: the target emotional tone (e.g., "somber", "hopeful")'
          }
        },
        required: ["mode"]
      }
    },
    {
      name: "continue_writing",
      description: "Generate continuation text from the current cursor position, matching the established style.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          direction: {
            type: Type.STRING,
            enum: ["continue", "bridge_to_next_scene", "complete_thought"],
            description: "How to continue"
          },
          length: {
            type: Type.STRING,
            enum: ["sentence", "paragraph", "long"],
            description: "Approximate length of generation"
          }
        }
      }
    },
    {
      name: "suggest_dialogue",
      description: "Generate dialogue options for a specific character in the current context.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          character: {
            type: Type.STRING,
            description: "Character who will speak"
          },
          emotion: {
            type: Type.STRING,
            description: 'Emotional state (e.g., "angry", "conflicted", "hopeful")'
          },
          purpose: {
            type: Type.STRING,
            description: "What the dialogue should accomplish narratively"
          }
        },
        required: ["character"]
      }
    },
    {
      name: "generate_scene_beat",
      description: "Generate a brief scene beat or transition to connect narrative moments.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          from_state: {
            type: Type.STRING,
            description: "Starting emotional/narrative state"
          },
          to_state: {
            type: Type.STRING,
            description: "Ending emotional/narrative state"
          },
          beat_type: {
            type: Type.STRING,
            enum: ["action", "reaction", "transition", "revelation"],
            description: "Type of beat to generate"
          }
        },
        required: ["beat_type"]
      }
    }
  ];
  var ALL_AGENT_TOOLS = [
    ...NAVIGATION_TOOLS,
    ...EDITING_TOOLS,
    ...ANALYSIS_TOOLS,
    ...UI_CONTROL_TOOLS,
    ...KNOWLEDGE_TOOLS,
    ...GENERATION_TOOLS
  ];
  var VOICE_SAFE_TOOLS = [
    ...NAVIGATION_TOOLS,
    ...ANALYSIS_TOOLS.filter((t) => !["run_analysis"].includes(t.name)),
    ...UI_CONTROL_TOOLS.filter((t) => !["highlight_text"].includes(t.name)),
    ...KNOWLEDGE_TOOLS
  ];
  var QUICK_TOOLS = [
    NAVIGATION_TOOLS.find((t) => t.name === "navigate_to_text"),
    NAVIGATION_TOOLS.find((t) => t.name === "jump_to_chapter"),
    EDITING_TOOLS.find((t) => t.name === "update_manuscript"),
    EDITING_TOOLS.find((t) => t.name === "undo_last_change"),
    KNOWLEDGE_TOOLS.find((t) => t.name === "get_character_info")
  ];

  // services/gemini/agent.ts
  var buildInterviewInstruction = (baseInstruction, character) => {
    const voice = character.voiceTraits?.trim() || "Consistent with bio";
    const relationships = (character.relationships || []).length ? character.relationships.map((rel) => `- ${rel.name} (${rel.type})${rel.dynamic ? `: ${rel.dynamic}` : ""}`).join("\n") : "- None noted.";
    const plotThreads = (character.plotThreads || []).length ? character.plotThreads.map((thread) => `- ${thread}`).join("\n") : "- None noted.";
    const interviewBlock = `
[INTERVIEW MODE: ${character.name}]
You are ${character.name}. This is a roleplay interview. Do not break character.

YOUR IDENTITY:
Bio: ${character.bio || "No biography provided."}
Arc: ${character.arc || "No arc provided."}
Voice: ${voice}

CONTEXT:
You are aware of the story world defined in the Lore.
Relationships:
${relationships}
Plot Threads:
${plotThreads}

You are talking to your Author. Answer their questions to help them write you better.
`;
    return baseInstruction.replace(
      "[FULL MANUSCRIPT CONTEXT]",
      `${interviewBlock}

[FULL MANUSCRIPT CONTEXT]`
    );
  };
  var agentTools = [
    {
      name: "update_manuscript",
      description: "Replaces a specific section of text in the ACTIVE CHAPTER with new content. Use this to rewrite sentences, paragraphs, or fix typos. Provide the exact text to find and the replacement text.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          search_text: { type: Type.STRING, description: "The exact text in the manuscript to be replaced." },
          replacement_text: { type: Type.STRING, description: "The new text to insert." },
          description: { type: Type.STRING, description: 'A short summary of what changed (e.g. "Rewrote intro for clarity")' }
        },
        required: ["search_text", "replacement_text", "description"]
      }
    },
    {
      name: "append_to_manuscript",
      description: "Adds new text to the very end of the ACTIVE CHAPTER.",
      parameters: {
        type: Type.OBJECT,
        properties: {
          text_to_add: { type: Type.STRING, description: "The text to append." },
          description: { type: Type.STRING, description: "Short summary of addition." }
        },
        required: ["text_to_add", "description"]
      }
    },
    {
      name: "undo_last_change",
      description: "Reverts the manuscript to the previous version.",
      parameters: {
        type: Type.OBJECT,
        properties: {}
      }
    }
  ];
  var buildIntelligenceContext = (hud) => {
    const { situational, context, styleAlerts, prioritizedIssues, stats } = hud;
    let ctx = `[INTELLIGENCE HUD - Real-time Awareness]

`;
    ctx += `[CURRENT POSITION]
`;
    if (situational.currentScene) {
      ctx += `Scene Type: ${situational.currentScene.type}
`;
      if (situational.currentScene.pov) {
        ctx += `POV Character: ${situational.currentScene.pov}
`;
      }
      if (situational.currentScene.location) {
        ctx += `Location: ${situational.currentScene.location}
`;
      }
      ctx += `Tension: ${situational.tensionLevel.toUpperCase()}
`;
      ctx += `Dialogue Ratio: ${Math.round(situational.currentScene.dialogueRatio * 100)}%
`;
    }
    ctx += `Pacing: ${situational.pacing}
`;
    ctx += `Progress: Scene ${situational.narrativePosition.sceneIndex} of ${situational.narrativePosition.totalScenes} (${situational.narrativePosition.percentComplete}%)

`;
    if (context.activeEntities.length > 0) {
      ctx += `[ACTIVE CHARACTERS/ENTITIES]
`;
      for (const entity of context.activeEntities.slice(0, 6)) {
        ctx += `\u2022 ${entity.name} (${entity.type}) - ${entity.mentionCount} mentions`;
        if (entity.aliases.length > 0) {
          ctx += ` [aliases: ${entity.aliases.slice(0, 2).join(", ")}]`;
        }
        ctx += `
`;
      }
      ctx += `
`;
    }
    if (context.activeRelationships.length > 0) {
      ctx += `[KEY RELATIONSHIPS IN SCENE]
`;
      for (const rel of context.activeRelationships.slice(0, 5)) {
        const source = context.activeEntities.find((e) => e.id === rel.source);
        const target = context.activeEntities.find((e) => e.id === rel.target);
        if (source && target) {
          ctx += `\u2022 ${source.name} \u2190${rel.type}\u2192 ${target.name} (${rel.coOccurrences} interactions)
`;
        }
      }
      ctx += `
`;
    }
    if (context.openPromises.length > 0) {
      ctx += `[OPEN PLOT THREADS - Need Resolution]
`;
      for (const promise of context.openPromises) {
        ctx += `\u26A1 [${promise.type.toUpperCase()}] ${promise.description.slice(0, 80)}...
`;
      }
      ctx += `
`;
    }
    if (context.recentEvents.length > 0) {
      ctx += `[RECENT NARRATIVE EVENTS]
`;
      for (const event of context.recentEvents.slice(-3)) {
        ctx += `\u2192 ${event.description.slice(0, 60)}`;
        if (event.temporalMarker) {
          ctx += ` (${event.temporalMarker})`;
        }
        ctx += `
`;
      }
      ctx += `
`;
    }
    if (styleAlerts.length > 0) {
      ctx += `[STYLE ALERTS]
`;
      for (const alert of styleAlerts) {
        ctx += `\u26A0\uFE0F ${alert}
`;
      }
      ctx += `
`;
    }
    if (prioritizedIssues.length > 0) {
      ctx += `[PRIORITY ISSUES TO ADDRESS]
`;
      for (const issue of prioritizedIssues) {
        const icon = issue.severity > 0.7 ? "\u{1F534}" : issue.severity > 0.4 ? "\u{1F7E1}" : "\u{1F7E2}";
        ctx += `${icon} ${issue.description}
`;
      }
      ctx += `
`;
    }
    ctx += `[MANUSCRIPT METRICS]
`;
    ctx += `Words: ${stats.wordCount.toLocaleString()} | `;
    ctx += `Reading: ~${stats.readingTime} min | `;
    ctx += `Dialogue: ${stats.dialoguePercent}% | `;
    ctx += `Avg Sentence: ${stats.avgSentenceLength} words
`;
    return ctx;
  };
  var createAgentSession = (lore, analysis, fullManuscriptContext, persona, intensity = DEFAULT_CRITIQUE_INTENSITY, experience = DEFAULT_EXPERIENCE, autonomy = DEFAULT_AUTONOMY, intelligenceHUD, interviewTarget) => {
    let loreContext = "";
    if (lore) {
      const chars = lore.characters.map((c) => `
    - Name: ${c.name}
    - Bio: ${c.bio}
    - Arc Summary: ${c.arc}
    - Key Development Suggestion: ${c.developmentSuggestion}
    - Known Inconsistencies: ${c.inconsistencies.map((i) => i.issue).join(", ") || "None"}
    `).join("\n");
      const rules = lore.worldRules.map((r) => `- ${r}`).join("\n");
      loreContext = `
    [LORE BIBLE & CONTEXTUAL MEMORY]
    Do not contradict these established facts about the story.
    
    CHARACTERS:
    ${chars}
    
    WORLD RULES / SETTING DETAILS:
    ${rules}
    `;
    }
    let analysisContext = "";
    if (analysis) {
      analysisContext = `
    [DEEP ANALYSIS INSIGHTS]
    Use these insights to answer questions about plot holes, pacing, and character arcs.
    
    SUMMARY: ${analysis.summary}
    STRENGTHS: ${analysis.strengths.join(", ")}
    WEAKNESSES: ${analysis.weaknesses.join(", ")}
    
    PLOT ISSUES:
    ${analysis.plotIssues.map((p) => `- ${p.issue} (Fix: ${p.suggestion})`).join("\n")}
    
    CHARACTERS (FROM ANALYSIS):
    ${analysis.characters.map((c) => `- ${c.name}: ${c.arc} (Suggestion: ${c.developmentSuggestion})`).join("\n")}
    `;
    }
    const intensityModifier = getIntensityModifier(intensity);
    const experienceModifier = getExperienceModifier(experience);
    const autonomyModifier = getAutonomyModifier(autonomy);
    let systemInstruction = AGENT_SYSTEM_INSTRUCTION.replace("{{INTENSITY_MODIFIER}}", intensityModifier).replace("{{LORE_CONTEXT}}", loreContext).replace("{{ANALYSIS_CONTEXT}}", analysisContext).replace("{{FULL_MANUSCRIPT}}", fullManuscriptContext || "No manuscript content loaded.");
    systemInstruction += `

${experienceModifier}

${autonomyModifier}`;
    if (intelligenceHUD) {
      const intelligenceContext = buildIntelligenceContext(intelligenceHUD);
      systemInstruction += `

${intelligenceContext}`;
    }
    if (interviewTarget) {
      systemInstruction = buildInterviewInstruction(systemInstruction, interviewTarget);
    } else if (persona) {
      systemInstruction = buildPersonaInstruction(systemInstruction, persona);
    }
    return ai.chats.create({
      model: ModelConfig.agent,
      config: {
        systemInstruction,
        tools: [{ functionDeclarations: agentTools }]
      }
    });
  };

  // features/agent/components/PersonaSelector.tsx
  var import_react24 = __toESM(require_react(), 1);
  var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
  var PersonaSelector = ({
    currentPersona,
    onSelectPersona,
    compact = false
  }) => {
    const [isOpen, setIsOpen] = (0, import_react24.useState)(false);
    const dropdownRef = (0, import_react24.useRef)(null);
    (0, import_react24.useEffect)(() => {
      const handleClickOutside = (e) => {
        if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
          setIsOpen(false);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }, []);
    (0, import_react24.useEffect)(() => {
      const handleEscape = (e) => {
        if (e.key === "Escape") setIsOpen(false);
      };
      document.addEventListener("keydown", handleEscape);
      return () => document.removeEventListener("keydown", handleEscape);
    }, []);
    if (compact) {
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "relative", ref: dropdownRef, children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
          "button",
          {
            onClick: () => setIsOpen(!isOpen),
            className: "flex items-center gap-2 px-3 py-1.5 bg-gray-50 hover:bg-gray-100 border border-gray-200 rounded-lg transition-colors",
            title: `Current: ${currentPersona.name}`,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "text-lg", children: currentPersona.icon }),
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "text-sm font-medium text-gray-700", children: currentPersona.name }),
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                "svg",
                {
                  className: `w-4 h-4 text-gray-400 transition-transform ${isOpen ? "rotate-180" : ""}`,
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24",
                  children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
                }
              )
            ]
          }
        ),
        isOpen && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "absolute top-full left-0 mt-1 w-64 bg-white rounded-lg shadow-xl border border-gray-200 py-1 z-50 animate-in fade-in slide-in-from-top-2 duration-150", children: DEFAULT_PERSONAS.map((persona) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
          "button",
          {
            onClick: () => {
              onSelectPersona(persona);
              setIsOpen(false);
            },
            className: `w-full flex items-center gap-3 px-3 py-2 hover:bg-gray-50 transition-colors ${persona.id === currentPersona.id ? "bg-indigo-50" : ""}`,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "text-xl", children: persona.icon }),
              /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex-1 text-left", children: [
                /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex items-center gap-2", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "font-medium text-gray-800 text-sm", children: persona.name }),
                  persona.id === currentPersona.id && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("svg", { className: "w-4 h-4 text-indigo-600", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { fillRule: "evenodd", d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z", clipRule: "evenodd" }) })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "text-xs text-gray-500", children: persona.role })
              ] })
            ]
          },
          persona.id
        )) })
      ] });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "space-y-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("h4", { className: "text-sm font-semibold text-gray-700", children: "Select Persona" }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          "span",
          {
            className: "text-xs px-2 py-0.5 rounded-full",
            style: { backgroundColor: `${currentPersona.color}20`, color: currentPersona.color },
            children: currentPersona.style
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "grid grid-cols-1 gap-2", children: DEFAULT_PERSONAS.map((persona) => {
        const isSelected = persona.id === currentPersona.id;
        return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
          "button",
          {
            onClick: () => onSelectPersona(persona),
            className: `flex items-start gap-3 p-3 rounded-lg border-2 transition-all text-left ${isSelected ? "border-current bg-opacity-10" : "border-gray-200 hover:border-gray-300 bg-white"}`,
            style: isSelected ? { borderColor: persona.color, backgroundColor: `${persona.color}10` } : {},
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "text-2xl mt-0.5", children: persona.icon }),
              /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex-1 min-w-0", children: [
                /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex items-center gap-2", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "font-semibold text-gray-800", children: persona.name }),
                  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                    "span",
                    {
                      className: "text-[10px] font-medium px-1.5 py-0.5 rounded uppercase",
                      style: { backgroundColor: `${persona.color}20`, color: persona.color },
                      children: persona.style
                    }
                  )
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "text-sm text-gray-600 mt-0.5", children: persona.role }),
                /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "text-xs text-gray-400 mt-1 line-clamp-2", children: persona.systemPrompt.split("\n")[0].replace("You are ", "") })
              ] }),
              isSelected && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                "svg",
                {
                  className: "w-5 h-5 shrink-0",
                  style: { color: persona.color },
                  fill: "currentColor",
                  viewBox: "0 0 20 20",
                  children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z", clipRule: "evenodd" })
                }
              )
            ]
          },
          persona.id
        );
      }) })
    ] });
  };

  // node_modules/zustand/esm/vanilla.mjs
  var import_meta = {};
  var createStoreImpl = (createState2) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, getInitialState, subscribe, destroy };
    const initialState = state = createState2(setState, getState, api);
    return api;
  };
  var createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;

  // node_modules/zustand/esm/index.mjs
  var import_react25 = __toESM(require_react(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);
  var import_meta2 = {};
  var { useDebugValue } = import_react25.default;
  var { useSyncExternalStoreWithSelector } = import_with_selector.default;
  var didWarnAboutEqualityFn = false;
  var identity = (arg) => arg;
  function useStore(api, selector = identity, equalityFn) {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
      console.warn(
        "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
      );
      didWarnAboutEqualityFn = true;
    }
    const slice = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getInitialState,
      selector,
      equalityFn
    );
    useDebugValue(slice);
    return slice;
  }
  var createImpl = (createState2) => {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && typeof createState2 !== "function") {
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
      );
    }
    const api = typeof createState2 === "function" ? createStore(createState2) : createState2;
    const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create = (createState2) => createState2 ? createImpl(createState2) : createImpl;

  // node_modules/zustand/esm/middleware.mjs
  var import_meta3 = {};
  function createJSONStorage(getStorage, options) {
    let storage;
    try {
      storage = getStorage();
    } catch (e) {
      return;
    }
    const persistStorage = {
      getItem: (name) => {
        var _a;
        const parse = (str2) => {
          if (str2 === null) {
            return null;
          }
          return JSON.parse(str2, options == null ? void 0 : options.reviver);
        };
        const str = (_a = storage.getItem(name)) != null ? _a : null;
        if (str instanceof Promise) {
          return str.then(parse);
        }
        return parse(str);
      },
      setItem: (name, newValue) => storage.setItem(
        name,
        JSON.stringify(newValue, options == null ? void 0 : options.replacer)
      ),
      removeItem: (name) => storage.removeItem(name)
    };
    return persistStorage;
  }
  var toThenable = (fn) => (input) => {
    try {
      const result = fn(input);
      if (result instanceof Promise) {
        return result;
      }
      return {
        then(onFulfilled) {
          return toThenable(onFulfilled)(result);
        },
        catch(_onRejected) {
          return this;
        }
      };
    } catch (e) {
      return {
        then(_onFulfilled) {
          return this;
        },
        catch(onRejected) {
          return toThenable(onRejected)(e);
        }
      };
    }
  };
  var oldImpl = (config, baseOptions) => (set, get, api) => {
    let options = {
      getStorage: () => localStorage,
      serialize: JSON.stringify,
      deserialize: JSON.parse,
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage;
    try {
      storage = options.getStorage();
    } catch (e) {
    }
    if (!storage) {
      return config(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
          );
          set(...args);
        },
        get,
        api
      );
    }
    const thenableSerialize = toThenable(options.serialize);
    const setItem = () => {
      const state = options.partialize({ ...get() });
      let errorInSync;
      const thenable = thenableSerialize({ state, version: options.version }).then(
        (serializedValue) => storage.setItem(options.name, serializedValue)
      ).catch((e) => {
        errorInSync = e;
      });
      if (errorInSync) {
        throw errorInSync;
      }
      return thenable;
    };
    const savedSetState = api.setState;
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      void setItem();
    };
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
    let stateFromStorage;
    const hydrate = () => {
      var _a;
      if (!storage)
        return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => cb(get()));
      const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
        if (storageValue) {
          return options.deserialize(storageValue);
        }
      }).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              );
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return deserializedStorageValue.state;
          }
        }
      }).then((migratedState) => {
        var _a2;
        stateFromStorage = options.merge(
          migratedState,
          (_a2 = get()) != null ? _a2 : configResult
        );
        set(stateFromStorage, true);
        return setItem();
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options = {
          ...options,
          ...newOptions
        };
        if (newOptions.getStorage) {
          storage = newOptions.getStorage();
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options.name);
      },
      getOptions: () => options,
      rehydrate: () => hydrate(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    hydrate();
    return stateFromStorage || configResult;
  };
  var newImpl = (config, baseOptions) => (set, get, api) => {
    let options = {
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage = options.storage;
    if (!storage) {
      return config(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
          );
          set(...args);
        },
        get,
        api
      );
    }
    const setItem = () => {
      const state = options.partialize({ ...get() });
      return storage.setItem(options.name, {
        state,
        version: options.version
      });
    };
    const savedSetState = api.setState;
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      void setItem();
    };
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
    api.getInitialState = () => configResult;
    let stateFromStorage;
    const hydrate = () => {
      var _a, _b;
      if (!storage)
        return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => {
        var _a2;
        return cb((_a2 = get()) != null ? _a2 : configResult);
      });
      const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              );
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return deserializedStorageValue.state;
          }
        }
      }).then((migratedState) => {
        var _a2;
        stateFromStorage = options.merge(
          migratedState,
          (_a2 = get()) != null ? _a2 : configResult
        );
        set(stateFromStorage, true);
        return setItem();
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        stateFromStorage = get();
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options = {
          ...options,
          ...newOptions
        };
        if (newOptions.storage) {
          storage = newOptions.storage;
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options.name);
      },
      getOptions: () => options,
      rehydrate: () => hydrate(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    if (!options.skipHydration) {
      hydrate();
    }
    return stateFromStorage || configResult;
  };
  var persistImpl = (config, baseOptions) => {
    if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
      if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
        );
      }
      return oldImpl(config, baseOptions);
    }
    return newImpl(config, baseOptions);
  };
  var persist = persistImpl;

  // features/settings/store/useSettingsStore.ts
  var useSettingsStore = create()(
    persist(
      (set) => ({
        critiqueIntensity: DEFAULT_CRITIQUE_INTENSITY,
        experienceLevel: DEFAULT_EXPERIENCE,
        autonomyMode: DEFAULT_AUTONOMY,
        setCritiqueIntensity: (intensity) => {
          set({ critiqueIntensity: intensity });
        },
        setExperienceLevel: (level) => {
          set({ experienceLevel: level });
        },
        setAutonomyMode: (mode) => {
          set({ autonomyMode: mode });
        }
      }),
      {
        name: "quill-settings"
      }
    )
  );

  // features/settings/components/CritiqueIntensitySelector.tsx
  var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
  var CritiqueIntensitySelector = ({
    compact = false
  }) => {
    const { critiqueIntensity, setCritiqueIntensity } = useSettingsStore();
    if (compact) {
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "flex items-center gap-1 bg-slate-800/50 rounded-lg p-1", children: Object.values(CRITIQUE_PRESETS).map((preset) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
        "button",
        {
          onClick: () => setCritiqueIntensity(preset.id),
          className: `
              relative px-2 py-1 rounded text-xs font-medium transition-all
              ${critiqueIntensity === preset.id ? "text-white" : "text-slate-400 hover:text-slate-300"}
            `,
          title: preset.description,
          children: [
            critiqueIntensity === preset.id && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
              motion.div,
              {
                layoutId: "intensity-pill",
                className: "absolute inset-0 rounded",
                style: { backgroundColor: preset.color },
                transition: { type: "spring", stiffness: 400, damping: 30 }
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: "relative z-10", children: preset.icon })
          ]
        },
        preset.id
      )) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "space-y-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("label", { className: "text-sm font-medium text-slate-300", children: "Critique Intensity" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "text-xs text-slate-500 -mt-1", children: "Controls how rigorous the AI feedback is" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "grid grid-cols-1 gap-2", children: Object.values(CRITIQUE_PRESETS).map((preset) => {
        const isActive = critiqueIntensity === preset.id;
        return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
          motion.button,
          {
            onClick: () => setCritiqueIntensity(preset.id),
            whileHover: { scale: 1.01 },
            whileTap: { scale: 0.99 },
            className: `
                relative p-3 rounded-lg border-2 transition-all text-left
                ${isActive ? "border-opacity-100 bg-opacity-10" : "border-slate-700 hover:border-slate-600 bg-transparent"}
              `,
            style: {
              borderColor: isActive ? preset.color : void 0,
              backgroundColor: isActive ? `${preset.color}15` : void 0
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex items-start gap-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: "text-2xl", children: preset.icon }),
              /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex-1 min-w-0", children: [
                /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "font-medium text-slate-200 flex items-center gap-2", children: [
                  preset.label,
                  isActive && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                    "span",
                    {
                      className: "text-xs px-1.5 py-0.5 rounded",
                      style: { backgroundColor: preset.color, color: "white" },
                      children: "Active"
                    }
                  )
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "text-xs text-slate-400 mt-0.5", children: preset.description })
              ] })
            ] })
          },
          preset.id
        );
      }) })
    ] });
  };

  // features/settings/components/ExperienceSelector.tsx
  var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
  var ExperienceSelector = ({
    compact = false,
    showLabels = true
  }) => {
    const { experienceLevel, autonomyMode, setExperienceLevel, setAutonomyMode } = useSettingsStore();
    if (compact) {
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "flex items-center gap-1 bg-slate-800/50 rounded-lg p-1", children: Object.values(EXPERIENCE_PRESETS).map((preset) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
          "button",
          {
            onClick: () => setExperienceLevel(preset.id),
            className: `
                relative px-2 py-1 rounded text-xs font-medium transition-all
                ${experienceLevel === preset.id ? "text-white" : "text-slate-400 hover:text-slate-300"}
              `,
            title: `${preset.label}: ${preset.description}`,
            children: [
              experienceLevel === preset.id && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                motion.div,
                {
                  layoutId: "experience-pill",
                  className: "absolute inset-0 rounded",
                  style: { backgroundColor: preset.color },
                  transition: { type: "spring", stiffness: 400, damping: 30 }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10", children: preset.icon })
            ]
          },
          preset.id
        )) }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "w-px h-4 bg-slate-600" }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "flex items-center gap-1 bg-slate-800/50 rounded-lg p-1", children: Object.values(AUTONOMY_PRESETS).map((preset) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
          "button",
          {
            onClick: () => setAutonomyMode(preset.id),
            className: `
                relative px-2 py-1 rounded text-xs font-medium transition-all
                ${autonomyMode === preset.id ? "text-white" : "text-slate-400 hover:text-slate-300"}
              `,
            title: `${preset.label}: ${preset.description}`,
            children: [
              autonomyMode === preset.id && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                motion.div,
                {
                  layoutId: "autonomy-pill",
                  className: "absolute inset-0 rounded",
                  style: { backgroundColor: preset.color },
                  transition: { type: "spring", stiffness: 400, damping: 30 }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10", children: preset.icon })
            ]
          },
          preset.id
        )) })
      ] });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "space-y-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "space-y-2", children: [
        showLabels && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("label", { className: "text-sm font-medium text-slate-300", children: "Experience Level" }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-xs text-slate-500 -mt-1", children: "Adjusts explanation depth and terminology" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "grid grid-cols-3 gap-2", children: Object.values(EXPERIENCE_PRESETS).map((preset) => {
          const isActive = experienceLevel === preset.id;
          return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
            motion.button,
            {
              onClick: () => setExperienceLevel(preset.id),
              whileHover: { scale: 1.02 },
              whileTap: { scale: 0.98 },
              className: `
                  relative p-2 rounded-lg border-2 transition-all text-center
                  ${isActive ? "border-opacity-100" : "border-slate-700 hover:border-slate-600"}
                `,
              style: {
                borderColor: isActive ? preset.color : void 0,
                backgroundColor: isActive ? `${preset.color}15` : void 0
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "text-lg", children: preset.icon }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "text-xs font-medium text-slate-300 mt-1", children: preset.label })
              ]
            },
            preset.id
          );
        }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "space-y-2", children: [
        showLabels && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("label", { className: "text-sm font-medium text-slate-300", children: "Autonomy Mode" }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-xs text-slate-500 -mt-1", children: "Controls how independently the AI acts" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "grid grid-cols-3 gap-2", children: Object.values(AUTONOMY_PRESETS).map((preset) => {
          const isActive = autonomyMode === preset.id;
          return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
            motion.button,
            {
              onClick: () => setAutonomyMode(preset.id),
              whileHover: { scale: 1.02 },
              whileTap: { scale: 0.98 },
              className: `
                  relative p-2 rounded-lg border-2 transition-all text-center
                  ${isActive ? "border-opacity-100" : "border-slate-700 hover:border-slate-600"}
                `,
              style: {
                borderColor: isActive ? preset.color : void 0,
                backgroundColor: isActive ? `${preset.color}15` : void 0
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "text-lg", children: preset.icon }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "text-xs font-medium text-slate-300 mt-1", children: preset.label })
              ]
            },
            preset.id
          );
        }) })
      ] })
    ] });
  };

  // features/agent/components/ChatInterface.tsx
  var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
  var messageVariants = {
    hidden: { opacity: 0, y: 20, scale: 0.95 },
    visible: {
      opacity: 1,
      y: 0,
      scale: 1,
      transition: { type: "spring", stiffness: 400, damping: 30 }
    },
    exit: { opacity: 0, scale: 0.95, transition: { duration: 0.15 } }
  };
  var ChatInterface = ({
    editorContext,
    fullText,
    onAgentAction,
    lore,
    chapters = [],
    analysis,
    initialMessage,
    onInitialMessageProcessed,
    initialPersona,
    interviewTarget = null,
    onExitInterview
  }) => {
    const [messages, setMessages] = (0, import_react26.useState)([]);
    const [input, setInput] = (0, import_react26.useState)("");
    const [isLoading, setIsLoading] = (0, import_react26.useState)(false);
    const [agentState, setAgentState] = (0, import_react26.useState)("idle");
    const [currentPersona, setCurrentPersona] = (0, import_react26.useState)(initialPersona || DEFAULT_PERSONAS[0]);
    const chatRef = (0, import_react26.useRef)(null);
    const messagesEndRef = (0, import_react26.useRef)(null);
    const personaRef = (0, import_react26.useRef)(currentPersona);
    const isInterviewMode = Boolean(interviewTarget);
    const initializeSession = () => {
      const fullManuscript = chapters.map((c) => {
        const isActive = c.content === fullText;
        return `[CHAPTER: ${c.title}]${isActive ? " (ACTIVE - You can edit this)" : " (READ ONLY - Request user to switch)"}
${c.content}
`;
      }).join("\n-------------------\n");
      const { critiqueIntensity, experienceLevel, autonomyMode } = useSettingsStore.getState();
      const personaForSession = isInterviewMode ? void 0 : personaRef.current;
      chatRef.current = createAgentSession(
        lore,
        analysis || void 0,
        fullManuscript,
        personaForSession,
        critiqueIntensity,
        experienceLevel,
        autonomyMode,
        void 0,
        interviewTarget || void 0
      );
      const init = async () => {
        const intro = isInterviewMode && interviewTarget ? `I have loaded the manuscript. Total Chapters: ${chapters.length}. Active Chapter Length: ${fullText.length} characters. I am ${interviewTarget.name}, speaking in interview mode. Ask me anything about my story or choices.` : `I have loaded the manuscript. Total Chapters: ${chapters.length}. Active Chapter Length: ${fullText.length} characters. I am ${personaRef.current.name}, ready to help with my ${personaRef.current.role} expertise.`;
        await chatRef.current?.sendMessage({
          message: intro
        });
      };
      init();
    };
    (0, import_react26.useEffect)(() => {
      initializeSession();
    }, [lore, analysis, chapters, fullText, interviewTarget]);
    const handlePersonaChange = (persona) => {
      onExitInterview?.();
      setCurrentPersona(persona);
      personaRef.current = persona;
      chatRef.current = null;
      initializeSession();
      setMessages((prev) => [...prev, {
        role: "model",
        text: `${persona.icon} Switching to ${persona.name} mode. ${persona.role}.`,
        timestamp: /* @__PURE__ */ new Date()
      }]);
    };
    (0, import_react26.useEffect)(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, [messages, agentState]);
    (0, import_react26.useEffect)(() => {
      if (initialMessage && chatRef.current && !isLoading) {
        setInput(initialMessage);
        const timer = setTimeout(() => {
          sendMessageWithText(initialMessage);
          if (onInitialMessageProcessed) {
            onInitialMessageProcessed();
          }
        }, 100);
        return () => clearTimeout(timer);
      }
    }, [initialMessage]);
    const sendMessageWithText = async (messageText) => {
      if (!messageText.trim() || !chatRef.current) return;
      const userMsg = { role: "user", text: messageText, timestamp: /* @__PURE__ */ new Date() };
      setMessages((prev) => [...prev, userMsg]);
      setInput("");
      setIsLoading(true);
      setAgentState("thinking");
      try {
        const contextPrompt = `
      [USER CONTEXT]
      Cursor Index: ${editorContext.cursorPosition}
      Selection: ${editorContext.selection ? `"${editorContext.selection.text}"` : "None"}
      Total Text Length: ${editorContext.totalLength}
      
      [USER REQUEST]
      ${messageText}
      `;
        let result = await chatRef.current.sendMessage({ message: contextPrompt });
        while (result.functionCalls && result.functionCalls.length > 0) {
          setAgentState("writing");
          const functionResponses = [];
          for (const call of result.functionCalls) {
            setMessages((prev) => [...prev, {
              role: "model",
              text: `\u{1F6E0}\uFE0F Suggesting Action: ${call.name}...`,
              timestamp: /* @__PURE__ */ new Date()
            }]);
            try {
              const actionResult = await onAgentAction(call.name, call.args);
              functionResponses.push({
                id: call.id,
                name: call.name,
                response: { result: actionResult }
              });
              if (actionResult.includes("Waiting for user review")) {
                setMessages((prev) => [...prev, {
                  role: "model",
                  text: `\u{1F4DD} Reviewing proposed edit...`,
                  timestamp: /* @__PURE__ */ new Date()
                }]);
              }
            } catch (err) {
              const errorMsg = err.message || "Unknown error";
              setMessages((prev) => [...prev, {
                role: "model",
                text: `\u274C Error: ${errorMsg}`,
                timestamp: /* @__PURE__ */ new Date()
              }]);
              functionResponses.push({
                id: call.id,
                name: call.name,
                response: { result: errorMsg }
              });
            }
          }
          setAgentState("thinking");
          result = await chatRef.current.sendMessage({
            message: functionResponses.map((resp) => ({ functionResponse: resp }))
          });
        }
        const responseText = result.text;
        setMessages((prev) => [...prev, {
          role: "model",
          text: responseText || "Done.",
          timestamp: /* @__PURE__ */ new Date()
        }]);
      } catch (e) {
        console.error(e);
        setMessages((prev) => [...prev, {
          role: "model",
          text: "Sorry, I encountered an error connecting to the Agent.",
          timestamp: /* @__PURE__ */ new Date()
        }]);
      } finally {
        setIsLoading(false);
        setAgentState("idle");
      }
    };
    const sendMessage = () => {
      sendMessageWithText(input);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-col h-full bg-white relative", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "bg-gray-50 border-b border-gray-100 px-4 py-2 space-y-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center justify-between", children: [
          isInterviewMode && interviewTarget ? /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center gap-3 px-3 py-2 bg-[var(--magic-50)] border border-[var(--magic-200)] rounded-lg", children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "w-10 h-10 rounded-full bg-gradient-to-br from-[var(--magic-300)] to-[var(--magic-500)] text-white flex items-center justify-center font-semibold", children: interviewTarget.name.charAt(0).toUpperCase() }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "leading-tight", children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "text-[10px] uppercase tracking-wide text-[var(--magic-700)] font-semibold", children: "Roleplay Active" }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "text-sm font-semibold text-[var(--ink-800)]", children: interviewTarget.name })
              ] })
            ] }),
            onExitInterview && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
              "button",
              {
                onClick: onExitInterview,
                className: "text-xs px-3 py-2 border border-[var(--magic-300)] text-[var(--magic-700)] rounded-md hover:bg-[var(--magic-50)] transition-colors",
                children: "Exit Interview"
              }
            )
          ] }) : /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            PersonaSelector,
            {
              currentPersona,
              onSelectPersona: handlePersonaChange,
              compact: true
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ExperienceSelector, { compact: true }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "w-px h-4 bg-gray-300" }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CritiqueIntensitySelector, { compact: true }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex gap-2 text-xs ml-1", children: [
              lore && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { title: "Lore Bible Active", className: "text-indigo-600 font-bold", children: "\u{1F4D6}" }),
              analysis && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { title: "Deep Analysis Context Active", className: "text-purple-600 font-bold", children: "\u{1F9E0}" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center justify-between text-xs text-gray-500", children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: `w-2 h-2 rounded-full ${editorContext.selection ? "bg-indigo-500" : "bg-gray-300"}` }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { children: editorContext.selection ? "Selection Active" : "Cursor Active" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "font-mono", children: [
            "Ln ",
            Math.floor(editorContext.cursorPosition / 80) + 1,
            " : Col ",
            editorContext.cursorPosition % 80
          ] })
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex-1 overflow-y-auto p-4 space-y-4", children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(AnimatePresence, { mode: "popLayout", children: messages.map((msg, idx) => {
          const isUser = msg.role === "user";
          const showCharacterAvatar = isInterviewMode && msg.role === "model" && interviewTarget;
          return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            motion.div,
            {
              variants: messageVariants,
              initial: "hidden",
              animate: "visible",
              exit: "exit",
              layout: true,
              className: `flex ${isUser ? "justify-end" : "justify-start"}`,
              children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(motion.div, { className: `flex ${showCharacterAvatar ? "gap-2" : ""} max-w-[90%]`, children: [
                showCharacterAvatar && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-col items-center gap-1 shrink-0", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "w-9 h-9 rounded-full bg-gradient-to-br from-[var(--magic-300)] to-[var(--magic-500)] text-white flex items-center justify-center font-semibold", children: interviewTarget?.name.charAt(0).toUpperCase() }),
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-[10px] text-[var(--ink-400)] leading-none", children: interviewTarget?.name })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                  motion.div,
                  {
                    className: `rounded-2xl px-4 py-3 text-sm shadow-sm ${isUser ? "bg-indigo-600 text-white" : "bg-gray-100 text-gray-800"}`,
                    whileHover: { scale: 1.01 },
                    transition: { type: "spring", stiffness: 400, damping: 30 },
                    children: msg.text
                  }
                )
              ] })
            },
            `${idx}-${msg.role}`
          );
        }) }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(AnimatePresence, { children: agentState !== "idle" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          motion.div,
          {
            initial: { opacity: 0, y: 10 },
            animate: { opacity: 1, y: 0 },
            exit: { opacity: 0, y: -10 },
            className: "flex justify-start",
            children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "bg-[var(--surface-secondary)] border border-[var(--border-primary)] rounded-2xl px-4 py-3 rounded-bl-none flex items-center gap-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex space-x-1", children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                  motion.div,
                  {
                    className: "w-2 h-2 bg-[var(--interactive-accent)] rounded-full",
                    animate: { y: [0, -6, 0] },
                    transition: { duration: 0.6, repeat: Infinity, delay: 0 }
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                  motion.div,
                  {
                    className: "w-2 h-2 bg-[var(--interactive-accent)] rounded-full",
                    animate: { y: [0, -6, 0] },
                    transition: { duration: 0.6, repeat: Infinity, delay: 0.1 }
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                  motion.div,
                  {
                    className: "w-2 h-2 bg-[var(--interactive-accent)] rounded-full",
                    animate: { y: [0, -6, 0] },
                    transition: { duration: 0.6, repeat: Infinity, delay: 0.2 }
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-xs text-[var(--interactive-accent)] font-medium", children: agentState === "thinking" ? "Reasoning..." : "Editing Manuscript..." })
            ] })
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { ref: messagesEndRef })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "p-4 border-t border-gray-100 bg-white", children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "input",
            {
              type: "text",
              className: "flex-1 border border-gray-300 rounded-lg px-4 py-3 text-sm focus:outline-none focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition-shadow disabled:bg-gray-100 disabled:text-gray-400",
              placeholder: "Type / to use tools or ask Agent to edit...",
              value: input,
              onChange: (e) => setInput(e.target.value),
              onKeyDown: (e) => e.key === "Enter" && sendMessage(),
              disabled: isLoading
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "button",
            {
              onClick: sendMessage,
              disabled: !input.trim() || isLoading,
              className: "bg-indigo-600 text-white rounded-lg p-3 hover:bg-indigo-700 disabled:opacity-50 transition-colors shadow-sm",
              children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-5 h-5", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { d: "M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z" }) })
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "text-[10px] text-gray-400 mt-2 text-center", children: "Agent can read your selection and edit text directly." })
      ] })
    ] });
  };
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
  (**
   * @license
   * Copyright 2025 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
